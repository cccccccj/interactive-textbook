<html><head><!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><meta charset="UTF-8"></head><body><div hidden="" by-vulcanize=""><div hidden="" by-vulcanize=""><script>(function () {
function resolve() {
document.body.removeAttribute('unresolved');
}
if (window.WebComponents) {
addEventListener('WebComponentsReady', resolve);
} else {
if (document.readyState === 'interactive' || document.readyState === 'complete') {
resolve();
} else {
addEventListener('DOMContentLoaded', resolve);
}
}
}());window.Polymer = {
Settings: function () {
var settings = window.Polymer || {};
if (!settings.noUrlSettings) {
var parts = location.search.slice(1).split('&');
for (var i = 0, o; i < parts.length && (o = parts[i]); i++) {
o = o.split('=');
o[0] && (settings[o[0]] = o[1] || true);
}
}
settings.wantShadow = settings.dom === 'shadow';
settings.hasShadow = Boolean(Element.prototype.createShadowRoot);
settings.nativeShadow = settings.hasShadow && !window.ShadowDOMPolyfill;
settings.useShadow = settings.wantShadow && settings.hasShadow;
settings.hasNativeImports = Boolean('import' in document.createElement('link'));
settings.useNativeImports = settings.hasNativeImports;
settings.useNativeCustomElements = !window.CustomElements || window.CustomElements.useNative;
settings.useNativeShadow = settings.useShadow && settings.nativeShadow;
settings.usePolyfillProto = !settings.useNativeCustomElements && !Object.__proto__;
settings.hasNativeCSSProperties = !navigator.userAgent.match('AppleWebKit/601') && window.CSS && CSS.supports && CSS.supports('box-shadow', '0 0 0 var(--foo)');
settings.useNativeCSSProperties = settings.hasNativeCSSProperties && settings.lazyRegister && settings.useNativeCSSProperties;
settings.isIE = navigator.userAgent.match('Trident');
return settings;
}()
};(function () {
var userPolymer = window.Polymer;
window.Polymer = function (prototype) {
if (typeof prototype === 'function') {
prototype = prototype.prototype;
}
if (!prototype) {
prototype = {};
}
prototype = desugar(prototype);
var customCtor = prototype === prototype.constructor.prototype ? prototype.constructor : null;
var options = { prototype: prototype };
if (prototype.extends) {
options.extends = prototype.extends;
}
Polymer.telemetry._registrate(prototype);
var ctor = document.registerElement(prototype.is, options);
return customCtor || ctor;
};
var desugar = function (prototype) {
var base = Polymer.Base;
if (prototype.extends) {
base = Polymer.Base._getExtendedPrototype(prototype.extends);
}
prototype = Polymer.Base.chainObject(prototype, base);
prototype.registerCallback();
return prototype;
};
if (userPolymer) {
for (var i in userPolymer) {
Polymer[i] = userPolymer[i];
}
}
Polymer.Class = function (prototype) {
if (!prototype.factoryImpl) {
prototype.factoryImpl = function () {
};
}
return desugar(prototype).constructor;
};
}());
Polymer.telemetry = {
registrations: [],
_regLog: function (prototype) {
console.log('[' + prototype.is + ']: registered');
},
_registrate: function (prototype) {
this.registrations.push(prototype);
Polymer.log && this._regLog(prototype);
},
dumpRegistrations: function () {
this.registrations.forEach(this._regLog);
}
};Object.defineProperty(window, 'currentImport', {
enumerable: true,
configurable: true,
get: function () {
return (document._currentScript || document.currentScript || {}).ownerDocument;
}
});Polymer.RenderStatus = {
_ready: false,
_callbacks: [],
whenReady: function (cb) {
if (this._ready) {
cb();
} else {
this._callbacks.push(cb);
}
},
_makeReady: function () {
this._ready = true;
for (var i = 0; i < this._callbacks.length; i++) {
this._callbacks[i]();
}
this._callbacks = [];
},
_catchFirstRender: function () {
requestAnimationFrame(function () {
Polymer.RenderStatus._makeReady();
});
},
_afterNextRenderQueue: [],
_waitingNextRender: false,
afterNextRender: function (element, fn, args) {
this._watchNextRender();
this._afterNextRenderQueue.push([
element,
fn,
args
]);
},
hasRendered: function () {
return this._ready;
},
_watchNextRender: function () {
if (!this._waitingNextRender) {
this._waitingNextRender = true;
var fn = function () {
Polymer.RenderStatus._flushNextRender();
};
if (!this._ready) {
this.whenReady(fn);
} else {
requestAnimationFrame(fn);
}
}
},
_flushNextRender: function () {
var self = this;
setTimeout(function () {
self._flushRenderCallbacks(self._afterNextRenderQueue);
self._afterNextRenderQueue = [];
self._waitingNextRender = false;
});
},
_flushRenderCallbacks: function (callbacks) {
for (var i = 0, h; i < callbacks.length; i++) {
h = callbacks[i];
h[1].apply(h[0], h[2] || Polymer.nar);
}
}
};
if (window.HTMLImports) {
HTMLImports.whenReady(function () {
Polymer.RenderStatus._catchFirstRender();
});
} else {
Polymer.RenderStatus._catchFirstRender();
}
Polymer.ImportStatus = Polymer.RenderStatus;
Polymer.ImportStatus.whenLoaded = Polymer.ImportStatus.whenReady;(function () {
'use strict';
var settings = Polymer.Settings;
Polymer.Base = {
__isPolymerInstance__: true,
_addFeature: function (feature) {
this.mixin(this, feature);
},
registerCallback: function () {
if (settings.lazyRegister === 'max') {
if (this.beforeRegister) {
this.beforeRegister();
}
} else {
this._desugarBehaviors();
for (var i = 0, b; i < this.behaviors.length; i++) {
b = this.behaviors[i];
if (b.beforeRegister) {
b.beforeRegister.call(this);
}
}
if (this.beforeRegister) {
this.beforeRegister();
}
}
this._registerFeatures();
if (!settings.lazyRegister) {
this.ensureRegisterFinished();
}
},
createdCallback: function () {
if (settings.disableUpgradeEnabled) {
if (this.hasAttribute('disable-upgrade')) {
this._propertySetter = disableUpgradePropertySetter;
this._configValue = null;
this.__data__ = {};
return;
} else {
this.__hasInitialized = true;
}
}
this.__initialize();
},
__initialize: function () {
if (!this.__hasRegisterFinished) {
this._ensureRegisterFinished(this.__proto__);
}
Polymer.telemetry.instanceCount++;
this.root = this;
for (var i = 0, b; i < this.behaviors.length; i++) {
b = this.behaviors[i];
if (b.created) {
b.created.call(this);
}
}
if (this.created) {
this.created();
}
this._initFeatures();
},
ensureRegisterFinished: function () {
this._ensureRegisterFinished(this);
},
_ensureRegisterFinished: function (proto) {
if (proto.__hasRegisterFinished !== proto.is || !proto.is) {
if (settings.lazyRegister === 'max') {
proto._desugarBehaviors();
for (var i = 0, b; i < proto.behaviors.length; i++) {
b = proto.behaviors[i];
if (b.beforeRegister) {
b.beforeRegister.call(proto);
}
}
}
proto.__hasRegisterFinished = proto.is;
if (proto._finishRegisterFeatures) {
proto._finishRegisterFeatures();
}
for (var j = 0, pb; j < proto.behaviors.length; j++) {
pb = proto.behaviors[j];
if (pb.registered) {
pb.registered.call(proto);
}
}
if (proto.registered) {
proto.registered();
}
if (settings.usePolyfillProto && proto !== this) {
proto.extend(this, proto);
}
}
},
attachedCallback: function () {
var self = this;
Polymer.RenderStatus.whenReady(function () {
self.isAttached = true;
for (var i = 0, b; i < self.behaviors.length; i++) {
b = self.behaviors[i];
if (b.attached) {
b.attached.call(self);
}
}
if (self.attached) {
self.attached();
}
});
},
detachedCallback: function () {
var self = this;
Polymer.RenderStatus.whenReady(function () {
self.isAttached = false;
for (var i = 0, b; i < self.behaviors.length; i++) {
b = self.behaviors[i];
if (b.detached) {
b.detached.call(self);
}
}
if (self.detached) {
self.detached();
}
});
},
attributeChangedCallback: function (name, oldValue, newValue) {
this._attributeChangedImpl(name);
for (var i = 0, b; i < this.behaviors.length; i++) {
b = this.behaviors[i];
if (b.attributeChanged) {
b.attributeChanged.call(this, name, oldValue, newValue);
}
}
if (this.attributeChanged) {
this.attributeChanged(name, oldValue, newValue);
}
},
_attributeChangedImpl: function (name) {
this._setAttributeToProperty(this, name);
},
extend: function (target, source) {
if (target && source) {
var n$ = Object.getOwnPropertyNames(source);
for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
this.copyOwnProperty(n, source, target);
}
}
return target || source;
},
mixin: function (target, source) {
for (var i in source) {
target[i] = source[i];
}
return target;
},
copyOwnProperty: function (name, source, target) {
var pd = Object.getOwnPropertyDescriptor(source, name);
if (pd) {
Object.defineProperty(target, name, pd);
}
},
_logger: function (level, args) {
if (args.length === 1 && Array.isArray(args[0])) {
args = args[0];
}
switch (level) {
case 'log':
case 'warn':
case 'error':
console[level].apply(console, args);
break;
}
},
_log: function () {
var args = Array.prototype.slice.call(arguments, 0);
this._logger('log', args);
},
_warn: function () {
var args = Array.prototype.slice.call(arguments, 0);
this._logger('warn', args);
},
_error: function () {
var args = Array.prototype.slice.call(arguments, 0);
this._logger('error', args);
},
_logf: function () {
return this._logPrefix.concat(this.is).concat(Array.prototype.slice.call(arguments, 0));
}
};
Polymer.Base._logPrefix = function () {
var color = window.chrome && !/edge/i.test(navigator.userAgent) || /firefox/i.test(navigator.userAgent);
return color ? [
'%c[%s::%s]:',
'font-weight: bold; background-color:#EEEE00;'
] : ['[%s::%s]:'];
}();
Polymer.Base.chainObject = function (object, inherited) {
if (object && inherited && object !== inherited) {
if (!Object.__proto__) {
object = Polymer.Base.extend(Object.create(inherited), object);
}
object.__proto__ = inherited;
}
return object;
};
Polymer.Base = Polymer.Base.chainObject(Polymer.Base, HTMLElement.prototype);
Polymer.BaseDescriptors = {};
var disableUpgradePropertySetter;
if (settings.disableUpgradeEnabled) {
disableUpgradePropertySetter = function (property, value) {
this.__data__[property] = value;
};
var origAttributeChangedCallback = Polymer.Base.attributeChangedCallback;
Polymer.Base.attributeChangedCallback = function (name, oldValue, newValue) {
if (!this.__hasInitialized && name === 'disable-upgrade') {
this.__hasInitialized = true;
this._propertySetter = Polymer.Bind._modelApi._propertySetter;
this._configValue = Polymer.Base._configValue;
this.__initialize();
}
origAttributeChangedCallback.call(this, name, oldValue, newValue);
};
}
if (window.CustomElements) {
Polymer.instanceof = CustomElements.instanceof;
} else {
Polymer.instanceof = function (obj, ctor) {
return obj instanceof ctor;
};
}
Polymer.isInstance = function (obj) {
return Boolean(obj && obj.__isPolymerInstance__);
};
Polymer.telemetry.instanceCount = 0;
}());(function () {
var modules = {};
var lcModules = {};
var findModule = function (id) {
return modules[id] || lcModules[id.toLowerCase()];
};
var DomModule = function () {
return document.createElement('dom-module');
};
DomModule.prototype = Object.create(HTMLElement.prototype);
Polymer.Base.mixin(DomModule.prototype, {
createdCallback: function () {
this.register();
},
register: function (id) {
id = id || this.id || this.getAttribute('name') || this.getAttribute('is');
if (id) {
this.id = id;
modules[id] = this;
lcModules[id.toLowerCase()] = this;
}
},
import: function (id, selector) {
if (id) {
var m = findModule(id);
if (!m) {
forceDomModulesUpgrade();
m = findModule(id);
}
if (m && selector) {
m = m.querySelector(selector);
}
return m;
}
}
});
Object.defineProperty(DomModule.prototype, 'constructor', {
value: DomModule,
configurable: true,
writable: true
});
var cePolyfill = window.CustomElements && !CustomElements.useNative;
document.registerElement('dom-module', DomModule);
function forceDomModulesUpgrade() {
if (cePolyfill) {
var script = document._currentScript || document.currentScript;
var doc = script && script.ownerDocument || document;
var modules = doc.querySelectorAll('dom-module');
for (var i = modules.length - 1, m; i >= 0 && (m = modules[i]); i--) {
if (m.__upgraded__) {
return;
} else {
CustomElements.upgrade(m);
}
}
}
}
}());Polymer.Base._addFeature({
_prepIs: function () {
if (!this.is) {
var module = (document._currentScript || document.currentScript).parentNode;
if (module.localName === 'dom-module') {
var id = module.id || module.getAttribute('name') || module.getAttribute('is');
this.is = id;
}
}
if (this.is) {
this.is = this.is.toLowerCase();
}
}
});Polymer.Base._addFeature({
behaviors: [],
_desugarBehaviors: function () {
if (this.behaviors.length) {
this.behaviors = this._desugarSomeBehaviors(this.behaviors);
}
},
_desugarSomeBehaviors: function (behaviors) {
var behaviorSet = [];
behaviors = this._flattenBehaviorsList(behaviors);
for (var i = behaviors.length - 1; i >= 0; i--) {
var b = behaviors[i];
if (behaviorSet.indexOf(b) === -1) {
this._mixinBehavior(b);
behaviorSet.unshift(b);
}
}
return behaviorSet;
},
_flattenBehaviorsList: function (behaviors) {
var flat = [];
for (var i = 0; i < behaviors.length; i++) {
var b = behaviors[i];
if (b instanceof Array) {
flat = flat.concat(this._flattenBehaviorsList(b));
} else if (b) {
flat.push(b);
} else {
this._warn(this._logf('_flattenBehaviorsList', 'behavior is null, check for missing or 404 import'));
}
}
return flat;
},
_mixinBehavior: function (b) {
var n$ = Object.getOwnPropertyNames(b);
var useAssignment = b._noAccessors;
for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
if (!Polymer.Base._behaviorProperties[n] && !this.hasOwnProperty(n)) {
if (useAssignment) {
this[n] = b[n];
} else {
this.copyOwnProperty(n, b, this);
}
}
}
},
_prepBehaviors: function () {
this._prepFlattenedBehaviors(this.behaviors);
},
_prepFlattenedBehaviors: function (behaviors) {
for (var i = 0, l = behaviors.length; i < l; i++) {
this._prepBehavior(behaviors[i]);
}
this._prepBehavior(this);
},
_marshalBehaviors: function () {
for (var i = 0; i < this.behaviors.length; i++) {
this._marshalBehavior(this.behaviors[i]);
}
this._marshalBehavior(this);
}
});
Polymer.Base._behaviorProperties = {
hostAttributes: true,
beforeRegister: true,
registered: true,
properties: true,
observers: true,
listeners: true,
created: true,
attached: true,
detached: true,
attributeChanged: true,
ready: true,
_noAccessors: true
};Polymer.Base._addFeature({
_getExtendedPrototype: function (tag) {
return this._getExtendedNativePrototype(tag);
},
_nativePrototypes: {},
_getExtendedNativePrototype: function (tag) {
var p = this._nativePrototypes[tag];
if (!p) {
p = Object.create(this.getNativePrototype(tag));
var p$ = Object.getOwnPropertyNames(Polymer.Base);
for (var i = 0, n; i < p$.length && (n = p$[i]); i++) {
if (!Polymer.BaseDescriptors[n]) {
p[n] = Polymer.Base[n];
}
}
Object.defineProperties(p, Polymer.BaseDescriptors);
this._nativePrototypes[tag] = p;
}
return p;
},
getNativePrototype: function (tag) {
return Object.getPrototypeOf(document.createElement(tag));
}
});Polymer.Base._addFeature({
_prepConstructor: function () {
this._factoryArgs = this.extends ? [
this.extends,
this.is
] : [this.is];
var ctor = function () {
return this._factory(arguments);
};
if (this.hasOwnProperty('extends')) {
ctor.extends = this.extends;
}
Object.defineProperty(this, 'constructor', {
value: ctor,
writable: true,
configurable: true
});
ctor.prototype = this;
},
_factory: function (args) {
var elt = document.createElement.apply(document, this._factoryArgs);
if (this.factoryImpl) {
this.factoryImpl.apply(elt, args);
}
return elt;
}
});Polymer.nob = Object.create(null);
Polymer.Base._addFeature({
getPropertyInfo: function (property) {
var info = this._getPropertyInfo(property, this.properties);
if (!info) {
for (var i = 0; i < this.behaviors.length; i++) {
info = this._getPropertyInfo(property, this.behaviors[i].properties);
if (info) {
return info;
}
}
}
return info || Polymer.nob;
},
_getPropertyInfo: function (property, properties) {
var p = properties && properties[property];
if (typeof p === 'function') {
p = properties[property] = { type: p };
}
if (p) {
p.defined = true;
}
return p;
},
_prepPropertyInfo: function () {
this._propertyInfo = {};
for (var i = 0; i < this.behaviors.length; i++) {
this._addPropertyInfo(this._propertyInfo, this.behaviors[i].properties);
}
this._addPropertyInfo(this._propertyInfo, this.properties);
this._addPropertyInfo(this._propertyInfo, this._propertyEffects);
},
_addPropertyInfo: function (target, source) {
if (source) {
var t, s;
for (var i in source) {
t = target[i];
s = source[i];
if (i[0] === '_' && !s.readOnly) {
continue;
}
if (!target[i]) {
target[i] = {
type: typeof s === 'function' ? s : s.type,
readOnly: s.readOnly,
attribute: Polymer.CaseMap.camelToDashCase(i)
};
} else {
if (!t.type) {
t.type = s.type;
}
if (!t.readOnly) {
t.readOnly = s.readOnly;
}
}
}
}
}
});
(function () {
var propertiesDesc = {
configurable: true,
writable: true,
enumerable: true,
value: {}
};
Polymer.BaseDescriptors.properties = propertiesDesc;
Object.defineProperty(Polymer.Base, 'properties', propertiesDesc);
}());Polymer.CaseMap = {
_caseMap: {},
_rx: {
dashToCamel: /-[a-z]/g,
camelToDash: /([A-Z])/g
},
dashToCamelCase: function (dash) {
return this._caseMap[dash] || (this._caseMap[dash] = dash.indexOf('-') < 0 ? dash : dash.replace(this._rx.dashToCamel, function (m) {
return m[1].toUpperCase();
}));
},
camelToDashCase: function (camel) {
return this._caseMap[camel] || (this._caseMap[camel] = camel.replace(this._rx.camelToDash, '-$1').toLowerCase());
}
};Polymer.Base._addFeature({
_addHostAttributes: function (attributes) {
if (!this._aggregatedAttributes) {
this._aggregatedAttributes = {};
}
if (attributes) {
this.mixin(this._aggregatedAttributes, attributes);
}
},
_marshalHostAttributes: function () {
if (this._aggregatedAttributes) {
this._applyAttributes(this, this._aggregatedAttributes);
}
},
_applyAttributes: function (node, attr$) {
for (var n in attr$) {
if (!this.hasAttribute(n) && n !== 'class') {
var v = attr$[n];
this.serializeValueToAttribute(v, n, this);
}
}
},
_marshalAttributes: function () {
this._takeAttributesToModel(this);
},
_takeAttributesToModel: function (model) {
if (this.hasAttributes()) {
for (var i in this._propertyInfo) {
var info = this._propertyInfo[i];
if (this.hasAttribute(info.attribute)) {
this._setAttributeToProperty(model, info.attribute, i, info);
}
}
}
},
_setAttributeToProperty: function (model, attribute, property, info) {
if (!this._serializing) {
property = property || Polymer.CaseMap.dashToCamelCase(attribute);
info = info || this._propertyInfo && this._propertyInfo[property];
if (info && !info.readOnly) {
var v = this.getAttribute(attribute);
model[property] = this.deserialize(v, info.type);
}
}
},
_serializing: false,
reflectPropertyToAttribute: function (property, attribute, value) {
this._serializing = true;
value = value === undefined ? this[property] : value;
this.serializeValueToAttribute(value, attribute || Polymer.CaseMap.camelToDashCase(property));
this._serializing = false;
},
serializeValueToAttribute: function (value, attribute, node) {
var str = this.serialize(value);
node = node || this;
if (str === undefined) {
node.removeAttribute(attribute);
} else {
node.setAttribute(attribute, str);
}
},
deserialize: function (value, type) {
switch (type) {
case Number:
value = Number(value);
break;
case Boolean:
value = value != null;
break;
case Object:
try {
value = JSON.parse(value);
} catch (x) {
}
break;
case Array:
try {
value = JSON.parse(value);
} catch (x) {
value = null;
console.warn('Polymer::Attributes: couldn`t decode Array as JSON');
}
break;
case Date:
value = new Date(value);
break;
case String:
default:
break;
}
return value;
},
serialize: function (value) {
switch (typeof value) {
case 'boolean':
return value ? '' : undefined;
case 'object':
if (value instanceof Date) {
return value.toString();
} else if (value) {
try {
return JSON.stringify(value);
} catch (x) {
return '';
}
}
default:
return value != null ? value : undefined;
}
}
});Polymer.version = "1.9.3";Polymer.Base._addFeature({
_registerFeatures: function () {
this._prepIs();
this._prepBehaviors();
this._prepConstructor();
this._prepPropertyInfo();
},
_prepBehavior: function (b) {
this._addHostAttributes(b.hostAttributes);
},
_marshalBehavior: function (b) {
},
_initFeatures: function () {
this._marshalHostAttributes();
this._marshalBehaviors();
}
});</script>











<script>(function () {
function resolveCss(cssText, ownerDocument) {
return cssText.replace(CSS_URL_RX, function (m, pre, url, post) {
return pre + '\'' + resolve(url.replace(/["']/g, ''), ownerDocument) + '\'' + post;
});
}
function resolveAttrs(element, ownerDocument) {
for (var name in URL_ATTRS) {
var a$ = URL_ATTRS[name];
for (var i = 0, l = a$.length, a, at, v; i < l && (a = a$[i]); i++) {
if (name === '*' || element.localName === name) {
at = element.attributes[a];
v = at && at.value;
if (v && v.search(BINDING_RX) < 0) {
at.value = a === 'style' ? resolveCss(v, ownerDocument) : resolve(v, ownerDocument);
}
}
}
}
}
function resolve(url, ownerDocument) {
if (url && ABS_URL.test(url)) {
return url;
}
var resolver = getUrlResolver(ownerDocument);
resolver.href = url;
return resolver.href || url;
}
var tempDoc;
var tempDocBase;
function resolveUrl(url, baseUri) {
if (!tempDoc) {
tempDoc = document.implementation.createHTMLDocument('temp');
tempDocBase = tempDoc.createElement('base');
tempDoc.head.appendChild(tempDocBase);
}
tempDocBase.href = baseUri;
return resolve(url, tempDoc);
}
function getUrlResolver(ownerDocument) {
return ownerDocument.body.__urlResolver || (ownerDocument.body.__urlResolver = ownerDocument.createElement('a'));
}
function pathFromUrl(url) {
return url.substring(0, url.lastIndexOf('/') + 1);
}
var CSS_URL_RX = /(url\()([^)]*)(\))/g;
var URL_ATTRS = {
'*': [
'href',
'src',
'style',
'url'
],
form: ['action']
};
var ABS_URL = /(^\/)|(^#)|(^[\w-\d]*:)/;
var BINDING_RX = /\{\{|\[\[/;
Polymer.ResolveUrl = {
resolveCss: resolveCss,
resolveAttrs: resolveAttrs,
resolveUrl: resolveUrl,
pathFromUrl: pathFromUrl
};
Polymer.rootPath = Polymer.Settings.rootPath || pathFromUrl(document.baseURI || window.location.href);
}());Polymer.Base._addFeature({
_prepTemplate: function () {
var module;
if (this._template === undefined) {
module = Polymer.DomModule.import(this.is);
this._template = module && module.querySelector('template');
}
if (module) {
var assetPath = module.getAttribute('assetpath') || '';
var importURL = Polymer.ResolveUrl.resolveUrl(assetPath, module.ownerDocument.baseURI);
this._importPath = Polymer.ResolveUrl.pathFromUrl(importURL);
} else {
this._importPath = '';
}
if (this._template && this._template.hasAttribute('is')) {
this._warn(this._logf('_prepTemplate', 'top-level Polymer template ' + 'must not be a type-extension, found', this._template, 'Move inside simple <template>.'));
}
if (this._template && !this._template.content && window.HTMLTemplateElement && HTMLTemplateElement.decorate) {
HTMLTemplateElement.decorate(this._template);
}
},
_stampTemplate: function () {
if (this._template) {
this.root = this.instanceTemplate(this._template);
}
},
instanceTemplate: function (template) {
var dom = document.importNode(template._content || template.content, true);
return dom;
}
});(function () {
var baseAttachedCallback = Polymer.Base.attachedCallback;
var baseDetachedCallback = Polymer.Base.detachedCallback;
Polymer.Base._addFeature({
_hostStack: [],
ready: function () {
},
_registerHost: function (host) {
this.dataHost = host = host || Polymer.Base._hostStack[Polymer.Base._hostStack.length - 1];
if (host && host._clients) {
host._clients.push(this);
}
this._clients = null;
this._clientsReadied = false;
},
_beginHosting: function () {
Polymer.Base._hostStack.push(this);
if (!this._clients) {
this._clients = [];
}
},
_endHosting: function () {
Polymer.Base._hostStack.pop();
},
_tryReady: function () {
this._readied = false;
if (this._canReady()) {
this._ready();
}
},
_canReady: function () {
return !this.dataHost || this.dataHost._clientsReadied;
},
_ready: function () {
this._beforeClientsReady();
if (this._template) {
this._setupRoot();
this._readyClients();
}
this._clientsReadied = true;
this._clients = null;
this._afterClientsReady();
this._readySelf();
},
_readyClients: function () {
this._beginDistribute();
var c$ = this._clients;
if (c$) {
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
c._ready();
}
}
this._finishDistribute();
},
_readySelf: function () {
for (var i = 0, b; i < this.behaviors.length; i++) {
b = this.behaviors[i];
if (b.ready) {
b.ready.call(this);
}
}
if (this.ready) {
this.ready();
}
this._readied = true;
if (this._attachedPending) {
this._attachedPending = false;
this.attachedCallback();
}
},
_beforeClientsReady: function () {
},
_afterClientsReady: function () {
},
_beforeAttached: function () {
},
attachedCallback: function () {
if (this._readied) {
this._beforeAttached();
baseAttachedCallback.call(this);
} else {
this._attachedPending = true;
}
},
detachedCallback: function () {
if (this._readied) {
baseDetachedCallback.call(this);
} else {
this._attachedPending = false;
}
}
});
}());Polymer.ArraySplice = function () {
function newSplice(index, removed, addedCount) {
return {
index: index,
removed: removed,
addedCount: addedCount
};
}
var EDIT_LEAVE = 0;
var EDIT_UPDATE = 1;
var EDIT_ADD = 2;
var EDIT_DELETE = 3;
function ArraySplice() {
}
ArraySplice.prototype = {
calcEditDistances: function (current, currentStart, currentEnd, old, oldStart, oldEnd) {
var rowCount = oldEnd - oldStart + 1;
var columnCount = currentEnd - currentStart + 1;
var distances = new Array(rowCount);
for (var i = 0; i < rowCount; i++) {
distances[i] = new Array(columnCount);
distances[i][0] = i;
}
for (var j = 0; j < columnCount; j++)
distances[0][j] = j;
for (i = 1; i < rowCount; i++) {
for (j = 1; j < columnCount; j++) {
if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1]))
distances[i][j] = distances[i - 1][j - 1];
else {
var north = distances[i - 1][j] + 1;
var west = distances[i][j - 1] + 1;
distances[i][j] = north < west ? north : west;
}
}
}
return distances;
},
spliceOperationsFromEditDistances: function (distances) {
var i = distances.length - 1;
var j = distances[0].length - 1;
var current = distances[i][j];
var edits = [];
while (i > 0 || j > 0) {
if (i == 0) {
edits.push(EDIT_ADD);
j--;
continue;
}
if (j == 0) {
edits.push(EDIT_DELETE);
i--;
continue;
}
var northWest = distances[i - 1][j - 1];
var west = distances[i - 1][j];
var north = distances[i][j - 1];
var min;
if (west < north)
min = west < northWest ? west : northWest;
else
min = north < northWest ? north : northWest;
if (min == northWest) {
if (northWest == current) {
edits.push(EDIT_LEAVE);
} else {
edits.push(EDIT_UPDATE);
current = northWest;
}
i--;
j--;
} else if (min == west) {
edits.push(EDIT_DELETE);
i--;
current = west;
} else {
edits.push(EDIT_ADD);
j--;
current = north;
}
}
edits.reverse();
return edits;
},
calcSplices: function (current, currentStart, currentEnd, old, oldStart, oldEnd) {
var prefixCount = 0;
var suffixCount = 0;
var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
if (currentStart == 0 && oldStart == 0)
prefixCount = this.sharedPrefix(current, old, minLength);
if (currentEnd == current.length && oldEnd == old.length)
suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);
currentStart += prefixCount;
oldStart += prefixCount;
currentEnd -= suffixCount;
oldEnd -= suffixCount;
if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)
return [];
if (currentStart == currentEnd) {
var splice = newSplice(currentStart, [], 0);
while (oldStart < oldEnd)
splice.removed.push(old[oldStart++]);
return [splice];
} else if (oldStart == oldEnd)
return [newSplice(currentStart, [], currentEnd - currentStart)];
var ops = this.spliceOperationsFromEditDistances(this.calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));
splice = undefined;
var splices = [];
var index = currentStart;
var oldIndex = oldStart;
for (var i = 0; i < ops.length; i++) {
switch (ops[i]) {
case EDIT_LEAVE:
if (splice) {
splices.push(splice);
splice = undefined;
}
index++;
oldIndex++;
break;
case EDIT_UPDATE:
if (!splice)
splice = newSplice(index, [], 0);
splice.addedCount++;
index++;
splice.removed.push(old[oldIndex]);
oldIndex++;
break;
case EDIT_ADD:
if (!splice)
splice = newSplice(index, [], 0);
splice.addedCount++;
index++;
break;
case EDIT_DELETE:
if (!splice)
splice = newSplice(index, [], 0);
splice.removed.push(old[oldIndex]);
oldIndex++;
break;
}
}
if (splice) {
splices.push(splice);
}
return splices;
},
sharedPrefix: function (current, old, searchLength) {
for (var i = 0; i < searchLength; i++)
if (!this.equals(current[i], old[i]))
return i;
return searchLength;
},
sharedSuffix: function (current, old, searchLength) {
var index1 = current.length;
var index2 = old.length;
var count = 0;
while (count < searchLength && this.equals(current[--index1], old[--index2]))
count++;
return count;
},
calculateSplices: function (current, previous) {
return this.calcSplices(current, 0, current.length, previous, 0, previous.length);
},
equals: function (currentValue, previousValue) {
return currentValue === previousValue;
}
};
return new ArraySplice();
}();Polymer.domInnerHTML = function () {
var escapeAttrRegExp = /[&\u00A0"]/g;
var escapeDataRegExp = /[&\u00A0<>]/g;
function escapeReplace(c) {
switch (c) {
case '&':
return '&amp;';
case '<':
return '&lt;';
case '>':
return '&gt;';
case '"':
return '&quot;';
case '\xA0':
return '&nbsp;';
}
}
function escapeAttr(s) {
return s.replace(escapeAttrRegExp, escapeReplace);
}
function escapeData(s) {
return s.replace(escapeDataRegExp, escapeReplace);
}
function makeSet(arr) {
var set = {};
for (var i = 0; i < arr.length; i++) {
set[arr[i]] = true;
}
return set;
}
var voidElements = makeSet([
'area',
'base',
'br',
'col',
'command',
'embed',
'hr',
'img',
'input',
'keygen',
'link',
'meta',
'param',
'source',
'track',
'wbr'
]);
var plaintextParents = makeSet([
'style',
'script',
'xmp',
'iframe',
'noembed',
'noframes',
'plaintext',
'noscript'
]);
function getOuterHTML(node, parentNode, composed) {
switch (node.nodeType) {
case Node.ELEMENT_NODE:
var tagName = node.localName;
var s = '<' + tagName;
var attrs = node.attributes;
for (var i = 0, attr; attr = attrs[i]; i++) {
s += ' ' + attr.name + '="' + escapeAttr(attr.value) + '"';
}
s += '>';
if (voidElements[tagName]) {
return s;
}
return s + getInnerHTML(node, composed) + '</' + tagName + '>';
case Node.TEXT_NODE:
var data = node.data;
if (parentNode && plaintextParents[parentNode.localName]) {
return data;
}
return escapeData(data);
case Node.COMMENT_NODE:
return '<!--' + node.data + '-->';
default:
console.error(node);
throw new Error('not implemented');
}
}
function getInnerHTML(node, composed) {
if (node instanceof HTMLTemplateElement)
node = node.content;
var s = '';
var c$ = Polymer.dom(node).childNodes;
for (var i = 0, l = c$.length, child; i < l && (child = c$[i]); i++) {
s += getOuterHTML(child, node, composed);
}
return s;
}
return { getInnerHTML: getInnerHTML };
}();(function () {
'use strict';
var nativeInsertBefore = Element.prototype.insertBefore;
var nativeAppendChild = Element.prototype.appendChild;
var nativeRemoveChild = Element.prototype.removeChild;
Polymer.TreeApi = {
arrayCopyChildNodes: function (parent) {
var copy = [], i = 0;
for (var n = parent.firstChild; n; n = n.nextSibling) {
copy[i++] = n;
}
return copy;
},
arrayCopyChildren: function (parent) {
var copy = [], i = 0;
for (var n = parent.firstElementChild; n; n = n.nextElementSibling) {
copy[i++] = n;
}
return copy;
},
arrayCopy: function (a$) {
var l = a$.length;
var copy = new Array(l);
for (var i = 0; i < l; i++) {
copy[i] = a$[i];
}
return copy;
}
};
Polymer.TreeApi.Logical = {
hasParentNode: function (node) {
return Boolean(node.__dom && node.__dom.parentNode);
},
hasChildNodes: function (node) {
return Boolean(node.__dom && node.__dom.childNodes !== undefined);
},
getChildNodes: function (node) {
return this.hasChildNodes(node) ? this._getChildNodes(node) : node.childNodes;
},
_getChildNodes: function (node) {
if (!node.__dom.childNodes) {
node.__dom.childNodes = [];
for (var n = node.__dom.firstChild; n; n = n.__dom.nextSibling) {
node.__dom.childNodes.push(n);
}
}
return node.__dom.childNodes;
},
getParentNode: function (node) {
return node.__dom && node.__dom.parentNode !== undefined ? node.__dom.parentNode : node.parentNode;
},
getFirstChild: function (node) {
return node.__dom && node.__dom.firstChild !== undefined ? node.__dom.firstChild : node.firstChild;
},
getLastChild: function (node) {
return node.__dom && node.__dom.lastChild !== undefined ? node.__dom.lastChild : node.lastChild;
},
getNextSibling: function (node) {
return node.__dom && node.__dom.nextSibling !== undefined ? node.__dom.nextSibling : node.nextSibling;
},
getPreviousSibling: function (node) {
return node.__dom && node.__dom.previousSibling !== undefined ? node.__dom.previousSibling : node.previousSibling;
},
getFirstElementChild: function (node) {
return node.__dom && node.__dom.firstChild !== undefined ? this._getFirstElementChild(node) : node.firstElementChild;
},
_getFirstElementChild: function (node) {
var n = node.__dom.firstChild;
while (n && n.nodeType !== Node.ELEMENT_NODE) {
n = n.__dom.nextSibling;
}
return n;
},
getLastElementChild: function (node) {
return node.__dom && node.__dom.lastChild !== undefined ? this._getLastElementChild(node) : node.lastElementChild;
},
_getLastElementChild: function (node) {
var n = node.__dom.lastChild;
while (n && n.nodeType !== Node.ELEMENT_NODE) {
n = n.__dom.previousSibling;
}
return n;
},
getNextElementSibling: function (node) {
return node.__dom && node.__dom.nextSibling !== undefined ? this._getNextElementSibling(node) : node.nextElementSibling;
},
_getNextElementSibling: function (node) {
var n = node.__dom.nextSibling;
while (n && n.nodeType !== Node.ELEMENT_NODE) {
n = n.__dom.nextSibling;
}
return n;
},
getPreviousElementSibling: function (node) {
return node.__dom && node.__dom.previousSibling !== undefined ? this._getPreviousElementSibling(node) : node.previousElementSibling;
},
_getPreviousElementSibling: function (node) {
var n = node.__dom.previousSibling;
while (n && n.nodeType !== Node.ELEMENT_NODE) {
n = n.__dom.previousSibling;
}
return n;
},
saveChildNodes: function (node) {
if (!this.hasChildNodes(node)) {
node.__dom = node.__dom || {};
node.__dom.firstChild = node.firstChild;
node.__dom.lastChild = node.lastChild;
node.__dom.childNodes = [];
for (var n = node.firstChild; n; n = n.nextSibling) {
n.__dom = n.__dom || {};
n.__dom.parentNode = node;
node.__dom.childNodes.push(n);
n.__dom.nextSibling = n.nextSibling;
n.__dom.previousSibling = n.previousSibling;
}
}
},
recordInsertBefore: function (node, container, ref_node) {
container.__dom.childNodes = null;
if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
for (var n = node.firstChild; n; n = n.nextSibling) {
this._linkNode(n, container, ref_node);
}
} else {
this._linkNode(node, container, ref_node);
}
},
_linkNode: function (node, container, ref_node) {
node.__dom = node.__dom || {};
container.__dom = container.__dom || {};
if (ref_node) {
ref_node.__dom = ref_node.__dom || {};
}
node.__dom.previousSibling = ref_node ? ref_node.__dom.previousSibling : container.__dom.lastChild;
if (node.__dom.previousSibling) {
node.__dom.previousSibling.__dom.nextSibling = node;
}
node.__dom.nextSibling = ref_node || null;
if (node.__dom.nextSibling) {
node.__dom.nextSibling.__dom.previousSibling = node;
}
node.__dom.parentNode = container;
if (ref_node) {
if (ref_node === container.__dom.firstChild) {
container.__dom.firstChild = node;
}
} else {
container.__dom.lastChild = node;
if (!container.__dom.firstChild) {
container.__dom.firstChild = node;
}
}
container.__dom.childNodes = null;
},
recordRemoveChild: function (node, container) {
node.__dom = node.__dom || {};
container.__dom = container.__dom || {};
if (node === container.__dom.firstChild) {
container.__dom.firstChild = node.__dom.nextSibling;
}
if (node === container.__dom.lastChild) {
container.__dom.lastChild = node.__dom.previousSibling;
}
var p = node.__dom.previousSibling;
var n = node.__dom.nextSibling;
if (p) {
p.__dom.nextSibling = n;
}
if (n) {
n.__dom.previousSibling = p;
}
node.__dom.parentNode = node.__dom.previousSibling = node.__dom.nextSibling = undefined;
container.__dom.childNodes = null;
}
};
Polymer.TreeApi.Composed = {
getChildNodes: function (node) {
return Polymer.TreeApi.arrayCopyChildNodes(node);
},
getParentNode: function (node) {
return node.parentNode;
},
clearChildNodes: function (node) {
node.textContent = '';
},
insertBefore: function (parentNode, newChild, refChild) {
return nativeInsertBefore.call(parentNode, newChild, refChild || null);
},
appendChild: function (parentNode, newChild) {
return nativeAppendChild.call(parentNode, newChild);
},
removeChild: function (parentNode, node) {
return nativeRemoveChild.call(parentNode, node);
}
};
}());Polymer.DomApi = function () {
'use strict';
var Settings = Polymer.Settings;
var TreeApi = Polymer.TreeApi;
var DomApi = function (node) {
this.node = needsToWrap ? DomApi.wrap(node) : node;
};
var needsToWrap = Settings.hasShadow && !Settings.nativeShadow;
DomApi.wrap = window.wrap ? window.wrap : function (node) {
return node;
};
DomApi.prototype = {
flush: function () {
Polymer.dom.flush();
},
deepContains: function (node) {
if (this.node.contains(node)) {
return true;
}
var n = node;
var doc = node.ownerDocument;
while (n && n !== doc && n !== this.node) {
n = Polymer.dom(n).parentNode || n.host;
}
return n === this.node;
},
queryDistributedElements: function (selector) {
var c$ = this.getEffectiveChildNodes();
var list = [];
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
if (c.nodeType === Node.ELEMENT_NODE && DomApi.matchesSelector.call(c, selector)) {
list.push(c);
}
}
return list;
},
getEffectiveChildNodes: function () {
var list = [];
var c$ = this.childNodes;
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
if (c.localName === CONTENT) {
var d$ = dom(c).getDistributedNodes();
for (var j = 0; j < d$.length; j++) {
list.push(d$[j]);
}
} else {
list.push(c);
}
}
return list;
},
observeNodes: function (callback) {
if (callback) {
if (!this.observer) {
this.observer = this.node.localName === CONTENT ? new DomApi.DistributedNodesObserver(this) : new DomApi.EffectiveNodesObserver(this);
}
return this.observer.addListener(callback);
}
},
unobserveNodes: function (handle) {
if (this.observer) {
this.observer.removeListener(handle);
}
},
notifyObserver: function () {
if (this.observer) {
this.observer.notify();
}
},
_query: function (matcher, node, halter) {
node = node || this.node;
var list = [];
this._queryElements(TreeApi.Logical.getChildNodes(node), matcher, halter, list);
return list;
},
_queryElements: function (elements, matcher, halter, list) {
for (var i = 0, l = elements.length, c; i < l && (c = elements[i]); i++) {
if (c.nodeType === Node.ELEMENT_NODE) {
if (this._queryElement(c, matcher, halter, list)) {
return true;
}
}
}
},
_queryElement: function (node, matcher, halter, list) {
var result = matcher(node);
if (result) {
list.push(node);
}
if (halter && halter(result)) {
return result;
}
this._queryElements(TreeApi.Logical.getChildNodes(node), matcher, halter, list);
}
};
var CONTENT = DomApi.CONTENT = 'content';
var dom = DomApi.factory = function (node) {
node = node || document;
if (!node.__domApi) {
node.__domApi = new DomApi.ctor(node);
}
return node.__domApi;
};
DomApi.hasApi = function (node) {
return Boolean(node.__domApi);
};
DomApi.ctor = DomApi;
Polymer.dom = function (obj, patch) {
if (obj instanceof Event) {
return Polymer.EventApi.factory(obj);
} else {
return DomApi.factory(obj, patch);
}
};
var p = Element.prototype;
DomApi.matchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;
return DomApi;
}();(function () {
'use strict';
var Settings = Polymer.Settings;
var DomApi = Polymer.DomApi;
var dom = DomApi.factory;
var TreeApi = Polymer.TreeApi;
var getInnerHTML = Polymer.domInnerHTML.getInnerHTML;
var CONTENT = DomApi.CONTENT;
if (Settings.useShadow) {
return;
}
var nativeCloneNode = Element.prototype.cloneNode;
var nativeImportNode = Document.prototype.importNode;
Polymer.Base.mixin(DomApi.prototype, {
_lazyDistribute: function (host) {
if (host.shadyRoot && host.shadyRoot._distributionClean) {
host.shadyRoot._distributionClean = false;
Polymer.dom.addDebouncer(host.debounce('_distribute', host._distributeContent));
}
},
appendChild: function (node) {
return this.insertBefore(node);
},
insertBefore: function (node, ref_node) {
if (ref_node && TreeApi.Logical.getParentNode(ref_node) !== this.node) {
throw Error('The ref_node to be inserted before is not a child ' + 'of this node');
}
if (node.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
var parent = TreeApi.Logical.getParentNode(node);
if (parent) {
if (DomApi.hasApi(parent)) {
dom(parent).notifyObserver();
}
this._removeNode(node);
} else {
this._removeOwnerShadyRoot(node);
}
}
if (!this._addNode(node, ref_node)) {
if (ref_node) {
ref_node = ref_node.localName === CONTENT ? this._firstComposedNode(ref_node) : ref_node;
}
var container = this.node._isShadyRoot ? this.node.host : this.node;
if (ref_node) {
TreeApi.Composed.insertBefore(container, node, ref_node);
} else {
TreeApi.Composed.appendChild(container, node);
}
}
this.notifyObserver();
return node;
},
_addNode: function (node, ref_node) {
var root = this.getOwnerRoot();
if (root) {
var ipAdded = this._maybeAddInsertionPoint(node, this.node);
if (!root._invalidInsertionPoints) {
root._invalidInsertionPoints = ipAdded;
}
this._addNodeToHost(root.host, node);
}
if (TreeApi.Logical.hasChildNodes(this.node)) {
TreeApi.Logical.recordInsertBefore(node, this.node, ref_node);
}
var handled = this._maybeDistribute(node) || this.node.shadyRoot;
if (handled) {
if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
while (node.firstChild) {
TreeApi.Composed.removeChild(node, node.firstChild);
}
} else {
var parent = TreeApi.Composed.getParentNode(node);
if (parent) {
TreeApi.Composed.removeChild(parent, node);
}
}
}
return handled;
},
removeChild: function (node) {
if (TreeApi.Logical.getParentNode(node) !== this.node) {
throw Error('The node to be removed is not a child of this node: ' + node);
}
if (!this._removeNode(node)) {
var container = this.node._isShadyRoot ? this.node.host : this.node;
var parent = TreeApi.Composed.getParentNode(node);
if (container === parent) {
TreeApi.Composed.removeChild(container, node);
}
}
this.notifyObserver();
return node;
},
_removeNode: function (node) {
var logicalParent = TreeApi.Logical.hasParentNode(node) && TreeApi.Logical.getParentNode(node);
var distributed;
var root = this._ownerShadyRootForNode(node);
if (logicalParent) {
distributed = dom(node)._maybeDistributeParent();
TreeApi.Logical.recordRemoveChild(node, logicalParent);
if (root && this._removeDistributedChildren(root, node)) {
root._invalidInsertionPoints = true;
this._lazyDistribute(root.host);
}
}
this._removeOwnerShadyRoot(node);
if (root) {
this._removeNodeFromHost(root.host, node);
}
return distributed;
},
replaceChild: function (node, ref_node) {
this.insertBefore(node, ref_node);
this.removeChild(ref_node);
return node;
},
_hasCachedOwnerRoot: function (node) {
return Boolean(node._ownerShadyRoot !== undefined);
},
getOwnerRoot: function () {
return this._ownerShadyRootForNode(this.node);
},
_ownerShadyRootForNode: function (node) {
if (!node) {
return;
}
var root = node._ownerShadyRoot;
if (root === undefined) {
if (node._isShadyRoot) {
root = node;
} else {
var parent = TreeApi.Logical.getParentNode(node);
if (parent) {
root = parent._isShadyRoot ? parent : this._ownerShadyRootForNode(parent);
} else {
root = null;
}
}
if (root || document.documentElement.contains(node)) {
node._ownerShadyRoot = root;
}
}
return root;
},
_maybeDistribute: function (node) {
var fragContent = node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !node.__noContent && dom(node).querySelector(CONTENT);
var wrappedContent = fragContent && TreeApi.Logical.getParentNode(fragContent).nodeType !== Node.DOCUMENT_FRAGMENT_NODE;
var hasContent = fragContent || node.localName === CONTENT;
if (hasContent) {
var root = this.getOwnerRoot();
if (root) {
this._lazyDistribute(root.host);
}
}
var needsDist = this._nodeNeedsDistribution(this.node);
if (needsDist) {
this._lazyDistribute(this.node);
}
return needsDist || hasContent && !wrappedContent;
},
_maybeAddInsertionPoint: function (node, parent) {
var added;
if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !node.__noContent) {
var c$ = dom(node).querySelectorAll(CONTENT);
for (var i = 0, n, np, na; i < c$.length && (n = c$[i]); i++) {
np = TreeApi.Logical.getParentNode(n);
if (np === node) {
np = parent;
}
na = this._maybeAddInsertionPoint(n, np);
added = added || na;
}
} else if (node.localName === CONTENT) {
TreeApi.Logical.saveChildNodes(parent);
TreeApi.Logical.saveChildNodes(node);
added = true;
}
return added;
},
_updateInsertionPoints: function (host) {
var i$ = host.shadyRoot._insertionPoints = dom(host.shadyRoot).querySelectorAll(CONTENT);
for (var i = 0, c; i < i$.length; i++) {
c = i$[i];
TreeApi.Logical.saveChildNodes(c);
TreeApi.Logical.saveChildNodes(TreeApi.Logical.getParentNode(c));
}
},
_nodeNeedsDistribution: function (node) {
return node && node.shadyRoot && DomApi.hasInsertionPoint(node.shadyRoot);
},
_addNodeToHost: function (host, node) {
if (host._elementAdd) {
host._elementAdd(node);
}
},
_removeNodeFromHost: function (host, node) {
if (host._elementRemove) {
host._elementRemove(node);
}
},
_removeDistributedChildren: function (root, container) {
var hostNeedsDist;
var ip$ = root._insertionPoints;
for (var i = 0; i < ip$.length; i++) {
var content = ip$[i];
if (this._contains(container, content)) {
var dc$ = dom(content).getDistributedNodes();
for (var j = 0; j < dc$.length; j++) {
hostNeedsDist = true;
var node = dc$[j];
var parent = TreeApi.Composed.getParentNode(node);
if (parent) {
TreeApi.Composed.removeChild(parent, node);
}
}
}
}
return hostNeedsDist;
},
_contains: function (container, node) {
while (node) {
if (node == container) {
return true;
}
node = TreeApi.Logical.getParentNode(node);
}
},
_removeOwnerShadyRoot: function (node) {
if (this._hasCachedOwnerRoot(node)) {
var c$ = TreeApi.Logical.getChildNodes(node);
for (var i = 0, l = c$.length, n; i < l && (n = c$[i]); i++) {
this._removeOwnerShadyRoot(n);
}
}
node._ownerShadyRoot = undefined;
},
_firstComposedNode: function (content) {
var n$ = dom(content).getDistributedNodes();
for (var i = 0, l = n$.length, n, p$; i < l && (n = n$[i]); i++) {
p$ = dom(n).getDestinationInsertionPoints();
if (p$[p$.length - 1] === content) {
return n;
}
}
},
querySelector: function (selector) {
var result = this._query(function (n) {
return DomApi.matchesSelector.call(n, selector);
}, this.node, function (n) {
return Boolean(n);
})[0];
return result || null;
},
querySelectorAll: function (selector) {
return this._query(function (n) {
return DomApi.matchesSelector.call(n, selector);
}, this.node);
},
getDestinationInsertionPoints: function () {
return this.node._destinationInsertionPoints || [];
},
getDistributedNodes: function () {
return this.node._distributedNodes || [];
},
_clear: function () {
while (this.childNodes.length) {
this.removeChild(this.childNodes[0]);
}
},
setAttribute: function (name, value) {
this.node.setAttribute(name, value);
this._maybeDistributeParent();
},
removeAttribute: function (name) {
this.node.removeAttribute(name);
this._maybeDistributeParent();
},
_maybeDistributeParent: function () {
if (this._nodeNeedsDistribution(this.parentNode)) {
this._lazyDistribute(this.parentNode);
return true;
}
},
cloneNode: function (deep) {
var n = nativeCloneNode.call(this.node, false);
if (deep) {
var c$ = this.childNodes;
var d = dom(n);
for (var i = 0, nc; i < c$.length; i++) {
nc = dom(c$[i]).cloneNode(true);
d.appendChild(nc);
}
}
return n;
},
importNode: function (externalNode, deep) {
var doc = this.node instanceof Document ? this.node : this.node.ownerDocument;
var n = nativeImportNode.call(doc, externalNode, false);
if (deep) {
var c$ = TreeApi.Logical.getChildNodes(externalNode);
var d = dom(n);
for (var i = 0, nc; i < c$.length; i++) {
nc = dom(doc).importNode(c$[i], true);
d.appendChild(nc);
}
}
return n;
},
_getComposedInnerHTML: function () {
return getInnerHTML(this.node, true);
}
});
Object.defineProperties(DomApi.prototype, {
activeElement: {
get: function () {
var active = document.activeElement;
if (!active) {
return null;
}
var isShadyRoot = !!this.node._isShadyRoot;
if (this.node !== document) {
if (!isShadyRoot) {
return null;
}
if (this.node.host === active || !this.node.host.contains(active)) {
return null;
}
}
var activeRoot = dom(active).getOwnerRoot();
while (activeRoot && activeRoot !== this.node) {
active = activeRoot.host;
activeRoot = dom(active).getOwnerRoot();
}
if (this.node === document) {
return activeRoot ? null : active;
} else {
return activeRoot === this.node ? active : null;
}
},
configurable: true
},
childNodes: {
get: function () {
var c$ = TreeApi.Logical.getChildNodes(this.node);
return Array.isArray(c$) ? c$ : TreeApi.arrayCopyChildNodes(this.node);
},
configurable: true
},
children: {
get: function () {
if (TreeApi.Logical.hasChildNodes(this.node)) {
return Array.prototype.filter.call(this.childNodes, function (n) {
return n.nodeType === Node.ELEMENT_NODE;
});
} else {
return TreeApi.arrayCopyChildren(this.node);
}
},
configurable: true
},
parentNode: {
get: function () {
return TreeApi.Logical.getParentNode(this.node);
},
configurable: true
},
firstChild: {
get: function () {
return TreeApi.Logical.getFirstChild(this.node);
},
configurable: true
},
lastChild: {
get: function () {
return TreeApi.Logical.getLastChild(this.node);
},
configurable: true
},
nextSibling: {
get: function () {
return TreeApi.Logical.getNextSibling(this.node);
},
configurable: true
},
previousSibling: {
get: function () {
return TreeApi.Logical.getPreviousSibling(this.node);
},
configurable: true
},
firstElementChild: {
get: function () {
return TreeApi.Logical.getFirstElementChild(this.node);
},
configurable: true
},
lastElementChild: {
get: function () {
return TreeApi.Logical.getLastElementChild(this.node);
},
configurable: true
},
nextElementSibling: {
get: function () {
return TreeApi.Logical.getNextElementSibling(this.node);
},
configurable: true
},
previousElementSibling: {
get: function () {
return TreeApi.Logical.getPreviousElementSibling(this.node);
},
configurable: true
},
textContent: {
get: function () {
var nt = this.node.nodeType;
if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {
return this.node.textContent;
} else {
var tc = [];
for (var i = 0, cn = this.childNodes, c; c = cn[i]; i++) {
if (c.nodeType !== Node.COMMENT_NODE) {
tc.push(c.textContent);
}
}
return tc.join('');
}
},
set: function (text) {
var nt = this.node.nodeType;
if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {
this.node.textContent = text;
} else {
this._clear();
if (text) {
this.appendChild(document.createTextNode(text));
}
}
},
configurable: true
},
innerHTML: {
get: function () {
var nt = this.node.nodeType;
if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {
return null;
} else {
return getInnerHTML(this.node);
}
},
set: function (text) {
var nt = this.node.nodeType;
if (nt !== Node.TEXT_NODE || nt !== Node.COMMENT_NODE) {
this._clear();
var d = document.createElement('div');
d.innerHTML = text;
var c$ = TreeApi.arrayCopyChildNodes(d);
for (var i = 0; i < c$.length; i++) {
this.appendChild(c$[i]);
}
}
},
configurable: true
}
});
DomApi.hasInsertionPoint = function (root) {
return Boolean(root && root._insertionPoints.length);
};
}());(function () {
'use strict';
var Settings = Polymer.Settings;
var TreeApi = Polymer.TreeApi;
var DomApi = Polymer.DomApi;
if (!Settings.useShadow) {
return;
}
Polymer.Base.mixin(DomApi.prototype, {
querySelectorAll: function (selector) {
return TreeApi.arrayCopy(this.node.querySelectorAll(selector));
},
getOwnerRoot: function () {
var n = this.node;
while (n) {
if (n.nodeType === Node.DOCUMENT_FRAGMENT_NODE && n.host) {
return n;
}
n = n.parentNode;
}
},
importNode: function (externalNode, deep) {
var doc = this.node instanceof Document ? this.node : this.node.ownerDocument;
return doc.importNode(externalNode, deep);
},
getDestinationInsertionPoints: function () {
var n$ = this.node.getDestinationInsertionPoints && this.node.getDestinationInsertionPoints();
return n$ ? TreeApi.arrayCopy(n$) : [];
},
getDistributedNodes: function () {
var n$ = this.node.getDistributedNodes && this.node.getDistributedNodes();
return n$ ? TreeApi.arrayCopy(n$) : [];
}
});
Object.defineProperties(DomApi.prototype, {
activeElement: {
get: function () {
var node = DomApi.wrap(this.node);
var activeElement = node.activeElement;
return node.contains(activeElement) ? activeElement : null;
},
configurable: true
},
childNodes: {
get: function () {
return TreeApi.arrayCopyChildNodes(this.node);
},
configurable: true
},
children: {
get: function () {
return TreeApi.arrayCopyChildren(this.node);
},
configurable: true
},
textContent: {
get: function () {
return this.node.textContent;
},
set: function (value) {
return this.node.textContent = value;
},
configurable: true
},
innerHTML: {
get: function () {
return this.node.innerHTML;
},
set: function (value) {
return this.node.innerHTML = value;
},
configurable: true
}
});
var forwardMethods = function (m$) {
for (var i = 0; i < m$.length; i++) {
forwardMethod(m$[i]);
}
};
var forwardMethod = function (method) {
DomApi.prototype[method] = function () {
return this.node[method].apply(this.node, arguments);
};
};
forwardMethods([
'cloneNode',
'appendChild',
'insertBefore',
'removeChild',
'replaceChild',
'setAttribute',
'removeAttribute',
'querySelector'
]);
var forwardProperties = function (f$) {
for (var i = 0; i < f$.length; i++) {
forwardProperty(f$[i]);
}
};
var forwardProperty = function (name) {
Object.defineProperty(DomApi.prototype, name, {
get: function () {
return this.node[name];
},
configurable: true
});
};
forwardProperties([
'parentNode',
'firstChild',
'lastChild',
'nextSibling',
'previousSibling',
'firstElementChild',
'lastElementChild',
'nextElementSibling',
'previousElementSibling'
]);
}());Polymer.Base.mixin(Polymer.dom, {
_flushGuard: 0,
_FLUSH_MAX: 100,
_needsTakeRecords: !Polymer.Settings.useNativeCustomElements,
_debouncers: [],
_staticFlushList: [],
_finishDebouncer: null,
flush: function () {
this._flushGuard = 0;
this._prepareFlush();
while (this._debouncers.length && this._flushGuard < this._FLUSH_MAX) {
while (this._debouncers.length) {
this._debouncers.shift().complete();
}
if (this._finishDebouncer) {
this._finishDebouncer.complete();
}
this._prepareFlush();
this._flushGuard++;
}
if (this._flushGuard >= this._FLUSH_MAX) {
console.warn('Polymer.dom.flush aborted. Flush may not be complete.');
}
},
_prepareFlush: function () {
if (this._needsTakeRecords) {
CustomElements.takeRecords();
}
for (var i = 0; i < this._staticFlushList.length; i++) {
this._staticFlushList[i]();
}
},
addStaticFlush: function (fn) {
this._staticFlushList.push(fn);
},
removeStaticFlush: function (fn) {
var i = this._staticFlushList.indexOf(fn);
if (i >= 0) {
this._staticFlushList.splice(i, 1);
}
},
addDebouncer: function (debouncer) {
this._debouncers.push(debouncer);
this._finishDebouncer = Polymer.Debounce(this._finishDebouncer, this._finishFlush);
},
_finishFlush: function () {
Polymer.dom._debouncers = [];
}
});Polymer.EventApi = function () {
'use strict';
var DomApi = Polymer.DomApi.ctor;
var Settings = Polymer.Settings;
DomApi.Event = function (event) {
this.event = event;
};
if (Settings.useShadow) {
DomApi.Event.prototype = {
get rootTarget() {
return this.event.path[0];
},
get localTarget() {
return this.event.target;
},
get path() {
var path = this.event.path;
if (!Array.isArray(path)) {
path = Array.prototype.slice.call(path);
}
return path;
}
};
} else {
DomApi.Event.prototype = {
get rootTarget() {
return this.event.target;
},
get localTarget() {
var current = this.event.currentTarget;
var currentRoot = current && Polymer.dom(current).getOwnerRoot();
var p$ = this.path;
for (var i = 0; i < p$.length; i++) {
if (Polymer.dom(p$[i]).getOwnerRoot() === currentRoot) {
return p$[i];
}
}
},
get path() {
if (!this.event._path) {
var path = [];
var current = this.rootTarget;
while (current) {
path.push(current);
var insertionPoints = Polymer.dom(current).getDestinationInsertionPoints();
if (insertionPoints.length) {
for (var i = 0; i < insertionPoints.length - 1; i++) {
path.push(insertionPoints[i]);
}
current = insertionPoints[insertionPoints.length - 1];
} else {
current = Polymer.dom(current).parentNode || current.host;
}
}
path.push(window);
this.event._path = path;
}
return this.event._path;
}
};
}
var factory = function (event) {
if (!event.__eventApi) {
event.__eventApi = new DomApi.Event(event);
}
return event.__eventApi;
};
return { factory: factory };
}();(function () {
'use strict';
var DomApi = Polymer.DomApi.ctor;
var useShadow = Polymer.Settings.useShadow;
Object.defineProperty(DomApi.prototype, 'classList', {
get: function () {
if (!this._classList) {
this._classList = new DomApi.ClassList(this);
}
return this._classList;
},
configurable: true
});
DomApi.ClassList = function (host) {
this.domApi = host;
this.node = host.node;
};
DomApi.ClassList.prototype = {
add: function () {
this.node.classList.add.apply(this.node.classList, arguments);
this._distributeParent();
},
remove: function () {
this.node.classList.remove.apply(this.node.classList, arguments);
this._distributeParent();
},
toggle: function () {
this.node.classList.toggle.apply(this.node.classList, arguments);
this._distributeParent();
},
_distributeParent: function () {
if (!useShadow) {
this.domApi._maybeDistributeParent();
}
},
contains: function () {
return this.node.classList.contains.apply(this.node.classList, arguments);
}
};
}());(function () {
'use strict';
var DomApi = Polymer.DomApi.ctor;
var Settings = Polymer.Settings;
DomApi.EffectiveNodesObserver = function (domApi) {
this.domApi = domApi;
this.node = this.domApi.node;
this._listeners = [];
};
DomApi.EffectiveNodesObserver.prototype = {
addListener: function (callback) {
if (!this._isSetup) {
this._setup();
this._isSetup = true;
}
var listener = {
fn: callback,
_nodes: []
};
this._listeners.push(listener);
this._scheduleNotify();
return listener;
},
removeListener: function (handle) {
var i = this._listeners.indexOf(handle);
if (i >= 0) {
this._listeners.splice(i, 1);
handle._nodes = [];
}
if (!this._hasListeners()) {
this._cleanup();
this._isSetup = false;
}
},
_setup: function () {
this._observeContentElements(this.domApi.childNodes);
},
_cleanup: function () {
this._unobserveContentElements(this.domApi.childNodes);
},
_hasListeners: function () {
return Boolean(this._listeners.length);
},
_scheduleNotify: function () {
if (this._debouncer) {
this._debouncer.stop();
}
this._debouncer = Polymer.Debounce(this._debouncer, this._notify);
this._debouncer.context = this;
Polymer.dom.addDebouncer(this._debouncer);
},
notify: function () {
if (this._hasListeners()) {
this._scheduleNotify();
}
},
_notify: function () {
this._beforeCallListeners();
this._callListeners();
},
_beforeCallListeners: function () {
this._updateContentElements();
},
_updateContentElements: function () {
this._observeContentElements(this.domApi.childNodes);
},
_observeContentElements: function (elements) {
for (var i = 0, n; i < elements.length && (n = elements[i]); i++) {
if (this._isContent(n)) {
n.__observeNodesMap = n.__observeNodesMap || new WeakMap();
if (!n.__observeNodesMap.has(this)) {
n.__observeNodesMap.set(this, this._observeContent(n));
}
}
}
},
_observeContent: function (content) {
var self = this;
var h = Polymer.dom(content).observeNodes(function () {
self._scheduleNotify();
});
h._avoidChangeCalculation = true;
return h;
},
_unobserveContentElements: function (elements) {
for (var i = 0, n, h; i < elements.length && (n = elements[i]); i++) {
if (this._isContent(n)) {
h = n.__observeNodesMap.get(this);
if (h) {
Polymer.dom(n).unobserveNodes(h);
n.__observeNodesMap.delete(this);
}
}
}
},
_isContent: function (node) {
return node.localName === 'content';
},
_callListeners: function () {
var o$ = this._listeners;
var nodes = this._getEffectiveNodes();
for (var i = 0, o; i < o$.length && (o = o$[i]); i++) {
var info = this._generateListenerInfo(o, nodes);
if (info || o._alwaysNotify) {
this._callListener(o, info);
}
}
},
_getEffectiveNodes: function () {
return this.domApi.getEffectiveChildNodes();
},
_generateListenerInfo: function (listener, newNodes) {
if (listener._avoidChangeCalculation) {
return true;
}
var oldNodes = listener._nodes;
var info = {
target: this.node,
addedNodes: [],
removedNodes: []
};
var splices = Polymer.ArraySplice.calculateSplices(newNodes, oldNodes);
for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {
info.removedNodes.push(n);
}
}
for (i = 0, s; i < splices.length && (s = splices[i]); i++) {
for (j = s.index; j < s.index + s.addedCount; j++) {
info.addedNodes.push(newNodes[j]);
}
}
listener._nodes = newNodes;
if (info.addedNodes.length || info.removedNodes.length) {
return info;
}
},
_callListener: function (listener, info) {
return listener.fn.call(this.node, info);
},
enableShadowAttributeTracking: function () {
}
};
if (Settings.useShadow) {
var baseSetup = DomApi.EffectiveNodesObserver.prototype._setup;
var baseCleanup = DomApi.EffectiveNodesObserver.prototype._cleanup;
Polymer.Base.mixin(DomApi.EffectiveNodesObserver.prototype, {
_setup: function () {
if (!this._observer) {
var self = this;
this._mutationHandler = function (mxns) {
if (mxns && mxns.length) {
self._scheduleNotify();
}
};
this._observer = new MutationObserver(this._mutationHandler);
this._boundFlush = function () {
self._flush();
};
Polymer.dom.addStaticFlush(this._boundFlush);
this._observer.observe(this.node, { childList: true });
}
baseSetup.call(this);
},
_cleanup: function () {
this._observer.disconnect();
this._observer = null;
this._mutationHandler = null;
Polymer.dom.removeStaticFlush(this._boundFlush);
baseCleanup.call(this);
},
_flush: function () {
if (this._observer) {
this._mutationHandler(this._observer.takeRecords());
}
},
enableShadowAttributeTracking: function () {
if (this._observer) {
this._makeContentListenersAlwaysNotify();
this._observer.disconnect();
this._observer.observe(this.node, {
childList: true,
attributes: true,
subtree: true
});
var root = this.domApi.getOwnerRoot();
var host = root && root.host;
if (host && Polymer.dom(host).observer) {
Polymer.dom(host).observer.enableShadowAttributeTracking();
}
}
},
_makeContentListenersAlwaysNotify: function () {
for (var i = 0, h; i < this._listeners.length; i++) {
h = this._listeners[i];
h._alwaysNotify = h._isContentListener;
}
}
});
}
}());(function () {
'use strict';
var DomApi = Polymer.DomApi.ctor;
var Settings = Polymer.Settings;
DomApi.DistributedNodesObserver = function (domApi) {
DomApi.EffectiveNodesObserver.call(this, domApi);
};
DomApi.DistributedNodesObserver.prototype = Object.create(DomApi.EffectiveNodesObserver.prototype);
Polymer.Base.mixin(DomApi.DistributedNodesObserver.prototype, {
_setup: function () {
},
_cleanup: function () {
},
_beforeCallListeners: function () {
},
_getEffectiveNodes: function () {
return this.domApi.getDistributedNodes();
}
});
if (Settings.useShadow) {
Polymer.Base.mixin(DomApi.DistributedNodesObserver.prototype, {
_setup: function () {
if (!this._observer) {
var root = this.domApi.getOwnerRoot();
var host = root && root.host;
if (host) {
var self = this;
this._observer = Polymer.dom(host).observeNodes(function () {
self._scheduleNotify();
});
this._observer._isContentListener = true;
if (this._hasAttrSelect()) {
Polymer.dom(host).observer.enableShadowAttributeTracking();
}
}
}
},
_hasAttrSelect: function () {
var select = this.node.getAttribute('select');
return select && select.match(/[[.]+/);
},
_cleanup: function () {
var root = this.domApi.getOwnerRoot();
var host = root && root.host;
if (host) {
Polymer.dom(host).unobserveNodes(this._observer);
}
this._observer = null;
}
});
}
}());(function () {
var DomApi = Polymer.DomApi;
var TreeApi = Polymer.TreeApi;
Polymer.Base._addFeature({
_prepShady: function () {
this._useContent = this._useContent || Boolean(this._template);
},
_setupShady: function () {
this.shadyRoot = null;
if (!this.__domApi) {
this.__domApi = null;
}
if (!this.__dom) {
this.__dom = null;
}
if (!this._ownerShadyRoot) {
this._ownerShadyRoot = undefined;
}
},
_poolContent: function () {
if (this._useContent) {
TreeApi.Logical.saveChildNodes(this);
}
},
_setupRoot: function () {
if (this._useContent) {
this._createLocalRoot();
if (!this.dataHost) {
upgradeLogicalChildren(TreeApi.Logical.getChildNodes(this));
}
}
},
_createLocalRoot: function () {
this.shadyRoot = this.root;
this.shadyRoot._distributionClean = false;
this.shadyRoot._hasDistributed = false;
this.shadyRoot._isShadyRoot = true;
this.shadyRoot._dirtyRoots = [];
var i$ = this.shadyRoot._insertionPoints = !this._notes || this._notes._hasContent ? this.shadyRoot.querySelectorAll('content') : [];
TreeApi.Logical.saveChildNodes(this.shadyRoot);
for (var i = 0, c; i < i$.length; i++) {
c = i$[i];
TreeApi.Logical.saveChildNodes(c);
TreeApi.Logical.saveChildNodes(c.parentNode);
}
this.shadyRoot.host = this;
},
distributeContent: function (updateInsertionPoints) {
if (this.shadyRoot) {
this.shadyRoot._invalidInsertionPoints = this.shadyRoot._invalidInsertionPoints || updateInsertionPoints;
var host = getTopDistributingHost(this);
Polymer.dom(this)._lazyDistribute(host);
}
},
_distributeContent: function () {
if (this._useContent && !this.shadyRoot._distributionClean) {
if (this.shadyRoot._invalidInsertionPoints) {
Polymer.dom(this)._updateInsertionPoints(this);
this.shadyRoot._invalidInsertionPoints = false;
}
this._beginDistribute();
this._distributeDirtyRoots();
this._finishDistribute();
}
},
_beginDistribute: function () {
if (this._useContent && DomApi.hasInsertionPoint(this.shadyRoot)) {
this._resetDistribution();
this._distributePool(this.shadyRoot, this._collectPool());
}
},
_distributeDirtyRoots: function () {
var c$ = this.shadyRoot._dirtyRoots;
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
c._distributeContent();
}
this.shadyRoot._dirtyRoots = [];
},
_finishDistribute: function () {
if (this._useContent) {
this.shadyRoot._distributionClean = true;
if (DomApi.hasInsertionPoint(this.shadyRoot)) {
this._composeTree();
notifyContentObservers(this.shadyRoot);
} else {
if (!this.shadyRoot._hasDistributed) {
TreeApi.Composed.clearChildNodes(this);
this.appendChild(this.shadyRoot);
} else {
var children = this._composeNode(this);
this._updateChildNodes(this, children);
}
}
if (!this.shadyRoot._hasDistributed) {
notifyInitialDistribution(this);
}
this.shadyRoot._hasDistributed = true;
}
},
elementMatches: function (selector, node) {
node = node || this;
return DomApi.matchesSelector.call(node, selector);
},
_resetDistribution: function () {
var children = TreeApi.Logical.getChildNodes(this);
for (var i = 0; i < children.length; i++) {
var child = children[i];
if (child._destinationInsertionPoints) {
child._destinationInsertionPoints = undefined;
}
if (isInsertionPoint(child)) {
clearDistributedDestinationInsertionPoints(child);
}
}
var root = this.shadyRoot;
var p$ = root._insertionPoints;
for (var j = 0; j < p$.length; j++) {
p$[j]._distributedNodes = [];
}
},
_collectPool: function () {
var pool = [];
var children = TreeApi.Logical.getChildNodes(this);
for (var i = 0; i < children.length; i++) {
var child = children[i];
if (isInsertionPoint(child)) {
pool.push.apply(pool, child._distributedNodes);
} else {
pool.push(child);
}
}
return pool;
},
_distributePool: function (node, pool) {
var p$ = node._insertionPoints;
for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {
this._distributeInsertionPoint(p, pool);
maybeRedistributeParent(p, this);
}
},
_distributeInsertionPoint: function (content, pool) {
var anyDistributed = false;
for (var i = 0, l = pool.length, node; i < l; i++) {
node = pool[i];
if (!node) {
continue;
}
if (this._matchesContentSelect(node, content)) {
distributeNodeInto(node, content);
pool[i] = undefined;
anyDistributed = true;
}
}
if (!anyDistributed) {
var children = TreeApi.Logical.getChildNodes(content);
for (var j = 0; j < children.length; j++) {
distributeNodeInto(children[j], content);
}
}
},
_composeTree: function () {
this._updateChildNodes(this, this._composeNode(this));
var p$ = this.shadyRoot._insertionPoints;
for (var i = 0, l = p$.length, p, parent; i < l && (p = p$[i]); i++) {
parent = TreeApi.Logical.getParentNode(p);
if (!parent._useContent && parent !== this && parent !== this.shadyRoot) {
this._updateChildNodes(parent, this._composeNode(parent));
}
}
},
_composeNode: function (node) {
var children = [];
var c$ = TreeApi.Logical.getChildNodes(node.shadyRoot || node);
for (var i = 0; i < c$.length; i++) {
var child = c$[i];
if (isInsertionPoint(child)) {
var distributedNodes = child._distributedNodes;
for (var j = 0; j < distributedNodes.length; j++) {
var distributedNode = distributedNodes[j];
if (isFinalDestination(child, distributedNode)) {
children.push(distributedNode);
}
}
} else {
children.push(child);
}
}
return children;
},
_updateChildNodes: function (container, children) {
var composed = TreeApi.Composed.getChildNodes(container);
var splices = Polymer.ArraySplice.calculateSplices(children, composed);
for (var i = 0, d = 0, s; i < splices.length && (s = splices[i]); i++) {
for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {
if (TreeApi.Composed.getParentNode(n) === container) {
TreeApi.Composed.removeChild(container, n);
}
composed.splice(s.index + d, 1);
}
d -= s.addedCount;
}
for (var i = 0, s, next; i < splices.length && (s = splices[i]); i++) {
next = composed[s.index];
for (j = s.index, n; j < s.index + s.addedCount; j++) {
n = children[j];
TreeApi.Composed.insertBefore(container, n, next);
composed.splice(j, 0, n);
}
}
},
_matchesContentSelect: function (node, contentElement) {
var select = contentElement.getAttribute('select');
if (!select) {
return true;
}
select = select.trim();
if (!select) {
return true;
}
if (!(node instanceof Element)) {
return false;
}
var validSelectors = /^(:not\()?[*.#[a-zA-Z_|]/;
if (!validSelectors.test(select)) {
return false;
}
return this.elementMatches(select, node);
},
_elementAdd: function () {
},
_elementRemove: function () {
}
});
var domHostDesc = {
get: function () {
var root = Polymer.dom(this).getOwnerRoot();
return root && root.host;
},
configurable: true
};
Object.defineProperty(Polymer.Base, 'domHost', domHostDesc);
Polymer.BaseDescriptors.domHost = domHostDesc;
function distributeNodeInto(child, insertionPoint) {
insertionPoint._distributedNodes.push(child);
var points = child._destinationInsertionPoints;
if (!points) {
child._destinationInsertionPoints = [insertionPoint];
} else {
points.push(insertionPoint);
}
}
function clearDistributedDestinationInsertionPoints(content) {
var e$ = content._distributedNodes;
if (e$) {
for (var i = 0; i < e$.length; i++) {
var d = e$[i]._destinationInsertionPoints;
if (d) {
d.splice(d.indexOf(content) + 1, d.length);
}
}
}
}
function maybeRedistributeParent(content, host) {
var parent = TreeApi.Logical.getParentNode(content);
if (parent && parent.shadyRoot && DomApi.hasInsertionPoint(parent.shadyRoot) && parent.shadyRoot._distributionClean) {
parent.shadyRoot._distributionClean = false;
host.shadyRoot._dirtyRoots.push(parent);
}
}
function isFinalDestination(insertionPoint, node) {
var points = node._destinationInsertionPoints;
return points && points[points.length - 1] === insertionPoint;
}
function isInsertionPoint(node) {
return node.localName == 'content';
}
function getTopDistributingHost(host) {
while (host && hostNeedsRedistribution(host)) {
host = host.domHost;
}
return host;
}
function hostNeedsRedistribution(host) {
var c$ = TreeApi.Logical.getChildNodes(host);
for (var i = 0, c; i < c$.length; i++) {
c = c$[i];
if (c.localName && c.localName === 'content') {
return host.domHost;
}
}
}
function notifyContentObservers(root) {
for (var i = 0, c; i < root._insertionPoints.length; i++) {
c = root._insertionPoints[i];
if (DomApi.hasApi(c)) {
Polymer.dom(c).notifyObserver();
}
}
}
function notifyInitialDistribution(host) {
if (DomApi.hasApi(host)) {
Polymer.dom(host).notifyObserver();
}
}
var needsUpgrade = window.CustomElements && !CustomElements.useNative;
function upgradeLogicalChildren(children) {
if (needsUpgrade && children) {
for (var i = 0; i < children.length; i++) {
CustomElements.upgrade(children[i]);
}
}
}
}());if (Polymer.Settings.useShadow) {
Polymer.Base._addFeature({
_poolContent: function () {
},
_beginDistribute: function () {
},
distributeContent: function () {
},
_distributeContent: function () {
},
_finishDistribute: function () {
},
_createLocalRoot: function () {
this.createShadowRoot();
this.shadowRoot.appendChild(this.root);
this.root = this.shadowRoot;
}
});
}Polymer.Async = {
_currVal: 0,
_lastVal: 0,
_callbacks: [],
_twiddleContent: 0,
_twiddle: document.createTextNode(''),
run: function (callback, waitTime) {
if (waitTime > 0) {
return ~setTimeout(callback, waitTime);
} else {
this._twiddle.textContent = this._twiddleContent++;
this._callbacks.push(callback);
return this._currVal++;
}
},
cancel: function (handle) {
if (handle < 0) {
clearTimeout(~handle);
} else {
var idx = handle - this._lastVal;
if (idx >= 0) {
if (!this._callbacks[idx]) {
throw 'invalid async handle: ' + handle;
}
this._callbacks[idx] = null;
}
}
},
_atEndOfMicrotask: function () {
var len = this._callbacks.length;
for (var i = 0; i < len; i++) {
var cb = this._callbacks[i];
if (cb) {
try {
cb();
} catch (e) {
i++;
this._callbacks.splice(0, i);
this._lastVal += i;
this._twiddle.textContent = this._twiddleContent++;
throw e;
}
}
}
this._callbacks.splice(0, len);
this._lastVal += len;
}
};
new window.MutationObserver(function () {
Polymer.Async._atEndOfMicrotask();
}).observe(Polymer.Async._twiddle, { characterData: true });Polymer.Debounce = function () {
var Async = Polymer.Async;
var Debouncer = function (context) {
this.context = context;
var self = this;
this.boundComplete = function () {
self.complete();
};
};
Debouncer.prototype = {
go: function (callback, wait) {
var h;
this.finish = function () {
Async.cancel(h);
};
h = Async.run(this.boundComplete, wait);
this.callback = callback;
},
stop: function () {
if (this.finish) {
this.finish();
this.finish = null;
this.callback = null;
}
},
complete: function () {
if (this.finish) {
var callback = this.callback;
this.stop();
callback.call(this.context);
}
}
};
function debounce(debouncer, callback, wait) {
if (debouncer) {
debouncer.stop();
} else {
debouncer = new Debouncer(this);
}
debouncer.go(callback, wait);
return debouncer;
}
return debounce;
}();Polymer.Base._addFeature({
_setupDebouncers: function () {
this._debouncers = {};
},
debounce: function (jobName, callback, wait) {
return this._debouncers[jobName] = Polymer.Debounce.call(this, this._debouncers[jobName], callback, wait);
},
isDebouncerActive: function (jobName) {
var debouncer = this._debouncers[jobName];
return !!(debouncer && debouncer.finish);
},
flushDebouncer: function (jobName) {
var debouncer = this._debouncers[jobName];
if (debouncer) {
debouncer.complete();
}
},
cancelDebouncer: function (jobName) {
var debouncer = this._debouncers[jobName];
if (debouncer) {
debouncer.stop();
}
}
});Polymer.DomModule = document.createElement('dom-module');
Polymer.Base._addFeature({
_registerFeatures: function () {
this._prepIs();
this._prepBehaviors();
this._prepConstructor();
this._prepTemplate();
this._prepShady();
this._prepPropertyInfo();
},
_prepBehavior: function (b) {
this._addHostAttributes(b.hostAttributes);
},
_initFeatures: function () {
this._registerHost();
if (this._template) {
this._poolContent();
this._beginHosting();
this._stampTemplate();
this._endHosting();
}
this._marshalHostAttributes();
this._setupDebouncers();
this._marshalBehaviors();
this._tryReady();
},
_marshalBehavior: function (b) {
}
});</script><script>(function () {
Polymer.nar = [];
var disableUpgradeEnabled = Polymer.Settings.disableUpgradeEnabled;
Polymer.Annotations = {
parseAnnotations: function (template, stripWhiteSpace) {
var list = [];
var content = template._content || template.content;
this._parseNodeAnnotations(content, list, stripWhiteSpace || template.hasAttribute('strip-whitespace'));
return list;
},
_parseNodeAnnotations: function (node, list, stripWhiteSpace) {
return node.nodeType === Node.TEXT_NODE ? this._parseTextNodeAnnotation(node, list) : this._parseElementAnnotations(node, list, stripWhiteSpace);
},
_bindingRegex: function () {
var IDENT = '(?:' + '[a-zA-Z_$][\\w.:$\\-*]*' + ')';
var NUMBER = '(?:' + '[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';
var SQUOTE_STRING = '(?:' + '\'(?:[^\'\\\\]|\\\\.)*\'' + ')';
var DQUOTE_STRING = '(?:' + '"(?:[^"\\\\]|\\\\.)*"' + ')';
var STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';
var ARGUMENT = '(?:' + IDENT + '|' + NUMBER + '|' + STRING + '\\s*' + ')';
var ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\s*' + ARGUMENT + ')*' + ')';
var ARGUMENT_LIST = '(?:' + '\\(\\s*' + '(?:' + ARGUMENTS + '?' + ')' + '\\)\\s*' + ')';
var BINDING = '(' + IDENT + '\\s*' + ARGUMENT_LIST + '?' + ')';
var OPEN_BRACKET = '(\\[\\[|{{)' + '\\s*';
var CLOSE_BRACKET = '(?:]]|}})';
var NEGATE = '(?:(!)\\s*)?';
var EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;
return new RegExp(EXPRESSION, 'g');
}(),
_parseBindings: function (text) {
var re = this._bindingRegex;
var parts = [];
var lastIndex = 0;
var m;
while ((m = re.exec(text)) !== null) {
if (m.index > lastIndex) {
parts.push({ literal: text.slice(lastIndex, m.index) });
}
var mode = m[1][0];
var negate = Boolean(m[2]);
var value = m[3].trim();
var customEvent, notifyEvent, colon;
if (mode == '{' && (colon = value.indexOf('::')) > 0) {
notifyEvent = value.substring(colon + 2);
value = value.substring(0, colon);
customEvent = true;
}
parts.push({
compoundIndex: parts.length,
value: value,
mode: mode,
negate: negate,
event: notifyEvent,
customEvent: customEvent
});
lastIndex = re.lastIndex;
}
if (lastIndex && lastIndex < text.length) {
var literal = text.substring(lastIndex);
if (literal) {
parts.push({ literal: literal });
}
}
if (parts.length) {
return parts;
}
},
_literalFromParts: function (parts) {
var s = '';
for (var i = 0; i < parts.length; i++) {
var literal = parts[i].literal;
s += literal || '';
}
return s;
},
_parseTextNodeAnnotation: function (node, list) {
var parts = this._parseBindings(node.textContent);
if (parts) {
node.textContent = this._literalFromParts(parts) || ' ';
var annote = {
bindings: [{
kind: 'text',
name: 'textContent',
parts: parts,
isCompound: parts.length !== 1
}]
};
list.push(annote);
return annote;
}
},
_parseElementAnnotations: function (element, list, stripWhiteSpace) {
var annote = {
bindings: [],
events: []
};
if (element.localName === 'content') {
list._hasContent = true;
}
this._parseChildNodesAnnotations(element, annote, list, stripWhiteSpace);
if (element.attributes) {
this._parseNodeAttributeAnnotations(element, annote, list);
if (this.prepElement) {
this.prepElement(element);
}
}
if (annote.bindings.length || annote.events.length || annote.id) {
list.push(annote);
}
return annote;
},
_parseChildNodesAnnotations: function (root, annote, list, stripWhiteSpace) {
if (root.firstChild) {
var node = root.firstChild;
var i = 0;
while (node) {
var next = node.nextSibling;
if (node.localName === 'template' && !node.hasAttribute('preserve-content')) {
this._parseTemplate(node, i, list, annote, stripWhiteSpace);
}
if (node.localName == 'slot') {
node = this._replaceSlotWithContent(node);
}
if (node.nodeType === Node.TEXT_NODE) {
var n = next;
while (n && n.nodeType === Node.TEXT_NODE) {
node.textContent += n.textContent;
next = n.nextSibling;
root.removeChild(n);
n = next;
}
if (stripWhiteSpace && !node.textContent.trim()) {
root.removeChild(node);
i--;
}
}
if (node.parentNode) {
var childAnnotation = this._parseNodeAnnotations(node, list, stripWhiteSpace);
if (childAnnotation) {
childAnnotation.parent = annote;
childAnnotation.index = i;
}
}
node = next;
i++;
}
}
},
_replaceSlotWithContent: function (slot) {
var content = slot.ownerDocument.createElement('content');
while (slot.firstChild) {
content.appendChild(slot.firstChild);
}
var attrs = slot.attributes;
for (var i = 0; i < attrs.length; i++) {
var attr = attrs[i];
content.setAttribute(attr.name, attr.value);
}
var name = slot.getAttribute('name');
if (name) {
content.setAttribute('select', '[slot=\'' + name + '\']');
}
slot.parentNode.replaceChild(content, slot);
return content;
},
_parseTemplate: function (node, index, list, parent, stripWhiteSpace) {
var content = document.createDocumentFragment();
content._notes = this.parseAnnotations(node, stripWhiteSpace);
content.appendChild(node.content);
list.push({
bindings: Polymer.nar,
events: Polymer.nar,
templateContent: content,
parent: parent,
index: index
});
},
_parseNodeAttributeAnnotations: function (node, annotation) {
var attrs = Array.prototype.slice.call(node.attributes);
for (var i = attrs.length - 1, a; a = attrs[i]; i--) {
var n = a.name;
var v = a.value;
var b;
if (n.slice(0, 3) === 'on-') {
node.removeAttribute(n);
annotation.events.push({
name: n.slice(3),
value: v
});
} else if (b = this._parseNodeAttributeAnnotation(node, n, v)) {
annotation.bindings.push(b);
} else if (n === 'id') {
annotation.id = v;
}
}
},
_parseNodeAttributeAnnotation: function (node, name, value) {
var parts = this._parseBindings(value);
if (parts) {
var origName = name;
var kind = 'property';
if (name[name.length - 1] == '$') {
name = name.slice(0, -1);
kind = 'attribute';
}
var literal = this._literalFromParts(parts);
if (literal && kind == 'attribute') {
node.setAttribute(name, literal);
}
if (node.localName === 'input' && origName === 'value') {
node.setAttribute(origName, '');
}
if (disableUpgradeEnabled && origName === 'disable-upgrade$') {
node.setAttribute(name, '');
}
node.removeAttribute(origName);
var propertyName = Polymer.CaseMap.dashToCamelCase(name);
if (kind === 'property') {
name = propertyName;
}
return {
kind: kind,
name: name,
propertyName: propertyName,
parts: parts,
literal: literal,
isCompound: parts.length !== 1
};
}
},
findAnnotatedNode: function (root, annote) {
var parent = annote.parent && Polymer.Annotations.findAnnotatedNode(root, annote.parent);
if (parent) {
for (var n = parent.firstChild, i = 0; n; n = n.nextSibling) {
if (annote.index === i++) {
return n;
}
}
} else {
return root;
}
}
};
}());Polymer.Path = {
root: function (path) {
var dotIndex = path.indexOf('.');
if (dotIndex === -1) {
return path;
}
return path.slice(0, dotIndex);
},
isDeep: function (path) {
return path.indexOf('.') !== -1;
},
isAncestor: function (base, path) {
return base.indexOf(path + '.') === 0;
},
isDescendant: function (base, path) {
return path.indexOf(base + '.') === 0;
},
translate: function (base, newBase, path) {
return newBase + path.slice(base.length);
},
matches: function (base, wildcard, path) {
return base === path || this.isAncestor(base, path) || Boolean(wildcard) && this.isDescendant(base, path);
}
};Polymer.Base._addFeature({
_prepAnnotations: function () {
if (!this._template) {
this._notes = [];
} else {
var self = this;
Polymer.Annotations.prepElement = function (element) {
self._prepElement(element);
};
if (this._template._content && this._template._content._notes) {
this._notes = this._template._content._notes;
} else {
this._notes = Polymer.Annotations.parseAnnotations(this._template);
this._processAnnotations(this._notes);
}
Polymer.Annotations.prepElement = null;
}
},
_processAnnotations: function (notes) {
for (var i = 0; i < notes.length; i++) {
var note = notes[i];
for (var j = 0; j < note.bindings.length; j++) {
var b = note.bindings[j];
for (var k = 0; k < b.parts.length; k++) {
var p = b.parts[k];
if (!p.literal) {
var signature = this._parseMethod(p.value);
if (signature) {
p.signature = signature;
} else {
p.model = Polymer.Path.root(p.value);
}
}
}
}
if (note.templateContent) {
this._processAnnotations(note.templateContent._notes);
var pp = note.templateContent._parentProps = this._discoverTemplateParentProps(note.templateContent._notes);
var bindings = [];
for (var prop in pp) {
var name = '_parent_' + prop;
bindings.push({
index: note.index,
kind: 'property',
name: name,
propertyName: name,
parts: [{
mode: '{',
model: prop,
value: prop
}]
});
}
note.bindings = note.bindings.concat(bindings);
}
}
},
_discoverTemplateParentProps: function (notes) {
var pp = {};
for (var i = 0, n; i < notes.length && (n = notes[i]); i++) {
for (var j = 0, b$ = n.bindings, b; j < b$.length && (b = b$[j]); j++) {
for (var k = 0, p$ = b.parts, p; k < p$.length && (p = p$[k]); k++) {
if (p.signature) {
var args = p.signature.args;
for (var kk = 0; kk < args.length; kk++) {
var model = args[kk].model;
if (model) {
pp[model] = true;
}
}
if (p.signature.dynamicFn) {
pp[p.signature.method] = true;
}
} else {
if (p.model) {
pp[p.model] = true;
}
}
}
}
if (n.templateContent) {
var tpp = n.templateContent._parentProps;
Polymer.Base.mixin(pp, tpp);
}
}
return pp;
},
_prepElement: function (element) {
Polymer.ResolveUrl.resolveAttrs(element, this._template.ownerDocument);
},
_findAnnotatedNode: Polymer.Annotations.findAnnotatedNode,
_marshalAnnotationReferences: function () {
if (this._template) {
this._marshalIdNodes();
this._marshalAnnotatedNodes();
this._marshalAnnotatedListeners();
}
},
_configureAnnotationReferences: function () {
var notes = this._notes;
var nodes = this._nodes;
for (var i = 0; i < notes.length; i++) {
var note = notes[i];
var node = nodes[i];
this._configureTemplateContent(note, node);
this._configureCompoundBindings(note, node);
}
},
_configureTemplateContent: function (note, node) {
if (note.templateContent) {
node._content = note.templateContent;
}
},
_configureCompoundBindings: function (note, node) {
var bindings = note.bindings;
for (var i = 0; i < bindings.length; i++) {
var binding = bindings[i];
if (binding.isCompound) {
var storage = node.__compoundStorage__ || (node.__compoundStorage__ = {});
var parts = binding.parts;
var literals = new Array(parts.length);
for (var j = 0; j < parts.length; j++) {
literals[j] = parts[j].literal;
}
var name = binding.name;
storage[name] = literals;
if (binding.literal && binding.kind == 'property') {
if (node._configValue) {
node._configValue(name, binding.literal);
} else {
node[name] = binding.literal;
}
}
}
}
},
_marshalIdNodes: function () {
this.$ = {};
for (var i = 0, l = this._notes.length, a; i < l && (a = this._notes[i]); i++) {
if (a.id) {
this.$[a.id] = this._findAnnotatedNode(this.root, a);
}
}
},
_marshalAnnotatedNodes: function () {
if (this._notes && this._notes.length) {
var r = new Array(this._notes.length);
for (var i = 0; i < this._notes.length; i++) {
r[i] = this._findAnnotatedNode(this.root, this._notes[i]);
}
this._nodes = r;
}
},
_marshalAnnotatedListeners: function () {
for (var i = 0, l = this._notes.length, a; i < l && (a = this._notes[i]); i++) {
if (a.events && a.events.length) {
var node = this._findAnnotatedNode(this.root, a);
for (var j = 0, e$ = a.events, e; j < e$.length && (e = e$[j]); j++) {
this.listen(node, e.name, e.value);
}
}
}
}
});Polymer.Base._addFeature({
listeners: {},
_listenListeners: function (listeners) {
var node, name, eventName;
for (eventName in listeners) {
if (eventName.indexOf('.') < 0) {
node = this;
name = eventName;
} else {
name = eventName.split('.');
node = this.$[name[0]];
name = name[1];
}
this.listen(node, name, listeners[eventName]);
}
},
listen: function (node, eventName, methodName) {
var handler = this._recallEventHandler(this, eventName, node, methodName);
if (!handler) {
handler = this._createEventHandler(node, eventName, methodName);
}
if (handler._listening) {
return;
}
this._listen(node, eventName, handler);
handler._listening = true;
},
_boundListenerKey: function (eventName, methodName) {
return eventName + ':' + methodName;
},
_recordEventHandler: function (host, eventName, target, methodName, handler) {
var hbl = host.__boundListeners;
if (!hbl) {
hbl = host.__boundListeners = new WeakMap();
}
var bl = hbl.get(target);
if (!bl) {
bl = {};
if (!Polymer.Settings.isIE || target != window) {
hbl.set(target, bl);
}
}
var key = this._boundListenerKey(eventName, methodName);
bl[key] = handler;
},
_recallEventHandler: function (host, eventName, target, methodName) {
var hbl = host.__boundListeners;
if (!hbl) {
return;
}
var bl = hbl.get(target);
if (!bl) {
return;
}
var key = this._boundListenerKey(eventName, methodName);
return bl[key];
},
_createEventHandler: function (node, eventName, methodName) {
var host = this;
var handler = function (e) {
if (host[methodName]) {
host[methodName](e, e.detail);
} else {
host._warn(host._logf('_createEventHandler', 'listener method `' + methodName + '` not defined'));
}
};
handler._listening = false;
this._recordEventHandler(host, eventName, node, methodName, handler);
return handler;
},
unlisten: function (node, eventName, methodName) {
var handler = this._recallEventHandler(this, eventName, node, methodName);
if (handler) {
this._unlisten(node, eventName, handler);
handler._listening = false;
}
},
_listen: function (node, eventName, handler) {
node.addEventListener(eventName, handler);
},
_unlisten: function (node, eventName, handler) {
node.removeEventListener(eventName, handler);
}
});(function () {
'use strict';
var wrap = Polymer.DomApi.wrap;
var HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';
var GESTURE_KEY = '__polymerGestures';
var HANDLED_OBJ = '__polymerGesturesHandled';
var TOUCH_ACTION = '__polymerGesturesTouchAction';
var TAP_DISTANCE = 25;
var TRACK_DISTANCE = 5;
var TRACK_LENGTH = 2;
var MOUSE_TIMEOUT = 2500;
var MOUSE_EVENTS = [
'mousedown',
'mousemove',
'mouseup',
'click'
];
var MOUSE_WHICH_TO_BUTTONS = [
0,
1,
4,
2
];
var MOUSE_HAS_BUTTONS = function () {
try {
return new MouseEvent('test', { buttons: 1 }).buttons === 1;
} catch (e) {
return false;
}
}();
var SUPPORTS_PASSIVE = false;
(function () {
try {
var opts = Object.defineProperty({}, 'passive', {
get: function () {
SUPPORTS_PASSIVE = true;
}
});
window.addEventListener('test', null, opts);
window.removeEventListener('test', null, opts);
} catch (e) {
}
}());
var IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/);
var mouseCanceller = function (mouseEvent) {
var sc = mouseEvent.sourceCapabilities;
if (sc && !sc.firesTouchEvents) {
return;
}
mouseEvent[HANDLED_OBJ] = { skip: true };
if (mouseEvent.type === 'click') {
var path = Polymer.dom(mouseEvent).path;
for (var i = 0; i < path.length; i++) {
if (path[i] === POINTERSTATE.mouse.target) {
return;
}
}
mouseEvent.preventDefault();
mouseEvent.stopPropagation();
}
};
function setupTeardownMouseCanceller(setup) {
var events = IS_TOUCH_ONLY ? ['click'] : MOUSE_EVENTS;
for (var i = 0, en; i < events.length; i++) {
en = events[i];
if (setup) {
document.addEventListener(en, mouseCanceller, true);
} else {
document.removeEventListener(en, mouseCanceller, true);
}
}
}
function ignoreMouse(ev) {
if (!POINTERSTATE.mouse.mouseIgnoreJob) {
setupTeardownMouseCanceller(true);
}
var unset = function () {
setupTeardownMouseCanceller();
POINTERSTATE.mouse.target = null;
POINTERSTATE.mouse.mouseIgnoreJob = null;
};
POINTERSTATE.mouse.target = Polymer.dom(ev).rootTarget;
POINTERSTATE.mouse.mouseIgnoreJob = Polymer.Debounce(POINTERSTATE.mouse.mouseIgnoreJob, unset, MOUSE_TIMEOUT);
}
function hasLeftMouseButton(ev) {
var type = ev.type;
if (MOUSE_EVENTS.indexOf(type) === -1) {
return false;
}
if (type === 'mousemove') {
var buttons = ev.buttons === undefined ? 1 : ev.buttons;
if (ev instanceof window.MouseEvent && !MOUSE_HAS_BUTTONS) {
buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;
}
return Boolean(buttons & 1);
} else {
var button = ev.button === undefined ? 0 : ev.button;
return button === 0;
}
}
function isSyntheticClick(ev) {
if (ev.type === 'click') {
if (ev.detail === 0) {
return true;
}
var t = Gestures.findOriginalTarget(ev);
var bcr = t.getBoundingClientRect();
var x = ev.pageX, y = ev.pageY;
return !(x >= bcr.left && x <= bcr.right && (y >= bcr.top && y <= bcr.bottom));
}
return false;
}
var POINTERSTATE = {
mouse: {
target: null,
mouseIgnoreJob: null
},
touch: {
x: 0,
y: 0,
id: -1,
scrollDecided: false
}
};
function firstTouchAction(ev) {
var path = Polymer.dom(ev).path;
var ta = 'auto';
for (var i = 0, n; i < path.length; i++) {
n = path[i];
if (n[TOUCH_ACTION]) {
ta = n[TOUCH_ACTION];
break;
}
}
return ta;
}
function trackDocument(stateObj, movefn, upfn) {
stateObj.movefn = movefn;
stateObj.upfn = upfn;
document.addEventListener('mousemove', movefn);
document.addEventListener('mouseup', upfn);
}
function untrackDocument(stateObj) {
document.removeEventListener('mousemove', stateObj.movefn);
document.removeEventListener('mouseup', stateObj.upfn);
stateObj.movefn = null;
stateObj.upfn = null;
}
document.addEventListener('touchend', ignoreMouse, SUPPORTS_PASSIVE ? { passive: true } : false);
var Gestures = {
gestures: {},
recognizers: [],
deepTargetFind: function (x, y) {
var node = document.elementFromPoint(x, y);
var next = node;
while (next && next.shadowRoot) {
next = next.shadowRoot.elementFromPoint(x, y);
if (next) {
node = next;
}
}
return node;
},
findOriginalTarget: function (ev) {
if (ev.path) {
return ev.path[0];
}
return ev.target;
},
handleNative: function (ev) {
var handled;
var type = ev.type;
var node = wrap(ev.currentTarget);
var gobj = node[GESTURE_KEY];
if (!gobj) {
return;
}
var gs = gobj[type];
if (!gs) {
return;
}
if (!ev[HANDLED_OBJ]) {
ev[HANDLED_OBJ] = {};
if (type.slice(0, 5) === 'touch') {
var t = ev.changedTouches[0];
if (type === 'touchstart') {
if (ev.touches.length === 1) {
POINTERSTATE.touch.id = t.identifier;
}
}
if (POINTERSTATE.touch.id !== t.identifier) {
return;
}
if (!HAS_NATIVE_TA) {
if (type === 'touchstart' || type === 'touchmove') {
Gestures.handleTouchAction(ev);
}
}
}
}
handled = ev[HANDLED_OBJ];
if (handled.skip) {
return;
}
var recognizers = Gestures.recognizers;
for (var i = 0, r; i < recognizers.length; i++) {
r = recognizers[i];
if (gs[r.name] && !handled[r.name]) {
if (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset) {
r.reset();
}
}
}
for (i = 0, r; i < recognizers.length; i++) {
r = recognizers[i];
if (gs[r.name] && !handled[r.name]) {
handled[r.name] = true;
r[type](ev);
}
}
},
handleTouchAction: function (ev) {
var t = ev.changedTouches[0];
var type = ev.type;
if (type === 'touchstart') {
POINTERSTATE.touch.x = t.clientX;
POINTERSTATE.touch.y = t.clientY;
POINTERSTATE.touch.scrollDecided = false;
} else if (type === 'touchmove') {
if (POINTERSTATE.touch.scrollDecided) {
return;
}
POINTERSTATE.touch.scrollDecided = true;
var ta = firstTouchAction(ev);
var prevent = false;
var dx = Math.abs(POINTERSTATE.touch.x - t.clientX);
var dy = Math.abs(POINTERSTATE.touch.y - t.clientY);
if (!ev.cancelable) {
} else if (ta === 'none') {
prevent = true;
} else if (ta === 'pan-x') {
prevent = dy > dx;
} else if (ta === 'pan-y') {
prevent = dx > dy;
}
if (prevent) {
ev.preventDefault();
} else {
Gestures.prevent('track');
}
}
},
add: function (node, evType, handler) {
node = wrap(node);
var recognizer = this.gestures[evType];
var deps = recognizer.deps;
var name = recognizer.name;
var gobj = node[GESTURE_KEY];
if (!gobj) {
node[GESTURE_KEY] = gobj = {};
}
for (var i = 0, dep, gd; i < deps.length; i++) {
dep = deps[i];
if (IS_TOUCH_ONLY && MOUSE_EVENTS.indexOf(dep) > -1 && dep !== 'click') {
continue;
}
gd = gobj[dep];
if (!gd) {
gobj[dep] = gd = { _count: 0 };
}
if (gd._count === 0) {
node.addEventListener(dep, this.handleNative);
}
gd[name] = (gd[name] || 0) + 1;
gd._count = (gd._count || 0) + 1;
}
node.addEventListener(evType, handler);
if (recognizer.touchAction) {
this.setTouchAction(node, recognizer.touchAction);
}
},
remove: function (node, evType, handler) {
node = wrap(node);
var recognizer = this.gestures[evType];
var deps = recognizer.deps;
var name = recognizer.name;
var gobj = node[GESTURE_KEY];
if (gobj) {
for (var i = 0, dep, gd; i < deps.length; i++) {
dep = deps[i];
gd = gobj[dep];
if (gd && gd[name]) {
gd[name] = (gd[name] || 1) - 1;
gd._count = (gd._count || 1) - 1;
if (gd._count === 0) {
node.removeEventListener(dep, this.handleNative);
}
}
}
}
node.removeEventListener(evType, handler);
},
register: function (recog) {
this.recognizers.push(recog);
for (var i = 0; i < recog.emits.length; i++) {
this.gestures[recog.emits[i]] = recog;
}
},
findRecognizerByEvent: function (evName) {
for (var i = 0, r; i < this.recognizers.length; i++) {
r = this.recognizers[i];
for (var j = 0, n; j < r.emits.length; j++) {
n = r.emits[j];
if (n === evName) {
return r;
}
}
}
return null;
},
setTouchAction: function (node, value) {
if (HAS_NATIVE_TA) {
node.style.touchAction = value;
}
node[TOUCH_ACTION] = value;
},
fire: function (target, type, detail) {
var ev = Polymer.Base.fire(type, detail, {
node: target,
bubbles: true,
cancelable: true
});
if (ev.defaultPrevented) {
var preventer = detail.preventer || detail.sourceEvent;
if (preventer && preventer.preventDefault) {
preventer.preventDefault();
}
}
},
prevent: function (evName) {
var recognizer = this.findRecognizerByEvent(evName);
if (recognizer.info) {
recognizer.info.prevent = true;
}
},
resetMouseCanceller: function () {
if (POINTERSTATE.mouse.mouseIgnoreJob) {
POINTERSTATE.mouse.mouseIgnoreJob.complete();
}
}
};
Gestures.register({
name: 'downup',
deps: [
'mousedown',
'touchstart',
'touchend'
],
flow: {
start: [
'mousedown',
'touchstart'
],
end: [
'mouseup',
'touchend'
]
},
emits: [
'down',
'up'
],
info: {
movefn: null,
upfn: null
},
reset: function () {
untrackDocument(this.info);
},
mousedown: function (e) {
if (!hasLeftMouseButton(e)) {
return;
}
var t = Gestures.findOriginalTarget(e);
var self = this;
var movefn = function movefn(e) {
if (!hasLeftMouseButton(e)) {
self.fire('up', t, e);
untrackDocument(self.info);
}
};
var upfn = function upfn(e) {
if (hasLeftMouseButton(e)) {
self.fire('up', t, e);
}
untrackDocument(self.info);
};
trackDocument(this.info, movefn, upfn);
this.fire('down', t, e);
},
touchstart: function (e) {
this.fire('down', Gestures.findOriginalTarget(e), e.changedTouches[0], e);
},
touchend: function (e) {
this.fire('up', Gestures.findOriginalTarget(e), e.changedTouches[0], e);
},
fire: function (type, target, event, preventer) {
Gestures.fire(target, type, {
x: event.clientX,
y: event.clientY,
sourceEvent: event,
preventer: preventer,
prevent: function (e) {
return Gestures.prevent(e);
}
});
}
});
Gestures.register({
name: 'track',
touchAction: 'none',
deps: [
'mousedown',
'touchstart',
'touchmove',
'touchend'
],
flow: {
start: [
'mousedown',
'touchstart'
],
end: [
'mouseup',
'touchend'
]
},
emits: ['track'],
info: {
x: 0,
y: 0,
state: 'start',
started: false,
moves: [],
addMove: function (move) {
if (this.moves.length > TRACK_LENGTH) {
this.moves.shift();
}
this.moves.push(move);
},
movefn: null,
upfn: null,
prevent: false
},
reset: function () {
this.info.state = 'start';
this.info.started = false;
this.info.moves = [];
this.info.x = 0;
this.info.y = 0;
this.info.prevent = false;
untrackDocument(this.info);
},
hasMovedEnough: function (x, y) {
if (this.info.prevent) {
return false;
}
if (this.info.started) {
return true;
}
var dx = Math.abs(this.info.x - x);
var dy = Math.abs(this.info.y - y);
return dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE;
},
mousedown: function (e) {
if (!hasLeftMouseButton(e)) {
return;
}
var t = Gestures.findOriginalTarget(e);
var self = this;
var movefn = function movefn(e) {
var x = e.clientX, y = e.clientY;
if (self.hasMovedEnough(x, y)) {
self.info.state = self.info.started ? e.type === 'mouseup' ? 'end' : 'track' : 'start';
if (self.info.state === 'start') {
Gestures.prevent('tap');
}
self.info.addMove({
x: x,
y: y
});
if (!hasLeftMouseButton(e)) {
self.info.state = 'end';
untrackDocument(self.info);
}
self.fire(t, e);
self.info.started = true;
}
};
var upfn = function upfn(e) {
if (self.info.started) {
movefn(e);
}
untrackDocument(self.info);
};
trackDocument(this.info, movefn, upfn);
this.info.x = e.clientX;
this.info.y = e.clientY;
},
touchstart: function (e) {
var ct = e.changedTouches[0];
this.info.x = ct.clientX;
this.info.y = ct.clientY;
},
touchmove: function (e) {
var t = Gestures.findOriginalTarget(e);
var ct = e.changedTouches[0];
var x = ct.clientX, y = ct.clientY;
if (this.hasMovedEnough(x, y)) {
if (this.info.state === 'start') {
Gestures.prevent('tap');
}
this.info.addMove({
x: x,
y: y
});
this.fire(t, ct);
this.info.state = 'track';
this.info.started = true;
}
},
touchend: function (e) {
var t = Gestures.findOriginalTarget(e);
var ct = e.changedTouches[0];
if (this.info.started) {
this.info.state = 'end';
this.info.addMove({
x: ct.clientX,
y: ct.clientY
});
this.fire(t, ct, e);
}
},
fire: function (target, touch, preventer) {
var secondlast = this.info.moves[this.info.moves.length - 2];
var lastmove = this.info.moves[this.info.moves.length - 1];
var dx = lastmove.x - this.info.x;
var dy = lastmove.y - this.info.y;
var ddx, ddy = 0;
if (secondlast) {
ddx = lastmove.x - secondlast.x;
ddy = lastmove.y - secondlast.y;
}
return Gestures.fire(target, 'track', {
state: this.info.state,
x: touch.clientX,
y: touch.clientY,
dx: dx,
dy: dy,
ddx: ddx,
ddy: ddy,
sourceEvent: touch,
preventer: preventer,
hover: function () {
return Gestures.deepTargetFind(touch.clientX, touch.clientY);
}
});
}
});
Gestures.register({
name: 'tap',
deps: [
'mousedown',
'click',
'touchstart',
'touchend'
],
flow: {
start: [
'mousedown',
'touchstart'
],
end: [
'click',
'touchend'
]
},
emits: ['tap'],
info: {
x: NaN,
y: NaN,
prevent: false
},
reset: function () {
this.info.x = NaN;
this.info.y = NaN;
this.info.prevent = false;
},
save: function (e) {
this.info.x = e.clientX;
this.info.y = e.clientY;
},
mousedown: function (e) {
if (hasLeftMouseButton(e)) {
this.save(e);
}
},
click: function (e) {
if (hasLeftMouseButton(e)) {
this.forward(e);
}
},
touchstart: function (e) {
this.save(e.changedTouches[0], e);
},
touchend: function (e) {
this.forward(e.changedTouches[0], e);
},
forward: function (e, preventer) {
var dx = Math.abs(e.clientX - this.info.x);
var dy = Math.abs(e.clientY - this.info.y);
var t = Gestures.findOriginalTarget(e);
if (isNaN(dx) || isNaN(dy) || dx <= TAP_DISTANCE && dy <= TAP_DISTANCE || isSyntheticClick(e)) {
if (!this.info.prevent) {
Gestures.fire(t, 'tap', {
x: e.clientX,
y: e.clientY,
sourceEvent: e,
preventer: preventer
});
}
}
}
});
var DIRECTION_MAP = {
x: 'pan-x',
y: 'pan-y',
none: 'none',
all: 'auto'
};
Polymer.Base._addFeature({
_setupGestures: function () {
this.__polymerGestures = null;
},
_listen: function (node, eventName, handler) {
if (Gestures.gestures[eventName]) {
Gestures.add(node, eventName, handler);
} else {
node.addEventListener(eventName, handler);
}
},
_unlisten: function (node, eventName, handler) {
if (Gestures.gestures[eventName]) {
Gestures.remove(node, eventName, handler);
} else {
node.removeEventListener(eventName, handler);
}
},
setScrollDirection: function (direction, node) {
node = node || this;
Gestures.setTouchAction(node, DIRECTION_MAP[direction] || 'auto');
}
});
Polymer.Gestures = Gestures;
}());(function () {
'use strict';
Polymer.Base._addFeature({
$$: function (slctr) {
return Polymer.dom(this.root).querySelector(slctr);
},
toggleClass: function (name, bool, node) {
node = node || this;
if (arguments.length == 1) {
bool = !node.classList.contains(name);
}
if (bool) {
Polymer.dom(node).classList.add(name);
} else {
Polymer.dom(node).classList.remove(name);
}
},
toggleAttribute: function (name, bool, node) {
node = node || this;
if (arguments.length == 1) {
bool = !node.hasAttribute(name);
}
if (bool) {
Polymer.dom(node).setAttribute(name, '');
} else {
Polymer.dom(node).removeAttribute(name);
}
},
classFollows: function (name, toElement, fromElement) {
if (fromElement) {
Polymer.dom(fromElement).classList.remove(name);
}
if (toElement) {
Polymer.dom(toElement).classList.add(name);
}
},
attributeFollows: function (name, toElement, fromElement) {
if (fromElement) {
Polymer.dom(fromElement).removeAttribute(name);
}
if (toElement) {
Polymer.dom(toElement).setAttribute(name, '');
}
},
getEffectiveChildNodes: function () {
return Polymer.dom(this).getEffectiveChildNodes();
},
getEffectiveChildren: function () {
var list = Polymer.dom(this).getEffectiveChildNodes();
return list.filter(function (n) {
return n.nodeType === Node.ELEMENT_NODE;
});
},
getEffectiveTextContent: function () {
var cn = this.getEffectiveChildNodes();
var tc = [];
for (var i = 0, c; c = cn[i]; i++) {
if (c.nodeType !== Node.COMMENT_NODE) {
tc.push(Polymer.dom(c).textContent);
}
}
return tc.join('');
},
queryEffectiveChildren: function (slctr) {
var e$ = Polymer.dom(this).queryDistributedElements(slctr);
return e$ && e$[0];
},
queryAllEffectiveChildren: function (slctr) {
return Polymer.dom(this).queryDistributedElements(slctr);
},
getContentChildNodes: function (slctr) {
var content = Polymer.dom(this.root).querySelector(slctr || 'content');
return content ? Polymer.dom(content).getDistributedNodes() : [];
},
getContentChildren: function (slctr) {
return this.getContentChildNodes(slctr).filter(function (n) {
return n.nodeType === Node.ELEMENT_NODE;
});
},
fire: function (type, detail, options) {
options = options || Polymer.nob;
var node = options.node || this;
detail = detail === null || detail === undefined ? {} : detail;
var bubbles = options.bubbles === undefined ? true : options.bubbles;
var cancelable = Boolean(options.cancelable);
var useCache = options._useCache;
var event = this._getEvent(type, bubbles, cancelable, useCache);
event.detail = detail;
if (useCache) {
this.__eventCache[type] = null;
}
node.dispatchEvent(event);
if (useCache) {
this.__eventCache[type] = event;
}
return event;
},
__eventCache: {},
_getEvent: function (type, bubbles, cancelable, useCache) {
var event = useCache && this.__eventCache[type];
if (!event || (event.bubbles != bubbles || event.cancelable != cancelable)) {
event = new Event(type, {
bubbles: Boolean(bubbles),
cancelable: cancelable
});
}
return event;
},
async: function (callback, waitTime) {
var self = this;
return Polymer.Async.run(function () {
callback.call(self);
}, waitTime);
},
cancelAsync: function (handle) {
Polymer.Async.cancel(handle);
},
arrayDelete: function (path, item) {
var index;
if (Array.isArray(path)) {
index = path.indexOf(item);
if (index >= 0) {
return path.splice(index, 1);
}
} else {
var arr = this._get(path);
index = arr.indexOf(item);
if (index >= 0) {
return this.splice(path, index, 1);
}
}
},
transform: function (transform, node) {
node = node || this;
node.style.webkitTransform = transform;
node.style.transform = transform;
},
translate3d: function (x, y, z, node) {
node = node || this;
this.transform('translate3d(' + x + ',' + y + ',' + z + ')', node);
},
importHref: function (href, onload, onerror, optAsync) {
var link = document.createElement('link');
link.rel = 'import';
link.href = href;
var list = Polymer.Base.importHref.imported = Polymer.Base.importHref.imported || {};
var cached = list[link.href];
var imprt = cached || link;
var self = this;
var loadListener = function (e) {
e.target.__firedLoad = true;
e.target.removeEventListener('load', loadListener);
e.target.removeEventListener('error', errorListener);
return onload.call(self, e);
};
var errorListener = function (e) {
e.target.__firedError = true;
e.target.removeEventListener('load', loadListener);
e.target.removeEventListener('error', errorListener);
return onerror.call(self, e);
};
if (onload) {
imprt.addEventListener('load', loadListener);
}
if (onerror) {
imprt.addEventListener('error', errorListener);
}
if (cached) {
if (cached.__firedLoad) {
cached.dispatchEvent(new Event('load'));
}
if (cached.__firedError) {
cached.dispatchEvent(new Event('error'));
}
} else {
list[link.href] = link;
optAsync = Boolean(optAsync);
if (optAsync) {
link.setAttribute('async', '');
}
document.head.appendChild(link);
}
return imprt;
},
create: function (tag, props) {
var elt = document.createElement(tag);
if (props) {
for (var n in props) {
elt[n] = props[n];
}
}
return elt;
},
isLightDescendant: function (node) {
return this !== node && this.contains(node) && Polymer.dom(this).getOwnerRoot() === Polymer.dom(node).getOwnerRoot();
},
isLocalDescendant: function (node) {
return this.root === Polymer.dom(node).getOwnerRoot();
}
});
if (!Polymer.Settings.useNativeCustomElements) {
var importHref = Polymer.Base.importHref;
Polymer.Base.importHref = function (href, onload, onerror, optAsync) {
CustomElements.ready = false;
var loadFn = function (e) {
CustomElements.upgradeDocumentTree(document);
CustomElements.ready = true;
if (onload) {
return onload.call(this, e);
}
};
return importHref.call(this, href, loadFn, onerror, optAsync);
};
}
}());Polymer.Bind = {
prepareModel: function (model) {
Polymer.Base.mixin(model, this._modelApi);
},
_modelApi: {
_notifyChange: function (source, event, value) {
value = value === undefined ? this[source] : value;
event = event || Polymer.CaseMap.camelToDashCase(source) + '-changed';
this.fire(event, { value: value }, {
bubbles: false,
cancelable: false,
_useCache: Polymer.Settings.eventDataCache || !Polymer.Settings.isIE
});
},
_propertySetter: function (property, value, effects, fromAbove) {
var old = this.__data__[property];
if (old !== value && (old === old || value === value)) {
this.__data__[property] = value;
if (typeof value == 'object') {
this._clearPath(property);
}
if (this._propertyChanged) {
this._propertyChanged(property, value, old);
}
if (effects) {
this._effectEffects(property, value, effects, old, fromAbove);
}
}
return old;
},
__setProperty: function (property, value, quiet, node) {
node = node || this;
var effects = node._propertyEffects && node._propertyEffects[property];
if (effects) {
node._propertySetter(property, value, effects, quiet);
} else if (node[property] !== value) {
node[property] = value;
}
},
_effectEffects: function (property, value, effects, old, fromAbove) {
for (var i = 0, l = effects.length, fx; i < l && (fx = effects[i]); i++) {
fx.fn.call(this, property, this[property], fx.effect, old, fromAbove);
}
},
_clearPath: function (path) {
for (var prop in this.__data__) {
if (Polymer.Path.isDescendant(path, prop)) {
this.__data__[prop] = undefined;
}
}
}
},
ensurePropertyEffects: function (model, property) {
if (!model._propertyEffects) {
model._propertyEffects = {};
}
var fx = model._propertyEffects[property];
if (!fx) {
fx = model._propertyEffects[property] = [];
}
return fx;
},
addPropertyEffect: function (model, property, kind, effect) {
var fx = this.ensurePropertyEffects(model, property);
var propEffect = {
kind: kind,
effect: effect,
fn: Polymer.Bind['_' + kind + 'Effect']
};
fx.push(propEffect);
return propEffect;
},
createBindings: function (model) {
var fx$ = model._propertyEffects;
if (fx$) {
for (var n in fx$) {
var fx = fx$[n];
fx.sort(this._sortPropertyEffects);
this._createAccessors(model, n, fx);
}
}
},
_sortPropertyEffects: function () {
var EFFECT_ORDER = {
'compute': 0,
'annotation': 1,
'annotatedComputation': 2,
'reflect': 3,
'notify': 4,
'observer': 5,
'complexObserver': 6,
'function': 7
};
return function (a, b) {
return EFFECT_ORDER[a.kind] - EFFECT_ORDER[b.kind];
};
}(),
_createAccessors: function (model, property, effects) {
var defun = {
get: function () {
return this.__data__[property];
}
};
var setter = function (value) {
this._propertySetter(property, value, effects);
};
var info = model.getPropertyInfo && model.getPropertyInfo(property);
if (info && info.readOnly) {
if (!info.computed) {
model['_set' + this.upper(property)] = setter;
}
} else {
defun.set = setter;
}
Object.defineProperty(model, property, defun);
},
upper: function (name) {
return name[0].toUpperCase() + name.substring(1);
},
_addAnnotatedListener: function (model, index, property, path, event, negated) {
if (!model._bindListeners) {
model._bindListeners = [];
}
var fn = this._notedListenerFactory(property, path, Polymer.Path.isDeep(path), negated);
var eventName = event || Polymer.CaseMap.camelToDashCase(property) + '-changed';
model._bindListeners.push({
index: index,
property: property,
path: path,
changedFn: fn,
event: eventName
});
},
_isEventBogus: function (e, target) {
return e.path && e.path[0] !== target;
},
_notedListenerFactory: function (property, path, isStructured, negated) {
return function (target, value, targetPath) {
if (targetPath) {
var newPath = Polymer.Path.translate(property, path, targetPath);
this._notifyPath(newPath, value);
} else {
value = target[property];
if (negated) {
value = !value;
}
if (!isStructured) {
this[path] = value;
} else {
if (this.__data__[path] != value) {
this.set(path, value);
}
}
}
};
},
prepareInstance: function (inst) {
inst.__data__ = Object.create(null);
},
setupBindListeners: function (inst) {
var b$ = inst._bindListeners;
for (var i = 0, l = b$.length, info; i < l && (info = b$[i]); i++) {
var node = inst._nodes[info.index];
this._addNotifyListener(node, inst, info.event, info.changedFn);
}
},
_addNotifyListener: function (element, context, event, changedFn) {
element.addEventListener(event, function (e) {
return context._notifyListener(changedFn, e);
});
}
};Polymer.Base.mixin(Polymer.Bind, {
_shouldAddListener: function (effect) {
return effect.name && effect.kind != 'attribute' && effect.kind != 'text' && !effect.isCompound && effect.parts[0].mode === '{';
},
_annotationEffect: function (source, value, effect) {
if (source != effect.value) {
value = this._get(effect.value);
this.__data__[effect.value] = value;
}
this._applyEffectValue(effect, value);
},
_reflectEffect: function (source, value, effect) {
this.reflectPropertyToAttribute(source, effect.attribute, value);
},
_notifyEffect: function (source, value, effect, old, fromAbove) {
if (!fromAbove) {
this._notifyChange(source, effect.event, value);
}
},
_functionEffect: function (source, value, fn, old, fromAbove) {
fn.call(this, source, value, old, fromAbove);
},
_observerEffect: function (source, value, effect, old) {
var fn = this[effect.method];
if (fn) {
fn.call(this, value, old);
} else {
this._warn(this._logf('_observerEffect', 'observer method `' + effect.method + '` not defined'));
}
},
_complexObserverEffect: function (source, value, effect) {
var fn = this[effect.method];
if (fn) {
var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
if (args) {
fn.apply(this, args);
}
} else if (effect.dynamicFn) {
} else {
this._warn(this._logf('_complexObserverEffect', 'observer method `' + effect.method + '` not defined'));
}
},
_computeEffect: function (source, value, effect) {
var fn = this[effect.method];
if (fn) {
var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
if (args) {
var computedvalue = fn.apply(this, args);
this.__setProperty(effect.name, computedvalue);
}
} else if (effect.dynamicFn) {
} else {
this._warn(this._logf('_computeEffect', 'compute method `' + effect.method + '` not defined'));
}
},
_annotatedComputationEffect: function (source, value, effect) {
var computedHost = this._rootDataHost || this;
var fn = computedHost[effect.method];
if (fn) {
var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
if (args) {
var computedvalue = fn.apply(computedHost, args);
this._applyEffectValue(effect, computedvalue);
}
} else if (effect.dynamicFn) {
} else {
computedHost._warn(computedHost._logf('_annotatedComputationEffect', 'compute method `' + effect.method + '` not defined'));
}
},
_marshalArgs: function (model, effect, path, value) {
var values = [];
var args = effect.args;
var bailoutEarly = args.length > 1 || effect.dynamicFn;
for (var i = 0, l = args.length; i < l; i++) {
var arg = args[i];
var name = arg.name;
var v;
if (arg.literal) {
v = arg.value;
} else if (path === name) {
v = value;
} else {
v = model[name];
if (v === undefined && arg.structured) {
v = Polymer.Base._get(name, model);
}
}
if (bailoutEarly && v === undefined) {
return;
}
if (arg.wildcard) {
var matches = Polymer.Path.isAncestor(path, name);
values[i] = {
path: matches ? path : name,
value: matches ? value : v,
base: v
};
} else {
values[i] = v;
}
}
return values;
}
});Polymer.Base._addFeature({
_addPropertyEffect: function (property, kind, effect) {
var prop = Polymer.Bind.addPropertyEffect(this, property, kind, effect);
prop.pathFn = this['_' + prop.kind + 'PathEffect'];
},
_prepEffects: function () {
Polymer.Bind.prepareModel(this);
this._addAnnotationEffects(this._notes);
},
_prepBindings: function () {
Polymer.Bind.createBindings(this);
},
_addPropertyEffects: function (properties) {
if (properties) {
for (var p in properties) {
var prop = properties[p];
if (prop.observer) {
this._addObserverEffect(p, prop.observer);
}
if (prop.computed) {
prop.readOnly = true;
this._addComputedEffect(p, prop.computed);
}
if (prop.notify) {
this._addPropertyEffect(p, 'notify', { event: Polymer.CaseMap.camelToDashCase(p) + '-changed' });
}
if (prop.reflectToAttribute) {
var attr = Polymer.CaseMap.camelToDashCase(p);
if (attr[0] === '-') {
this._warn(this._logf('_addPropertyEffects', 'Property ' + p + ' cannot be reflected to attribute ' + attr + ' because "-" is not a valid starting attribute name. Use a lowercase first letter for the property instead.'));
} else {
this._addPropertyEffect(p, 'reflect', { attribute: attr });
}
}
if (prop.readOnly) {
Polymer.Bind.ensurePropertyEffects(this, p);
}
}
}
},
_addComputedEffect: function (name, expression) {
var sig = this._parseMethod(expression);
var dynamicFn = sig.dynamicFn;
for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {
this._addPropertyEffect(arg.model, 'compute', {
method: sig.method,
args: sig.args,
trigger: arg,
name: name,
dynamicFn: dynamicFn
});
}
if (dynamicFn) {
this._addPropertyEffect(sig.method, 'compute', {
method: sig.method,
args: sig.args,
trigger: null,
name: name,
dynamicFn: dynamicFn
});
}
},
_addObserverEffect: function (property, observer) {
this._addPropertyEffect(property, 'observer', {
method: observer,
property: property
});
},
_addComplexObserverEffects: function (observers) {
if (observers) {
for (var i = 0, o; i < observers.length && (o = observers[i]); i++) {
this._addComplexObserverEffect(o);
}
}
},
_addComplexObserverEffect: function (observer) {
var sig = this._parseMethod(observer);
if (!sig) {
throw new Error('Malformed observer expression \'' + observer + '\'');
}
var dynamicFn = sig.dynamicFn;
for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {
this._addPropertyEffect(arg.model, 'complexObserver', {
method: sig.method,
args: sig.args,
trigger: arg,
dynamicFn: dynamicFn
});
}
if (dynamicFn) {
this._addPropertyEffect(sig.method, 'complexObserver', {
method: sig.method,
args: sig.args,
trigger: null,
dynamicFn: dynamicFn
});
}
},
_addAnnotationEffects: function (notes) {
for (var i = 0, note; i < notes.length && (note = notes[i]); i++) {
var b$ = note.bindings;
for (var j = 0, binding; j < b$.length && (binding = b$[j]); j++) {
this._addAnnotationEffect(binding, i);
}
}
},
_addAnnotationEffect: function (note, index) {
if (Polymer.Bind._shouldAddListener(note)) {
Polymer.Bind._addAnnotatedListener(this, index, note.name, note.parts[0].value, note.parts[0].event, note.parts[0].negate);
}
for (var i = 0; i < note.parts.length; i++) {
var part = note.parts[i];
if (part.signature) {
this._addAnnotatedComputationEffect(note, part, index);
} else if (!part.literal) {
if (note.kind === 'attribute' && note.name[0] === '-') {
this._warn(this._logf('_addAnnotationEffect', 'Cannot set attribute ' + note.name + ' because "-" is not a valid attribute starting character'));
} else {
this._addPropertyEffect(part.model, 'annotation', {
kind: note.kind,
index: index,
name: note.name,
propertyName: note.propertyName,
value: part.value,
isCompound: note.isCompound,
compoundIndex: part.compoundIndex,
event: part.event,
customEvent: part.customEvent,
negate: part.negate
});
}
}
}
},
_addAnnotatedComputationEffect: function (note, part, index) {
var sig = part.signature;
if (sig.static) {
this.__addAnnotatedComputationEffect('__static__', index, note, part, null);
} else {
for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {
if (!arg.literal) {
this.__addAnnotatedComputationEffect(arg.model, index, note, part, arg);
}
}
if (sig.dynamicFn) {
this.__addAnnotatedComputationEffect(sig.method, index, note, part, null);
}
}
},
__addAnnotatedComputationEffect: function (property, index, note, part, trigger) {
this._addPropertyEffect(property, 'annotatedComputation', {
index: index,
isCompound: note.isCompound,
compoundIndex: part.compoundIndex,
kind: note.kind,
name: note.name,
negate: part.negate,
method: part.signature.method,
args: part.signature.args,
trigger: trigger,
dynamicFn: part.signature.dynamicFn
});
},
_parseMethod: function (expression) {
var m = expression.match(/([^\s]+?)\(([\s\S]*)\)/);
if (m) {
var sig = {
method: m[1],
static: true
};
if (this.getPropertyInfo(sig.method) !== Polymer.nob) {
sig.static = false;
sig.dynamicFn = true;
}
if (m[2].trim()) {
var args = m[2].replace(/\\,/g, '&comma;').split(',');
return this._parseArgs(args, sig);
} else {
sig.args = Polymer.nar;
return sig;
}
}
},
_parseArgs: function (argList, sig) {
sig.args = argList.map(function (rawArg) {
var arg = this._parseArg(rawArg);
if (!arg.literal) {
sig.static = false;
}
return arg;
}, this);
return sig;
},
_parseArg: function (rawArg) {
var arg = rawArg.trim().replace(/&comma;/g, ',').replace(/\\(.)/g, '$1');
var a = { name: arg };
var fc = arg[0];
if (fc === '-') {
fc = arg[1];
}
if (fc >= '0' && fc <= '9') {
fc = '#';
}
switch (fc) {
case '\'':
case '"':
a.value = arg.slice(1, -1);
a.literal = true;
break;
case '#':
a.value = Number(arg);
a.literal = true;
break;
}
if (!a.literal) {
a.model = Polymer.Path.root(arg);
a.structured = Polymer.Path.isDeep(arg);
if (a.structured) {
a.wildcard = arg.slice(-2) == '.*';
if (a.wildcard) {
a.name = arg.slice(0, -2);
}
}
}
return a;
},
_marshalInstanceEffects: function () {
Polymer.Bind.prepareInstance(this);
if (this._bindListeners) {
Polymer.Bind.setupBindListeners(this);
}
},
_applyEffectValue: function (info, value) {
var node = this._nodes[info.index];
var property = info.name;
value = this._computeFinalAnnotationValue(node, property, value, info);
if (info.kind == 'attribute') {
this.serializeValueToAttribute(value, property, node);
} else {
var pinfo = node._propertyInfo && node._propertyInfo[property];
if (pinfo && pinfo.readOnly) {
return;
}
this.__setProperty(property, value, Polymer.Settings.suppressBindingNotifications, node);
}
},
_computeFinalAnnotationValue: function (node, property, value, info) {
if (info.negate) {
value = !value;
}
if (info.isCompound) {
var storage = node.__compoundStorage__[property];
storage[info.compoundIndex] = value;
value = storage.join('');
}
if (info.kind !== 'attribute') {
if (property === 'className') {
value = this._scopeElementClass(node, value);
}
if (property === 'textContent' || node.localName == 'input' && property == 'value') {
value = value == undefined ? '' : value;
}
}
return value;
},
_executeStaticEffects: function () {
if (this._propertyEffects && this._propertyEffects.__static__) {
this._effectEffects('__static__', null, this._propertyEffects.__static__);
}
}
});(function () {
var usePolyfillProto = Polymer.Settings.usePolyfillProto;
var avoidInstanceProperties = Boolean(Object.getOwnPropertyDescriptor(document.documentElement, 'properties'));
Polymer.Base._addFeature({
_setupConfigure: function (initialConfig) {
this._config = {};
this._handlers = [];
this._aboveConfig = null;
if (initialConfig) {
for (var i in initialConfig) {
if (initialConfig[i] !== undefined) {
this._config[i] = initialConfig[i];
}
}
}
},
_marshalAttributes: function () {
this._takeAttributesToModel(this._config);
},
_attributeChangedImpl: function (name) {
var model = this._clientsReadied ? this : this._config;
this._setAttributeToProperty(model, name);
},
_configValue: function (name, value) {
var info = this._propertyInfo[name];
if (!info || !info.readOnly) {
this._config[name] = value;
}
},
_beforeClientsReady: function () {
this._configure();
},
_configure: function () {
this._configureAnnotationReferences();
this._configureInstanceProperties();
this._aboveConfig = this.mixin({}, this._config);
var config = {};
for (var i = 0; i < this.behaviors.length; i++) {
this._configureProperties(this.behaviors[i].properties, config);
}
this._configureProperties(avoidInstanceProperties ? this.__proto__.properties : this.properties, config);
this.mixin(config, this._aboveConfig);
this._config = config;
if (this._clients && this._clients.length) {
this._distributeConfig(this._config);
}
},
_configureInstanceProperties: function () {
for (var i in this._propertyEffects) {
if (!usePolyfillProto && this.hasOwnProperty(i)) {
this._configValue(i, this[i]);
delete this[i];
}
}
},
_configureProperties: function (properties, config) {
for (var i in properties) {
var c = properties[i];
if (c.value !== undefined) {
var value = c.value;
if (typeof value == 'function') {
value = value.call(this, this._config);
}
config[i] = value;
}
}
},
_distributeConfig: function (config) {
var fx$ = this._propertyEffects;
if (fx$) {
for (var p in config) {
var fx = fx$[p];
if (fx) {
for (var i = 0, l = fx.length, x; i < l && (x = fx[i]); i++) {
if (x.kind === 'annotation') {
var node = this._nodes[x.effect.index];
var name = x.effect.propertyName;
var isAttr = x.effect.kind == 'attribute';
var hasEffect = node._propertyEffects && node._propertyEffects[name];
if (node._configValue && (hasEffect || !isAttr)) {
var value = p === x.effect.value ? config[p] : this._get(x.effect.value, config);
value = this._computeFinalAnnotationValue(node, name, value, x.effect);
if (isAttr) {
value = node.deserialize(this.serialize(value), node._propertyInfo[name].type);
}
node._configValue(name, value);
}
}
}
}
}
}
},
_afterClientsReady: function () {
this.importPath = this._importPath;
this.rootPath = Polymer.rootPath;
this._executeStaticEffects();
this._applyConfig(this._config, this._aboveConfig);
this._flushHandlers();
},
_applyConfig: function (config, aboveConfig) {
for (var n in config) {
if (this[n] === undefined) {
this.__setProperty(n, config[n], n in aboveConfig);
}
}
},
_notifyListener: function (fn, e) {
if (!Polymer.Bind._isEventBogus(e, e.target)) {
var value, path;
if (e.detail) {
value = e.detail.value;
path = e.detail.path;
}
if (!this._clientsReadied) {
this._queueHandler([
fn,
e.target,
value,
path
]);
} else {
return fn.call(this, e.target, value, path);
}
}
},
_queueHandler: function (args) {
this._handlers.push(args);
},
_flushHandlers: function () {
var h$ = this._handlers;
for (var i = 0, l = h$.length, h; i < l && (h = h$[i]); i++) {
h[0].call(this, h[1], h[2], h[3]);
}
this._handlers = [];
}
});
}());(function () {
'use strict';
var Path = Polymer.Path;
Polymer.Base._addFeature({
notifyPath: function (path, value, fromAbove) {
var info = {};
var v = this._get(path, this, info);
if (arguments.length === 1) {
value = v;
}
if (info.path) {
this._notifyPath(info.path, value, fromAbove);
}
},
_notifyPath: function (path, value, fromAbove) {
var old = this._propertySetter(path, value);
if (old !== value && (old === old || value === value)) {
this._pathEffector(path, value);
if (!fromAbove) {
this._notifyPathUp(path, value);
}
return true;
}
},
_getPathParts: function (path) {
if (Array.isArray(path)) {
var parts = [];
for (var i = 0; i < path.length; i++) {
var args = path[i].toString().split('.');
for (var j = 0; j < args.length; j++) {
parts.push(args[j]);
}
}
return parts;
} else {
return path.toString().split('.');
}
},
set: function (path, value, root) {
var prop = root || this;
var parts = this._getPathParts(path);
var array;
var last = parts[parts.length - 1];
if (parts.length > 1) {
for (var i = 0; i < parts.length - 1; i++) {
var part = parts[i];
if (array && part[0] == '#') {
prop = Polymer.Collection.get(array).getItem(part);
} else {
prop = prop[part];
if (array && parseInt(part, 10) == part) {
parts[i] = Polymer.Collection.get(array).getKey(prop);
}
}
if (!prop) {
return;
}
array = Array.isArray(prop) ? prop : null;
}
if (array) {
var coll = Polymer.Collection.get(array);
var old, key;
if (last[0] == '#') {
key = last;
old = coll.getItem(key);
last = array.indexOf(old);
coll.setItem(key, value);
} else if (parseInt(last, 10) == last) {
old = prop[last];
key = coll.getKey(old);
parts[i] = key;
coll.setItem(key, value);
}
}
prop[last] = value;
if (!root) {
this._notifyPath(parts.join('.'), value);
}
} else {
prop[path] = value;
}
},
get: function (path, root) {
return this._get(path, root);
},
_get: function (path, root, info) {
var prop = root || this;
var parts = this._getPathParts(path);
var array;
for (var i = 0; i < parts.length; i++) {
if (!prop) {
return;
}
var part = parts[i];
if (array && part[0] == '#') {
prop = Polymer.Collection.get(array).getItem(part);
} else {
prop = prop[part];
if (info && array && parseInt(part, 10) == part) {
parts[i] = Polymer.Collection.get(array).getKey(prop);
}
}
array = Array.isArray(prop) ? prop : null;
}
if (info) {
info.path = parts.join('.');
}
return prop;
},
_pathEffector: function (path, value) {
var model = Path.root(path);
var fx$ = this._propertyEffects && this._propertyEffects[model];
if (fx$) {
for (var i = 0, fx; i < fx$.length && (fx = fx$[i]); i++) {
var fxFn = fx.pathFn;
if (fxFn) {
fxFn.call(this, path, value, fx.effect);
}
}
}
if (this._boundPaths) {
this._notifyBoundPaths(path, value);
}
},
_annotationPathEffect: function (path, value, effect) {
if (Path.matches(effect.value, false, path)) {
Polymer.Bind._annotationEffect.call(this, path, value, effect);
} else if (!effect.negate && Path.isDescendant(effect.value, path)) {
var node = this._nodes[effect.index];
if (node && node._notifyPath) {
var newPath = Path.translate(effect.value, effect.name, path);
node._notifyPath(newPath, value, true);
}
}
},
_complexObserverPathEffect: function (path, value, effect) {
if (Path.matches(effect.trigger.name, effect.trigger.wildcard, path)) {
Polymer.Bind._complexObserverEffect.call(this, path, value, effect);
}
},
_computePathEffect: function (path, value, effect) {
if (Path.matches(effect.trigger.name, effect.trigger.wildcard, path)) {
Polymer.Bind._computeEffect.call(this, path, value, effect);
}
},
_annotatedComputationPathEffect: function (path, value, effect) {
if (Path.matches(effect.trigger.name, effect.trigger.wildcard, path)) {
Polymer.Bind._annotatedComputationEffect.call(this, path, value, effect);
}
},
linkPaths: function (to, from) {
this._boundPaths = this._boundPaths || {};
if (from) {
this._boundPaths[to] = from;
} else {
this.unlinkPaths(to);
}
},
unlinkPaths: function (path) {
if (this._boundPaths) {
delete this._boundPaths[path];
}
},
_notifyBoundPaths: function (path, value) {
for (var a in this._boundPaths) {
var b = this._boundPaths[a];
if (Path.isDescendant(a, path)) {
this._notifyPath(Path.translate(a, b, path), value);
} else if (Path.isDescendant(b, path)) {
this._notifyPath(Path.translate(b, a, path), value);
}
}
},
_notifyPathUp: function (path, value) {
var rootName = Path.root(path);
var dashCaseName = Polymer.CaseMap.camelToDashCase(rootName);
var eventName = dashCaseName + this._EVENT_CHANGED;
this.fire(eventName, {
path: path,
value: value
}, {
bubbles: false,
_useCache: Polymer.Settings.eventDataCache || !Polymer.Settings.isIE
});
},
_EVENT_CHANGED: '-changed',
notifySplices: function (path, splices) {
var info = {};
var array = this._get(path, this, info);
this._notifySplices(array, info.path, splices);
},
_notifySplices: function (array, path, splices) {
var change = {
keySplices: Polymer.Collection.applySplices(array, splices),
indexSplices: splices
};
var splicesPath = path + '.splices';
this._notifyPath(splicesPath, change);
this._notifyPath(path + '.length', array.length);
this.__data__[splicesPath] = {
keySplices: null,
indexSplices: null
};
},
_notifySplice: function (array, path, index, added, removed) {
this._notifySplices(array, path, [{
index: index,
addedCount: added,
removed: removed,
object: array,
type: 'splice'
}]);
},
push: function (path) {
var info = {};
var array = this._get(path, this, info);
var args = Array.prototype.slice.call(arguments, 1);
var len = array.length;
var ret = array.push.apply(array, args);
if (args.length) {
this._notifySplice(array, info.path, len, args.length, []);
}
return ret;
},
pop: function (path) {
var info = {};
var array = this._get(path, this, info);
var hadLength = Boolean(array.length);
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.pop.apply(array, args);
if (hadLength) {
this._notifySplice(array, info.path, array.length, 0, [ret]);
}
return ret;
},
splice: function (path, start) {
var info = {};
var array = this._get(path, this, info);
if (start < 0) {
start = array.length - Math.floor(-start);
} else {
start = Math.floor(start);
}
if (!start) {
start = 0;
}
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.splice.apply(array, args);
var addedCount = Math.max(args.length - 2, 0);
if (addedCount || ret.length) {
this._notifySplice(array, info.path, start, addedCount, ret);
}
return ret;
},
shift: function (path) {
var info = {};
var array = this._get(path, this, info);
var hadLength = Boolean(array.length);
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.shift.apply(array, args);
if (hadLength) {
this._notifySplice(array, info.path, 0, 0, [ret]);
}
return ret;
},
unshift: function (path) {
var info = {};
var array = this._get(path, this, info);
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.unshift.apply(array, args);
if (args.length) {
this._notifySplice(array, info.path, 0, args.length, []);
}
return ret;
},
prepareModelNotifyPath: function (model) {
this.mixin(model, {
fire: Polymer.Base.fire,
_getEvent: Polymer.Base._getEvent,
__eventCache: Polymer.Base.__eventCache,
notifyPath: Polymer.Base.notifyPath,
_get: Polymer.Base._get,
_EVENT_CHANGED: Polymer.Base._EVENT_CHANGED,
_notifyPath: Polymer.Base._notifyPath,
_notifyPathUp: Polymer.Base._notifyPathUp,
_pathEffector: Polymer.Base._pathEffector,
_annotationPathEffect: Polymer.Base._annotationPathEffect,
_complexObserverPathEffect: Polymer.Base._complexObserverPathEffect,
_annotatedComputationPathEffect: Polymer.Base._annotatedComputationPathEffect,
_computePathEffect: Polymer.Base._computePathEffect,
_notifyBoundPaths: Polymer.Base._notifyBoundPaths,
_getPathParts: Polymer.Base._getPathParts
});
}
});
}());Polymer.Base._addFeature({
resolveUrl: function (url) {
return Polymer.ResolveUrl.resolveUrl(url, this._importPath);
}
});Polymer.CssParse = function () {
return {
parse: function (text) {
text = this._clean(text);
return this._parseCss(this._lex(text), text);
},
_clean: function (cssText) {
return cssText.replace(this._rx.comments, '').replace(this._rx.port, '');
},
_lex: function (text) {
var root = {
start: 0,
end: text.length
};
var n = root;
for (var i = 0, l = text.length; i < l; i++) {
switch (text[i]) {
case this.OPEN_BRACE:
if (!n.rules) {
n.rules = [];
}
var p = n;
var previous = p.rules[p.rules.length - 1];
n = {
start: i + 1,
parent: p,
previous: previous
};
p.rules.push(n);
break;
case this.CLOSE_BRACE:
n.end = i + 1;
n = n.parent || root;
break;
}
}
return root;
},
_parseCss: function (node, text) {
var t = text.substring(node.start, node.end - 1);
node.parsedCssText = node.cssText = t.trim();
if (node.parent) {
var ss = node.previous ? node.previous.end : node.parent.start;
t = text.substring(ss, node.start - 1);
t = this._expandUnicodeEscapes(t);
t = t.replace(this._rx.multipleSpaces, ' ');
t = t.substring(t.lastIndexOf(';') + 1);
var s = node.parsedSelector = node.selector = t.trim();
node.atRule = s.indexOf(this.AT_START) === 0;
if (node.atRule) {
if (s.indexOf(this.MEDIA_START) === 0) {
node.type = this.types.MEDIA_RULE;
} else if (s.match(this._rx.keyframesRule)) {
node.type = this.types.KEYFRAMES_RULE;
node.keyframesName = node.selector.split(this._rx.multipleSpaces).pop();
}
} else {
if (s.indexOf(this.VAR_START) === 0) {
node.type = this.types.MIXIN_RULE;
} else {
node.type = this.types.STYLE_RULE;
}
}
}
var r$ = node.rules;
if (r$) {
for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
this._parseCss(r, text);
}
}
return node;
},
_expandUnicodeEscapes: function (s) {
return s.replace(/\\([0-9a-f]{1,6})\s/gi, function () {
var code = arguments[1], repeat = 6 - code.length;
while (repeat--) {
code = '0' + code;
}
return '\\' + code;
});
},
stringify: function (node, preserveProperties, text) {
text = text || '';
var cssText = '';
if (node.cssText || node.rules) {
var r$ = node.rules;
if (r$ && !this._hasMixinRules(r$)) {
for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
cssText = this.stringify(r, preserveProperties, cssText);
}
} else {
cssText = preserveProperties ? node.cssText : this.removeCustomProps(node.cssText);
cssText = cssText.trim();
if (cssText) {
cssText = '  ' + cssText + '\n';
}
}
}
if (cssText) {
if (node.selector) {
text += node.selector + ' ' + this.OPEN_BRACE + '\n';
}
text += cssText;
if (node.selector) {
text += this.CLOSE_BRACE + '\n\n';
}
}
return text;
},
_hasMixinRules: function (rules) {
return rules[0].selector.indexOf(this.VAR_START) === 0;
},
removeCustomProps: function (cssText) {
cssText = this.removeCustomPropAssignment(cssText);
return this.removeCustomPropApply(cssText);
},
removeCustomPropAssignment: function (cssText) {
return cssText.replace(this._rx.customProp, '').replace(this._rx.mixinProp, '');
},
removeCustomPropApply: function (cssText) {
return cssText.replace(this._rx.mixinApply, '').replace(this._rx.varApply, '');
},
types: {
STYLE_RULE: 1,
KEYFRAMES_RULE: 7,
MEDIA_RULE: 4,
MIXIN_RULE: 1000
},
OPEN_BRACE: '{',
CLOSE_BRACE: '}',
_rx: {
comments: /\/\*[^*]*\*+([^\/*][^*]*\*+)*\//gim,
port: /@import[^;]*;/gim,
customProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\n]|$)/gim,
mixinProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\n]|$)?/gim,
mixinApply: /@apply\s*\(?[^);]*\)?\s*(?:[;\n]|$)?/gim,
varApply: /[^;:]*?:[^;]*?var\([^;]*\)(?:[;\n]|$)?/gim,
keyframesRule: /^@[^\s]*keyframes/,
multipleSpaces: /\s+/g
},
VAR_START: '--',
MEDIA_START: '@media',
AT_START: '@'
};
}();Polymer.StyleUtil = function () {
var settings = Polymer.Settings;
return {
NATIVE_VARIABLES: Polymer.Settings.useNativeCSSProperties,
MODULE_STYLES_SELECTOR: 'style, link[rel=import][type~=css], template',
INCLUDE_ATTR: 'include',
toCssText: function (rules, callback) {
if (typeof rules === 'string') {
rules = this.parser.parse(rules);
}
if (callback) {
this.forEachRule(rules, callback);
}
return this.parser.stringify(rules, this.NATIVE_VARIABLES);
},
forRulesInStyles: function (styles, styleRuleCallback, keyframesRuleCallback) {
if (styles) {
for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {
this.forEachRuleInStyle(s, styleRuleCallback, keyframesRuleCallback);
}
}
},
forActiveRulesInStyles: function (styles, styleRuleCallback, keyframesRuleCallback) {
if (styles) {
for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {
this.forEachRuleInStyle(s, styleRuleCallback, keyframesRuleCallback, true);
}
}
},
rulesForStyle: function (style) {
if (!style.__cssRules && style.textContent) {
style.__cssRules = this.parser.parse(style.textContent);
}
return style.__cssRules;
},
isKeyframesSelector: function (rule) {
return rule.parent && rule.parent.type === this.ruleTypes.KEYFRAMES_RULE;
},
forEachRuleInStyle: function (style, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {
var rules = this.rulesForStyle(style);
var styleCallback, keyframeCallback;
if (styleRuleCallback) {
styleCallback = function (rule) {
styleRuleCallback(rule, style);
};
}
if (keyframesRuleCallback) {
keyframeCallback = function (rule) {
keyframesRuleCallback(rule, style);
};
}
this.forEachRule(rules, styleCallback, keyframeCallback, onlyActiveRules);
},
forEachRule: function (node, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {
if (!node) {
return;
}
var skipRules = false;
if (onlyActiveRules) {
if (node.type === this.ruleTypes.MEDIA_RULE) {
var matchMedia = node.selector.match(this.rx.MEDIA_MATCH);
if (matchMedia) {
if (!window.matchMedia(matchMedia[1]).matches) {
skipRules = true;
}
}
}
}
if (node.type === this.ruleTypes.STYLE_RULE) {
styleRuleCallback(node);
} else if (keyframesRuleCallback && node.type === this.ruleTypes.KEYFRAMES_RULE) {
keyframesRuleCallback(node);
} else if (node.type === this.ruleTypes.MIXIN_RULE) {
skipRules = true;
}
var r$ = node.rules;
if (r$ && !skipRules) {
for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
this.forEachRule(r, styleRuleCallback, keyframesRuleCallback, onlyActiveRules);
}
}
},
applyCss: function (cssText, moniker, target, contextNode) {
var style = this.createScopeStyle(cssText, moniker);
return this.applyStyle(style, target, contextNode);
},
applyStyle: function (style, target, contextNode) {
target = target || document.head;
var after = contextNode && contextNode.nextSibling || target.firstChild;
this.__lastHeadApplyNode = style;
return target.insertBefore(style, after);
},
createScopeStyle: function (cssText, moniker) {
var style = document.createElement('style');
if (moniker) {
style.setAttribute('scope', moniker);
}
style.textContent = cssText;
return style;
},
__lastHeadApplyNode: null,
applyStylePlaceHolder: function (moniker) {
var placeHolder = document.createComment(' Shady DOM styles for ' + moniker + ' ');
var after = this.__lastHeadApplyNode ? this.__lastHeadApplyNode.nextSibling : null;
var scope = document.head;
scope.insertBefore(placeHolder, after || scope.firstChild);
this.__lastHeadApplyNode = placeHolder;
return placeHolder;
},
cssFromModules: function (moduleIds, warnIfNotFound) {
var modules = moduleIds.trim().split(' ');
var cssText = '';
for (var i = 0; i < modules.length; i++) {
cssText += this.cssFromModule(modules[i], warnIfNotFound);
}
return cssText;
},
cssFromModule: function (moduleId, warnIfNotFound) {
var m = Polymer.DomModule.import(moduleId);
if (m && !m._cssText) {
m._cssText = this.cssFromElement(m);
}
if (!m && warnIfNotFound) {
console.warn('Could not find style data in module named', moduleId);
}
return m && m._cssText || '';
},
cssFromElement: function (element) {
var cssText = '';
var content = element.content || element;
var e$ = Polymer.TreeApi.arrayCopy(content.querySelectorAll(this.MODULE_STYLES_SELECTOR));
for (var i = 0, e; i < e$.length; i++) {
e = e$[i];
if (e.localName === 'template') {
if (!e.hasAttribute('preserve-content')) {
cssText += this.cssFromElement(e);
}
} else {
if (e.localName === 'style') {
var include = e.getAttribute(this.INCLUDE_ATTR);
if (include) {
cssText += this.cssFromModules(include, true);
}
e = e.__appliedElement || e;
e.parentNode.removeChild(e);
cssText += this.resolveCss(e.textContent, element.ownerDocument);
} else if (e.import && e.import.body) {
cssText += this.resolveCss(e.import.body.textContent, e.import);
}
}
}
return cssText;
},
styleIncludesToTemplate: function (targetTemplate) {
var styles = targetTemplate.content.querySelectorAll('style[include]');
for (var i = 0, s; i < styles.length; i++) {
s = styles[i];
s.parentNode.insertBefore(this._includesToFragment(s.getAttribute('include')), s);
}
},
_includesToFragment: function (styleIncludes) {
var includeArray = styleIncludes.trim().split(' ');
var frag = document.createDocumentFragment();
for (var i = 0; i < includeArray.length; i++) {
var t = Polymer.DomModule.import(includeArray[i], 'template');
if (t) {
this._addStylesToFragment(frag, t.content);
}
}
return frag;
},
_addStylesToFragment: function (frag, source) {
var s$ = source.querySelectorAll('style');
for (var i = 0, s; i < s$.length; i++) {
s = s$[i];
var include = s.getAttribute('include');
if (include) {
frag.appendChild(this._includesToFragment(include));
}
if (s.textContent) {
frag.appendChild(s.cloneNode(true));
}
}
},
isTargetedBuild: function (buildType) {
return settings.useNativeShadow ? buildType === 'shadow' : buildType === 'shady';
},
cssBuildTypeForModule: function (module) {
var dm = Polymer.DomModule.import(module);
if (dm) {
return this.getCssBuildType(dm);
}
},
getCssBuildType: function (element) {
return element.getAttribute('css-build');
},
_findMatchingParen: function (text, start) {
var level = 0;
for (var i = start, l = text.length; i < l; i++) {
switch (text[i]) {
case '(':
level++;
break;
case ')':
if (--level === 0) {
return i;
}
break;
}
}
return -1;
},
processVariableAndFallback: function (str, callback) {
var start = str.indexOf('var(');
if (start === -1) {
return callback(str, '', '', '');
}
var end = this._findMatchingParen(str, start + 3);
var inner = str.substring(start + 4, end);
var prefix = str.substring(0, start);
var suffix = this.processVariableAndFallback(str.substring(end + 1), callback);
var comma = inner.indexOf(',');
if (comma === -1) {
return callback(prefix, inner.trim(), '', suffix);
}
var value = inner.substring(0, comma).trim();
var fallback = inner.substring(comma + 1).trim();
return callback(prefix, value, fallback, suffix);
},
rx: {
VAR_ASSIGN: /(?:^|[;\s{]\s*)(--[\w-]*?)\s*:\s*(?:([^;{]*)|{([^}]*)})(?:(?=[;\s}])|$)/gi,
MIXIN_MATCH: /(?:^|\W+)@apply\s*\(?([^);\n]*)\)?/gi,
VAR_CONSUMED: /(--[\w-]+)\s*([:,;)]|$)/gi,
ANIMATION_MATCH: /(animation\s*:)|(animation-name\s*:)/,
MEDIA_MATCH: /@media[^(]*(\([^)]*\))/,
IS_VAR: /^--/,
BRACKETED: /\{[^}]*\}/g,
HOST_PREFIX: '(?:^|[^.#[:])',
HOST_SUFFIX: '($|[.:[\\s>+~])'
},
resolveCss: Polymer.ResolveUrl.resolveCss,
parser: Polymer.CssParse,
ruleTypes: Polymer.CssParse.types
};
}();Polymer.StyleTransformer = function () {
var styleUtil = Polymer.StyleUtil;
var settings = Polymer.Settings;
var api = {
dom: function (node, scope, useAttr, shouldRemoveScope) {
this._transformDom(node, scope || '', useAttr, shouldRemoveScope);
},
_transformDom: function (node, selector, useAttr, shouldRemoveScope) {
if (node.setAttribute) {
this.element(node, selector, useAttr, shouldRemoveScope);
}
var c$ = Polymer.dom(node).childNodes;
for (var i = 0; i < c$.length; i++) {
this._transformDom(c$[i], selector, useAttr, shouldRemoveScope);
}
},
element: function (element, scope, useAttr, shouldRemoveScope) {
if (useAttr) {
if (shouldRemoveScope) {
element.removeAttribute(SCOPE_NAME);
} else {
element.setAttribute(SCOPE_NAME, scope);
}
} else {
if (scope) {
if (element.classList) {
if (shouldRemoveScope) {
element.classList.remove(SCOPE_NAME);
element.classList.remove(scope);
} else {
element.classList.add(SCOPE_NAME);
element.classList.add(scope);
}
} else if (element.getAttribute) {
var c = element.getAttribute(CLASS);
if (shouldRemoveScope) {
if (c) {
element.setAttribute(CLASS, c.replace(SCOPE_NAME, '').replace(scope, ''));
}
} else {
element.setAttribute(CLASS, (c ? c + ' ' : '') + SCOPE_NAME + ' ' + scope);
}
}
}
}
},
elementStyles: function (element, callback) {
var styles = element._styles;
var cssText = '';
var cssBuildType = element.__cssBuild;
var passthrough = settings.useNativeShadow || cssBuildType === 'shady';
var cb;
if (passthrough) {
var self = this;
cb = function (rule) {
rule.selector = self._slottedToContent(rule.selector);
rule.selector = rule.selector.replace(ROOT, ':host > *');
if (callback) {
callback(rule);
}
};
}
for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {
var rules = styleUtil.rulesForStyle(s);
cssText += passthrough ? styleUtil.toCssText(rules, cb) : this.css(rules, element.is, element.extends, callback, element._scopeCssViaAttr) + '\n\n';
}
return cssText.trim();
},
css: function (rules, scope, ext, callback, useAttr) {
var hostScope = this._calcHostScope(scope, ext);
scope = this._calcElementScope(scope, useAttr);
var self = this;
return styleUtil.toCssText(rules, function (rule) {
if (!rule.isScoped) {
self.rule(rule, scope, hostScope);
rule.isScoped = true;
}
if (callback) {
callback(rule, scope, hostScope);
}
});
},
_calcElementScope: function (scope, useAttr) {
if (scope) {
return useAttr ? CSS_ATTR_PREFIX + scope + CSS_ATTR_SUFFIX : CSS_CLASS_PREFIX + scope;
} else {
return '';
}
},
_calcHostScope: function (scope, ext) {
return ext ? '[is=' + scope + ']' : scope;
},
rule: function (rule, scope, hostScope) {
this._transformRule(rule, this._transformComplexSelector, scope, hostScope);
},
_transformRule: function (rule, transformer, scope, hostScope) {
rule.selector = rule.transformedSelector = this._transformRuleCss(rule, transformer, scope, hostScope);
},
_transformRuleCss: function (rule, transformer, scope, hostScope) {
var p$ = rule.selector.split(COMPLEX_SELECTOR_SEP);
if (!styleUtil.isKeyframesSelector(rule)) {
for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {
p$[i] = transformer.call(this, p, scope, hostScope);
}
}
return p$.join(COMPLEX_SELECTOR_SEP);
},
_transformComplexSelector: function (selector, scope, hostScope) {
var stop = false;
var hostContext = false;
var self = this;
selector = selector.trim();
selector = this._slottedToContent(selector);
selector = selector.replace(ROOT, ':host > *');
selector = selector.replace(CONTENT_START, HOST + ' $1');
selector = selector.replace(SIMPLE_SELECTOR_SEP, function (m, c, s) {
if (!stop) {
var info = self._transformCompoundSelector(s, c, scope, hostScope);
stop = stop || info.stop;
hostContext = hostContext || info.hostContext;
c = info.combinator;
s = info.value;
} else {
s = s.replace(SCOPE_JUMP, ' ');
}
return c + s;
});
if (hostContext) {
selector = selector.replace(HOST_CONTEXT_PAREN, function (m, pre, paren, post) {
return pre + paren + ' ' + hostScope + post + COMPLEX_SELECTOR_SEP + ' ' + pre + hostScope + paren + post;
});
}
return selector;
},
_transformCompoundSelector: function (selector, combinator, scope, hostScope) {
var jumpIndex = selector.search(SCOPE_JUMP);
var hostContext = false;
if (selector.indexOf(HOST_CONTEXT) >= 0) {
hostContext = true;
} else if (selector.indexOf(HOST) >= 0) {
selector = this._transformHostSelector(selector, hostScope);
} else if (jumpIndex !== 0) {
selector = scope ? this._transformSimpleSelector(selector, scope) : selector;
}
if (selector.indexOf(CONTENT) >= 0) {
combinator = '';
}
var stop;
if (jumpIndex >= 0) {
selector = selector.replace(SCOPE_JUMP, ' ');
stop = true;
}
return {
value: selector,
combinator: combinator,
stop: stop,
hostContext: hostContext
};
},
_transformSimpleSelector: function (selector, scope) {
var p$ = selector.split(PSEUDO_PREFIX);
p$[0] += scope;
return p$.join(PSEUDO_PREFIX);
},
_transformHostSelector: function (selector, hostScope) {
var m = selector.match(HOST_PAREN);
var paren = m && m[2].trim() || '';
if (paren) {
if (!paren[0].match(SIMPLE_SELECTOR_PREFIX)) {
var typeSelector = paren.split(SIMPLE_SELECTOR_PREFIX)[0];
if (typeSelector === hostScope) {
return paren;
} else {
return SELECTOR_NO_MATCH;
}
} else {
return selector.replace(HOST_PAREN, function (m, host, paren) {
return hostScope + paren;
});
}
} else {
return selector.replace(HOST, hostScope);
}
},
documentRule: function (rule) {
rule.selector = rule.parsedSelector;
this.normalizeRootSelector(rule);
if (!settings.useNativeShadow) {
this._transformRule(rule, this._transformDocumentSelector);
}
},
normalizeRootSelector: function (rule) {
rule.selector = rule.selector.replace(ROOT, 'html');
var parts = rule.selector.split(COMPLEX_SELECTOR_SEP);
parts = parts.filter(function (part) {
return !part.match(HOST_OR_HOST_GT_STAR);
});
rule.selector = parts.join(COMPLEX_SELECTOR_SEP);
},
_transformDocumentSelector: function (selector) {
return selector.match(SCOPE_JUMP) ? this._transformComplexSelector(selector, SCOPE_DOC_SELECTOR) : this._transformSimpleSelector(selector.trim(), SCOPE_DOC_SELECTOR);
},
_slottedToContent: function (cssText) {
return cssText.replace(SLOTTED_PAREN, CONTENT + '> $1');
},
SCOPE_NAME: 'style-scope'
};
var SCOPE_NAME = api.SCOPE_NAME;
var SCOPE_DOC_SELECTOR = ':not([' + SCOPE_NAME + '])' + ':not(.' + SCOPE_NAME + ')';
var COMPLEX_SELECTOR_SEP = ',';
var SIMPLE_SELECTOR_SEP = /(^|[\s>+~]+)((?:\[.+?\]|[^\s>+~=\[])+)/g;
var SIMPLE_SELECTOR_PREFIX = /[[.:#*]/;
var HOST = ':host';
var ROOT = ':root';
var HOST_PAREN = /(:host)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/;
var HOST_CONTEXT = ':host-context';
var HOST_CONTEXT_PAREN = /(.*)(?::host-context)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))(.*)/;
var CONTENT = '::content';
var SCOPE_JUMP = /::content|::shadow|\/deep\//;
var CSS_CLASS_PREFIX = '.';
var CSS_ATTR_PREFIX = '[' + SCOPE_NAME + '~=';
var CSS_ATTR_SUFFIX = ']';
var PSEUDO_PREFIX = ':';
var CLASS = 'class';
var CONTENT_START = new RegExp('^(' + CONTENT + ')');
var SELECTOR_NO_MATCH = 'should_not_match';
var SLOTTED_PAREN = /(?:::slotted)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/g;
var HOST_OR_HOST_GT_STAR = /:host(?:\s*>\s*\*)?/;
return api;
}();Polymer.StyleExtends = function () {
var styleUtil = Polymer.StyleUtil;
return {
hasExtends: function (cssText) {
return Boolean(cssText.match(this.rx.EXTEND));
},
transform: function (style) {
var rules = styleUtil.rulesForStyle(style);
var self = this;
styleUtil.forEachRule(rules, function (rule) {
self._mapRuleOntoParent(rule);
if (rule.parent) {
var m;
while (m = self.rx.EXTEND.exec(rule.cssText)) {
var extend = m[1];
var extendor = self._findExtendor(extend, rule);
if (extendor) {
self._extendRule(rule, extendor);
}
}
}
rule.cssText = rule.cssText.replace(self.rx.EXTEND, '');
});
return styleUtil.toCssText(rules, function (rule) {
if (rule.selector.match(self.rx.STRIP)) {
rule.cssText = '';
}
}, true);
},
_mapRuleOntoParent: function (rule) {
if (rule.parent) {
var map = rule.parent.map || (rule.parent.map = {});
var parts = rule.selector.split(',');
for (var i = 0, p; i < parts.length; i++) {
p = parts[i];
map[p.trim()] = rule;
}
return map;
}
},
_findExtendor: function (extend, rule) {
return rule.parent && rule.parent.map && rule.parent.map[extend] || this._findExtendor(extend, rule.parent);
},
_extendRule: function (target, source) {
if (target.parent !== source.parent) {
this._cloneAndAddRuleToParent(source, target.parent);
}
target.extends = target.extends || [];
target.extends.push(source);
source.selector = source.selector.replace(this.rx.STRIP, '');
source.selector = (source.selector && source.selector + ',\n') + target.selector;
if (source.extends) {
source.extends.forEach(function (e) {
this._extendRule(target, e);
}, this);
}
},
_cloneAndAddRuleToParent: function (rule, parent) {
rule = Object.create(rule);
rule.parent = parent;
if (rule.extends) {
rule.extends = rule.extends.slice();
}
parent.rules.push(rule);
},
rx: {
EXTEND: /@extends\(([^)]*)\)\s*?;/gim,
STRIP: /%[^,]*$/
}
};
}();Polymer.ApplyShim = function () {
'use strict';
var styleUtil = Polymer.StyleUtil;
var MIXIN_MATCH = styleUtil.rx.MIXIN_MATCH;
var VAR_ASSIGN = styleUtil.rx.VAR_ASSIGN;
var BAD_VAR = /var\(\s*(--[^,]*),\s*(--[^)]*)\)/g;
var APPLY_NAME_CLEAN = /;\s*/m;
var INITIAL_INHERIT = /^\s*(initial)|(inherit)\s*$/;
var MIXIN_VAR_SEP = '_-_';
var mixinMap = {};
function mapSet(name, props) {
name = name.trim();
mixinMap[name] = {
properties: props,
dependants: {}
};
}
function mapGet(name) {
name = name.trim();
return mixinMap[name];
}
function replaceInitialOrInherit(property, value) {
var match = INITIAL_INHERIT.exec(value);
if (match) {
if (match[1]) {
value = ApplyShim._getInitialValueForProperty(property);
} else {
value = 'apply-shim-inherit';
}
}
return value;
}
function cssTextToMap(text) {
var props = text.split(';');
var property, value;
var out = {};
for (var i = 0, p, sp; i < props.length; i++) {
p = props[i];
if (p) {
sp = p.split(':');
if (sp.length > 1) {
property = sp[0].trim();
value = replaceInitialOrInherit(property, sp.slice(1).join(':'));
out[property] = value;
}
}
}
return out;
}
function invalidateMixinEntry(mixinEntry) {
var currentProto = ApplyShim.__currentElementProto;
var currentElementName = currentProto && currentProto.is;
for (var elementName in mixinEntry.dependants) {
if (elementName !== currentElementName) {
mixinEntry.dependants[elementName].__applyShimInvalid = true;
}
}
}
function produceCssProperties(matchText, propertyName, valueProperty, valueMixin) {
if (valueProperty) {
styleUtil.processVariableAndFallback(valueProperty, function (prefix, value) {
if (value && mapGet(value)) {
valueMixin = '@apply ' + value + ';';
}
});
}
if (!valueMixin) {
return matchText;
}
var mixinAsProperties = consumeCssProperties(valueMixin);
var prefix = matchText.slice(0, matchText.indexOf('--'));
var mixinValues = cssTextToMap(mixinAsProperties);
var combinedProps = mixinValues;
var mixinEntry = mapGet(propertyName);
var oldProps = mixinEntry && mixinEntry.properties;
if (oldProps) {
combinedProps = Object.create(oldProps);
combinedProps = Polymer.Base.mixin(combinedProps, mixinValues);
} else {
mapSet(propertyName, combinedProps);
}
var out = [];
var p, v;
var needToInvalidate = false;
for (p in combinedProps) {
v = mixinValues[p];
if (v === undefined) {
v = 'initial';
}
if (oldProps && !(p in oldProps)) {
needToInvalidate = true;
}
out.push(propertyName + MIXIN_VAR_SEP + p + ': ' + v);
}
if (needToInvalidate) {
invalidateMixinEntry(mixinEntry);
}
if (mixinEntry) {
mixinEntry.properties = combinedProps;
}
if (valueProperty) {
prefix = matchText + ';' + prefix;
}
return prefix + out.join('; ') + ';';
}
function fixVars(matchText, varA, varB) {
return 'var(' + varA + ',' + 'var(' + varB + '))';
}
function atApplyToCssProperties(mixinName, fallbacks) {
mixinName = mixinName.replace(APPLY_NAME_CLEAN, '');
var vars = [];
var mixinEntry = mapGet(mixinName);
if (!mixinEntry) {
mapSet(mixinName, {});
mixinEntry = mapGet(mixinName);
}
if (mixinEntry) {
var currentProto = ApplyShim.__currentElementProto;
if (currentProto) {
mixinEntry.dependants[currentProto.is] = currentProto;
}
var p, parts, f;
for (p in mixinEntry.properties) {
f = fallbacks && fallbacks[p];
parts = [
p,
': var(',
mixinName,
MIXIN_VAR_SEP,
p
];
if (f) {
parts.push(',', f);
}
parts.push(')');
vars.push(parts.join(''));
}
}
return vars.join('; ');
}
function consumeCssProperties(text) {
var m;
while (m = MIXIN_MATCH.exec(text)) {
var matchText = m[0];
var mixinName = m[1];
var idx = m.index;
var applyPos = idx + matchText.indexOf('@apply');
var afterApplyPos = idx + matchText.length;
var textBeforeApply = text.slice(0, applyPos);
var textAfterApply = text.slice(afterApplyPos);
var defaults = cssTextToMap(textBeforeApply);
var replacement = atApplyToCssProperties(mixinName, defaults);
text = [
textBeforeApply,
replacement,
textAfterApply
].join('');
MIXIN_MATCH.lastIndex = idx + replacement.length;
}
return text;
}
var ApplyShim = {
_measureElement: null,
_map: mixinMap,
_separator: MIXIN_VAR_SEP,
transform: function (styles, elementProto) {
this.__currentElementProto = elementProto;
styleUtil.forRulesInStyles(styles, this._boundFindDefinitions);
styleUtil.forRulesInStyles(styles, this._boundFindApplications);
if (elementProto) {
elementProto.__applyShimInvalid = false;
}
this.__currentElementProto = null;
},
_findDefinitions: function (rule) {
var cssText = rule.parsedCssText;
cssText = cssText.replace(BAD_VAR, fixVars);
cssText = cssText.replace(VAR_ASSIGN, produceCssProperties);
rule.cssText = cssText;
if (rule.selector === ':root') {
rule.selector = ':host > *';
}
},
_findApplications: function (rule) {
rule.cssText = consumeCssProperties(rule.cssText);
},
transformRule: function (rule) {
this._findDefinitions(rule);
this._findApplications(rule);
},
_getInitialValueForProperty: function (property) {
if (!this._measureElement) {
this._measureElement = document.createElement('meta');
this._measureElement.style.all = 'initial';
document.head.appendChild(this._measureElement);
}
return window.getComputedStyle(this._measureElement).getPropertyValue(property);
}
};
ApplyShim._boundTransformRule = ApplyShim.transformRule.bind(ApplyShim);
ApplyShim._boundFindDefinitions = ApplyShim._findDefinitions.bind(ApplyShim);
ApplyShim._boundFindApplications = ApplyShim._findApplications.bind(ApplyShim);
return ApplyShim;
}();(function () {
var prepElement = Polymer.Base._prepElement;
var nativeShadow = Polymer.Settings.useNativeShadow;
var styleUtil = Polymer.StyleUtil;
var styleTransformer = Polymer.StyleTransformer;
var styleExtends = Polymer.StyleExtends;
var applyShim = Polymer.ApplyShim;
var settings = Polymer.Settings;
Polymer.Base._addFeature({
_prepElement: function (element) {
if (this._encapsulateStyle && this.__cssBuild !== 'shady') {
styleTransformer.element(element, this.is, this._scopeCssViaAttr);
}
prepElement.call(this, element);
},
_prepStyles: function () {
if (this._encapsulateStyle === undefined) {
this._encapsulateStyle = !nativeShadow;
}
if (!nativeShadow) {
this._scopeStyle = styleUtil.applyStylePlaceHolder(this.is);
}
this.__cssBuild = styleUtil.cssBuildTypeForModule(this.is);
},
_prepShimStyles: function () {
if (this._template) {
var hasTargetedCssBuild = styleUtil.isTargetedBuild(this.__cssBuild);
if (settings.useNativeCSSProperties && this.__cssBuild === 'shadow' && hasTargetedCssBuild) {
if (settings.preserveStyleIncludes) {
styleUtil.styleIncludesToTemplate(this._template);
}
return;
}
this._styles = this._styles || this._collectStyles();
if (settings.useNativeCSSProperties && !this.__cssBuild) {
applyShim.transform(this._styles, this);
}
var cssText = settings.useNativeCSSProperties && hasTargetedCssBuild ? this._styles.length && this._styles[0].textContent.trim() : styleTransformer.elementStyles(this);
this._prepStyleProperties();
if (!this._needsStyleProperties() && cssText) {
styleUtil.applyCss(cssText, this.is, nativeShadow ? this._template.content : null, this._scopeStyle);
}
} else {
this._styles = [];
}
},
_collectStyles: function () {
var styles = [];
var cssText = '', m$ = this.styleModules;
if (m$) {
for (var i = 0, l = m$.length, m; i < l && (m = m$[i]); i++) {
cssText += styleUtil.cssFromModule(m);
}
}
cssText += styleUtil.cssFromModule(this.is);
var p = this._template && this._template.parentNode;
if (this._template && (!p || p.id.toLowerCase() !== this.is)) {
cssText += styleUtil.cssFromElement(this._template);
}
if (cssText) {
var style = document.createElement('style');
style.textContent = cssText;
if (styleExtends.hasExtends(style.textContent)) {
cssText = styleExtends.transform(style);
}
styles.push(style);
}
return styles;
},
_elementAdd: function (node) {
if (this._encapsulateStyle) {
if (node.__styleScoped) {
node.__styleScoped = false;
} else {
styleTransformer.dom(node, this.is, this._scopeCssViaAttr);
}
}
},
_elementRemove: function (node) {
if (this._encapsulateStyle) {
styleTransformer.dom(node, this.is, this._scopeCssViaAttr, true);
}
},
scopeSubtree: function (container, shouldObserve) {
if (nativeShadow) {
return;
}
var self = this;
var scopify = function (node) {
if (node.nodeType === Node.ELEMENT_NODE) {
var className = node.getAttribute('class');
node.setAttribute('class', self._scopeElementClass(node, className));
var n$ = node.querySelectorAll('*');
for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
className = n.getAttribute('class');
n.setAttribute('class', self._scopeElementClass(n, className));
}
}
};
scopify(container);
if (shouldObserve) {
var mo = new MutationObserver(function (mxns) {
for (var i = 0, m; i < mxns.length && (m = mxns[i]); i++) {
if (m.addedNodes) {
for (var j = 0; j < m.addedNodes.length; j++) {
scopify(m.addedNodes[j]);
}
}
}
});
mo.observe(container, {
childList: true,
subtree: true
});
return mo;
}
}
});
}());Polymer.StyleProperties = function () {
'use strict';
var matchesSelector = Polymer.DomApi.matchesSelector;
var styleUtil = Polymer.StyleUtil;
var styleTransformer = Polymer.StyleTransformer;
var IS_IE = navigator.userAgent.match('Trident');
var settings = Polymer.Settings;
return {
decorateStyles: function (styles, scope) {
var self = this, props = {}, keyframes = [], ruleIndex = 0;
var scopeSelector = styleTransformer._calcHostScope(scope.is, scope.extends);
styleUtil.forRulesInStyles(styles, function (rule, style) {
self.decorateRule(rule);
rule.index = ruleIndex++;
self.whenHostOrRootRule(scope, rule, style, function (info) {
if (rule.parent.type === styleUtil.ruleTypes.MEDIA_RULE) {
scope.__notStyleScopeCacheable = true;
}
if (info.isHost) {
var hostContextOrFunction = info.selector.split(' ').some(function (s) {
return s.indexOf(scopeSelector) === 0 && s.length !== scopeSelector.length;
});
scope.__notStyleScopeCacheable = scope.__notStyleScopeCacheable || hostContextOrFunction;
}
});
self.collectPropertiesInCssText(rule.propertyInfo.cssText, props);
}, function onKeyframesRule(rule) {
keyframes.push(rule);
});
styles._keyframes = keyframes;
var names = [];
for (var i in props) {
names.push(i);
}
return names;
},
decorateRule: function (rule) {
if (rule.propertyInfo) {
return rule.propertyInfo;
}
var info = {}, properties = {};
var hasProperties = this.collectProperties(rule, properties);
if (hasProperties) {
info.properties = properties;
rule.rules = null;
}
info.cssText = this.collectCssText(rule);
rule.propertyInfo = info;
return info;
},
collectProperties: function (rule, properties) {
var info = rule.propertyInfo;
if (info) {
if (info.properties) {
Polymer.Base.mixin(properties, info.properties);
return true;
}
} else {
var m, rx = this.rx.VAR_ASSIGN;
var cssText = rule.parsedCssText;
var value;
var any;
while (m = rx.exec(cssText)) {
value = (m[2] || m[3]).trim();
if (value !== 'inherit') {
properties[m[1].trim()] = value;
}
any = true;
}
return any;
}
},
collectCssText: function (rule) {
return this.collectConsumingCssText(rule.parsedCssText);
},
collectConsumingCssText: function (cssText) {
return cssText.replace(this.rx.BRACKETED, '').replace(this.rx.VAR_ASSIGN, '');
},
collectPropertiesInCssText: function (cssText, props) {
var m;
while (m = this.rx.VAR_CONSUMED.exec(cssText)) {
var name = m[1];
if (m[2] !== ':') {
props[name] = true;
}
}
},
reify: function (props) {
var names = Object.getOwnPropertyNames(props);
for (var i = 0, n; i < names.length; i++) {
n = names[i];
props[n] = this.valueForProperty(props[n], props);
}
},
valueForProperty: function (property, props) {
if (property) {
if (property.indexOf(';') >= 0) {
property = this.valueForProperties(property, props);
} else {
var self = this;
var fn = function (prefix, value, fallback, suffix) {
var propertyValue = self.valueForProperty(props[value], props);
if (!propertyValue || propertyValue === 'initial') {
propertyValue = self.valueForProperty(props[fallback] || fallback, props) || fallback;
} else if (propertyValue === 'apply-shim-inherit') {
propertyValue = 'inherit';
}
return prefix + (propertyValue || '') + suffix;
};
property = styleUtil.processVariableAndFallback(property, fn);
}
}
return property && property.trim() || '';
},
valueForProperties: function (property, props) {
var parts = property.split(';');
for (var i = 0, p, m; i < parts.length; i++) {
if (p = parts[i]) {
this.rx.MIXIN_MATCH.lastIndex = 0;
m = this.rx.MIXIN_MATCH.exec(p);
if (m) {
p = this.valueForProperty(props[m[1]], props);
} else {
var colon = p.indexOf(':');
if (colon !== -1) {
var pp = p.substring(colon);
pp = pp.trim();
pp = this.valueForProperty(pp, props) || pp;
p = p.substring(0, colon) + pp;
}
}
parts[i] = p && p.lastIndexOf(';') === p.length - 1 ? p.slice(0, -1) : p || '';
}
}
return parts.join(';');
},
applyProperties: function (rule, props) {
var output = '';
if (!rule.propertyInfo) {
this.decorateRule(rule);
}
if (rule.propertyInfo.cssText) {
output = this.valueForProperties(rule.propertyInfo.cssText, props);
}
rule.cssText = output;
},
applyKeyframeTransforms: function (rule, keyframeTransforms) {
var input = rule.cssText;
var output = rule.cssText;
if (rule.hasAnimations == null) {
rule.hasAnimations = this.rx.ANIMATION_MATCH.test(input);
}
if (rule.hasAnimations) {
var transform;
if (rule.keyframeNamesToTransform == null) {
rule.keyframeNamesToTransform = [];
for (var keyframe in keyframeTransforms) {
transform = keyframeTransforms[keyframe];
output = transform(input);
if (input !== output) {
input = output;
rule.keyframeNamesToTransform.push(keyframe);
}
}
} else {
for (var i = 0; i < rule.keyframeNamesToTransform.length; ++i) {
transform = keyframeTransforms[rule.keyframeNamesToTransform[i]];
input = transform(input);
}
output = input;
}
}
rule.cssText = output;
},
propertyDataFromStyles: function (styles, element) {
var props = {}, self = this;
var o = [];
styleUtil.forActiveRulesInStyles(styles, function (rule) {
if (!rule.propertyInfo) {
self.decorateRule(rule);
}
var selectorToMatch = rule.transformedSelector || rule.parsedSelector;
if (element && rule.propertyInfo.properties && selectorToMatch) {
if (matchesSelector.call(element, selectorToMatch)) {
self.collectProperties(rule, props);
addToBitMask(rule.index, o);
}
}
});
return {
properties: props,
key: o
};
},
_rootSelector: /:root|:host\s*>\s*\*/,
_checkRoot: function (hostScope, selector) {
return Boolean(selector.match(this._rootSelector)) || hostScope === 'html' && selector.indexOf('html') > -1;
},
whenHostOrRootRule: function (scope, rule, style, callback) {
if (!rule.propertyInfo) {
self.decorateRule(rule);
}
if (!rule.propertyInfo.properties) {
return;
}
var hostScope = scope.is ? styleTransformer._calcHostScope(scope.is, scope.extends) : 'html';
var parsedSelector = rule.parsedSelector;
var isRoot = this._checkRoot(hostScope, parsedSelector);
var isHost = !isRoot && parsedSelector.indexOf(':host') === 0;
var cssBuild = scope.__cssBuild || style.__cssBuild;
if (cssBuild === 'shady') {
isRoot = parsedSelector === hostScope + ' > *.' + hostScope || parsedSelector.indexOf('html') > -1;
isHost = !isRoot && parsedSelector.indexOf(hostScope) === 0;
}
if (!isRoot && !isHost) {
return;
}
var selectorToMatch = hostScope;
if (isHost) {
if (settings.useNativeShadow && !rule.transformedSelector) {
rule.transformedSelector = styleTransformer._transformRuleCss(rule, styleTransformer._transformComplexSelector, scope.is, hostScope);
}
selectorToMatch = rule.transformedSelector || rule.parsedSelector;
}
if (isRoot && hostScope === 'html') {
selectorToMatch = rule.transformedSelector || rule.parsedSelector;
}
callback({
selector: selectorToMatch,
isHost: isHost,
isRoot: isRoot
});
},
hostAndRootPropertiesForScope: function (scope) {
var hostProps = {}, rootProps = {}, self = this;
styleUtil.forActiveRulesInStyles(scope._styles, function (rule, style) {
self.whenHostOrRootRule(scope, rule, style, function (info) {
var element = scope._element || scope;
if (matchesSelector.call(element, info.selector)) {
if (info.isHost) {
self.collectProperties(rule, hostProps);
} else {
self.collectProperties(rule, rootProps);
}
}
});
});
return {
rootProps: rootProps,
hostProps: hostProps
};
},
transformStyles: function (element, properties, scopeSelector) {
var self = this;
var hostSelector = styleTransformer._calcHostScope(element.is, element.extends);
var rxHostSelector = element.extends ? '\\' + hostSelector.slice(0, -1) + '\\]' : hostSelector;
var hostRx = new RegExp(this.rx.HOST_PREFIX + rxHostSelector + this.rx.HOST_SUFFIX);
var keyframeTransforms = this._elementKeyframeTransforms(element, scopeSelector);
return styleTransformer.elementStyles(element, function (rule) {
self.applyProperties(rule, properties);
if (!settings.useNativeShadow && !Polymer.StyleUtil.isKeyframesSelector(rule) && rule.cssText) {
self.applyKeyframeTransforms(rule, keyframeTransforms);
self._scopeSelector(rule, hostRx, hostSelector, element._scopeCssViaAttr, scopeSelector);
}
});
},
_elementKeyframeTransforms: function (element, scopeSelector) {
var keyframesRules = element._styles._keyframes;
var keyframeTransforms = {};
if (!settings.useNativeShadow && keyframesRules) {
for (var i = 0, keyframesRule = keyframesRules[i]; i < keyframesRules.length; keyframesRule = keyframesRules[++i]) {
this._scopeKeyframes(keyframesRule, scopeSelector);
keyframeTransforms[keyframesRule.keyframesName] = this._keyframesRuleTransformer(keyframesRule);
}
}
return keyframeTransforms;
},
_keyframesRuleTransformer: function (keyframesRule) {
return function (cssText) {
return cssText.replace(keyframesRule.keyframesNameRx, keyframesRule.transformedKeyframesName);
};
},
_scopeKeyframes: function (rule, scopeId) {
rule.keyframesNameRx = new RegExp(rule.keyframesName, 'g');
rule.transformedKeyframesName = rule.keyframesName + '-' + scopeId;
rule.transformedSelector = rule.transformedSelector || rule.selector;
rule.selector = rule.transformedSelector.replace(rule.keyframesName, rule.transformedKeyframesName);
},
_scopeSelector: function (rule, hostRx, hostSelector, viaAttr, scopeId) {
rule.transformedSelector = rule.transformedSelector || rule.selector;
var selector = rule.transformedSelector;
var scope = viaAttr ? '[' + styleTransformer.SCOPE_NAME + '~=' + scopeId + ']' : '.' + scopeId;
var parts = selector.split(',');
for (var i = 0, l = parts.length, p; i < l && (p = parts[i]); i++) {
parts[i] = p.match(hostRx) ? p.replace(hostSelector, scope) : scope + ' ' + p;
}
rule.selector = parts.join(',');
},
applyElementScopeSelector: function (element, selector, old, viaAttr) {
var c = viaAttr ? element.getAttribute(styleTransformer.SCOPE_NAME) : element.getAttribute('class') || '';
var v = old ? c.replace(old, selector) : (c ? c + ' ' : '') + this.XSCOPE_NAME + ' ' + selector;
if (c !== v) {
if (viaAttr) {
element.setAttribute(styleTransformer.SCOPE_NAME, v);
} else {
element.setAttribute('class', v);
}
}
},
applyElementStyle: function (element, properties, selector, style) {
var cssText = style ? style.textContent || '' : this.transformStyles(element, properties, selector);
var s = element._customStyle;
if (s && !settings.useNativeShadow && s !== style) {
s._useCount--;
if (s._useCount <= 0 && s.parentNode) {
s.parentNode.removeChild(s);
}
}
if (settings.useNativeShadow) {
if (element._customStyle) {
element._customStyle.textContent = cssText;
style = element._customStyle;
} else if (cssText) {
style = styleUtil.applyCss(cssText, selector, element.root, element._scopeStyle);
}
} else {
if (!style) {
if (cssText) {
style = styleUtil.applyCss(cssText, selector, null, element._scopeStyle);
}
} else if (!style.parentNode) {
if (IS_IE && cssText.indexOf('@media') > -1) {
style.textContent = cssText;
}
styleUtil.applyStyle(style, null, element._scopeStyle);
}
}
if (style) {
style._useCount = style._useCount || 0;
if (element._customStyle != style) {
style._useCount++;
}
element._customStyle = style;
}
return style;
},
mixinCustomStyle: function (props, customStyle) {
var v;
for (var i in customStyle) {
v = customStyle[i];
if (v || v === 0) {
props[i] = v;
}
}
},
updateNativeStyleProperties: function (element, properties) {
var oldPropertyNames = element.__customStyleProperties;
if (oldPropertyNames) {
for (var i = 0; i < oldPropertyNames.length; i++) {
element.style.removeProperty(oldPropertyNames[i]);
}
}
var propertyNames = [];
for (var p in properties) {
if (properties[p] !== null) {
element.style.setProperty(p, properties[p]);
propertyNames.push(p);
}
}
element.__customStyleProperties = propertyNames;
},
rx: styleUtil.rx,
XSCOPE_NAME: 'x-scope'
};
function addToBitMask(n, bits) {
var o = parseInt(n / 32);
var v = 1 << n % 32;
bits[o] = (bits[o] || 0) | v;
}
}();(function () {
Polymer.StyleCache = function () {
this.cache = {};
};
Polymer.StyleCache.prototype = {
MAX: 100,
store: function (is, data, keyValues, keyStyles) {
data.keyValues = keyValues;
data.styles = keyStyles;
var s$ = this.cache[is] = this.cache[is] || [];
s$.push(data);
if (s$.length > this.MAX) {
s$.shift();
}
},
retrieve: function (is, keyValues, keyStyles) {
var cache = this.cache[is];
if (cache) {
for (var i = cache.length - 1, data; i >= 0; i--) {
data = cache[i];
if (keyStyles === data.styles && this._objectsEqual(keyValues, data.keyValues)) {
return data;
}
}
}
},
clear: function () {
this.cache = {};
},
_objectsEqual: function (target, source) {
var t, s;
for (var i in target) {
t = target[i], s = source[i];
if (!(typeof t === 'object' && t ? this._objectsStrictlyEqual(t, s) : t === s)) {
return false;
}
}
if (Array.isArray(target)) {
return target.length === source.length;
}
return true;
},
_objectsStrictlyEqual: function (target, source) {
return this._objectsEqual(target, source) && this._objectsEqual(source, target);
}
};
}());Polymer.StyleDefaults = function () {
var styleProperties = Polymer.StyleProperties;
var StyleCache = Polymer.StyleCache;
var nativeVariables = Polymer.Settings.useNativeCSSProperties;
var api = {
_styles: [],
_properties: null,
customStyle: {},
_styleCache: new StyleCache(),
_element: Polymer.DomApi.wrap(document.documentElement),
addStyle: function (style) {
this._styles.push(style);
this._properties = null;
},
get _styleProperties() {
if (!this._properties) {
styleProperties.decorateStyles(this._styles, this);
this._styles._scopeStyleProperties = null;
this._properties = styleProperties.hostAndRootPropertiesForScope(this).rootProps;
styleProperties.mixinCustomStyle(this._properties, this.customStyle);
styleProperties.reify(this._properties);
}
return this._properties;
},
hasStyleProperties: function () {
return Boolean(this._properties);
},
_needsStyleProperties: function () {
},
_computeStyleProperties: function () {
return this._styleProperties;
},
updateStyles: function (properties) {
this._properties = null;
if (properties) {
Polymer.Base.mixin(this.customStyle, properties);
}
this._styleCache.clear();
for (var i = 0, s; i < this._styles.length; i++) {
s = this._styles[i];
s = s.__importElement || s;
s._apply();
}
if (nativeVariables) {
styleProperties.updateNativeStyleProperties(document.documentElement, this.customStyle);
}
}
};
return api;
}();(function () {
'use strict';
var serializeValueToAttribute = Polymer.Base.serializeValueToAttribute;
var propertyUtils = Polymer.StyleProperties;
var styleTransformer = Polymer.StyleTransformer;
var styleDefaults = Polymer.StyleDefaults;
var nativeShadow = Polymer.Settings.useNativeShadow;
var nativeVariables = Polymer.Settings.useNativeCSSProperties;
Polymer.Base._addFeature({
_prepStyleProperties: function () {
if (!nativeVariables) {
this._ownStylePropertyNames = this._styles && this._styles.length ? propertyUtils.decorateStyles(this._styles, this) : null;
}
},
customStyle: null,
getComputedStyleValue: function (property) {
if (!nativeVariables && !this._styleProperties) {
this._computeStyleProperties();
}
return !nativeVariables && this._styleProperties && this._styleProperties[property] || getComputedStyle(this).getPropertyValue(property);
},
_setupStyleProperties: function () {
this.customStyle = {};
this._styleCache = null;
this._styleProperties = null;
this._scopeSelector = null;
this._ownStyleProperties = null;
this._customStyle = null;
},
_needsStyleProperties: function () {
return Boolean(!nativeVariables && this._ownStylePropertyNames && this._ownStylePropertyNames.length);
},
_validateApplyShim: function () {
if (this.__applyShimInvalid) {
Polymer.ApplyShim.transform(this._styles, this.__proto__);
var cssText = styleTransformer.elementStyles(this);
if (nativeShadow) {
var templateStyle = this._template.content.querySelector('style');
if (templateStyle) {
templateStyle.textContent = cssText;
}
} else {
var shadyStyle = this._scopeStyle && this._scopeStyle.nextSibling;
if (shadyStyle) {
shadyStyle.textContent = cssText;
}
}
}
},
_beforeAttached: function () {
if ((!this._scopeSelector || this.__stylePropertiesInvalid) && this._needsStyleProperties()) {
this.__stylePropertiesInvalid = false;
this._updateStyleProperties();
}
},
_findStyleHost: function () {
var e = this, root;
while (root = Polymer.dom(e).getOwnerRoot()) {
if (Polymer.isInstance(root.host)) {
return root.host;
}
e = root.host;
}
return styleDefaults;
},
_updateStyleProperties: function () {
var info, scope = this._findStyleHost();
if (!scope._styleProperties) {
scope._computeStyleProperties();
}
if (!scope._styleCache) {
scope._styleCache = new Polymer.StyleCache();
}
var scopeData = propertyUtils.propertyDataFromStyles(scope._styles, this);
var scopeCacheable = !this.__notStyleScopeCacheable;
if (scopeCacheable) {
scopeData.key.customStyle = this.customStyle;
info = scope._styleCache.retrieve(this.is, scopeData.key, this._styles);
}
var scopeCached = Boolean(info);
if (scopeCached) {
this._styleProperties = info._styleProperties;
} else {
this._computeStyleProperties(scopeData.properties);
}
this._computeOwnStyleProperties();
if (!scopeCached) {
info = styleCache.retrieve(this.is, this._ownStyleProperties, this._styles);
}
var globalCached = Boolean(info) && !scopeCached;
var style = this._applyStyleProperties(info);
if (!scopeCached) {
style = style && nativeShadow ? style.cloneNode(true) : style;
info = {
style: style,
_scopeSelector: this._scopeSelector,
_styleProperties: this._styleProperties
};
if (scopeCacheable) {
scopeData.key.customStyle = {};
this.mixin(scopeData.key.customStyle, this.customStyle);
scope._styleCache.store(this.is, info, scopeData.key, this._styles);
}
if (!globalCached) {
styleCache.store(this.is, Object.create(info), this._ownStyleProperties, this._styles);
}
}
},
_computeStyleProperties: function (scopeProps) {
var scope = this._findStyleHost();
if (!scope._styleProperties) {
scope._computeStyleProperties();
}
var props = Object.create(scope._styleProperties);
var hostAndRootProps = propertyUtils.hostAndRootPropertiesForScope(this);
this.mixin(props, hostAndRootProps.hostProps);
scopeProps = scopeProps || propertyUtils.propertyDataFromStyles(scope._styles, this).properties;
this.mixin(props, scopeProps);
this.mixin(props, hostAndRootProps.rootProps);
propertyUtils.mixinCustomStyle(props, this.customStyle);
propertyUtils.reify(props);
this._styleProperties = props;
},
_computeOwnStyleProperties: function () {
var props = {};
for (var i = 0, n; i < this._ownStylePropertyNames.length; i++) {
n = this._ownStylePropertyNames[i];
props[n] = this._styleProperties[n];
}
this._ownStyleProperties = props;
},
_scopeCount: 0,
_applyStyleProperties: function (info) {
var oldScopeSelector = this._scopeSelector;
this._scopeSelector = info ? info._scopeSelector : this.is + '-' + this.__proto__._scopeCount++;
var style = propertyUtils.applyElementStyle(this, this._styleProperties, this._scopeSelector, info && info.style);
if (!nativeShadow) {
propertyUtils.applyElementScopeSelector(this, this._scopeSelector, oldScopeSelector, this._scopeCssViaAttr);
}
return style;
},
serializeValueToAttribute: function (value, attribute, node) {
node = node || this;
if (attribute === 'class' && !nativeShadow) {
var host = node === this ? this.domHost || this.dataHost : this;
if (host) {
value = host._scopeElementClass(node, value);
}
}
node = this.shadyRoot && this.shadyRoot._hasDistributed ? Polymer.dom(node) : node;
serializeValueToAttribute.call(this, value, attribute, node);
},
_scopeElementClass: function (element, selector) {
if (!nativeShadow && !this._scopeCssViaAttr) {
selector = (selector ? selector + ' ' : '') + SCOPE_NAME + ' ' + this.is + (element._scopeSelector ? ' ' + XSCOPE_NAME + ' ' + element._scopeSelector : '');
}
return selector;
},
updateStyles: function (properties) {
if (properties) {
this.mixin(this.customStyle, properties);
}
if (nativeVariables) {
propertyUtils.updateNativeStyleProperties(this, this.customStyle);
} else {
if (this.isAttached) {
if (this._needsStyleProperties()) {
this._updateStyleProperties();
} else {
this._styleProperties = null;
}
} else {
this.__stylePropertiesInvalid = true;
}
if (this._styleCache) {
this._styleCache.clear();
}
this._updateRootStyles();
}
},
_updateRootStyles: function (root) {
root = root || this.root;
var c$ = Polymer.dom(root)._query(function (e) {
return e.shadyRoot || e.shadowRoot;
});
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
if (c.updateStyles) {
c.updateStyles();
}
}
}
});
Polymer.updateStyles = function (properties) {
styleDefaults.updateStyles(properties);
Polymer.Base._updateRootStyles(document);
};
var styleCache = new Polymer.StyleCache();
Polymer.customStyleCache = styleCache;
var SCOPE_NAME = styleTransformer.SCOPE_NAME;
var XSCOPE_NAME = propertyUtils.XSCOPE_NAME;
}());Polymer.Base._addFeature({
_registerFeatures: function () {
this._prepIs();
if (this.factoryImpl) {
this._prepConstructor();
}
this._prepStyles();
},
_finishRegisterFeatures: function () {
this._prepTemplate();
this._prepShimStyles();
this._prepAnnotations();
this._prepEffects();
this._prepBehaviors();
this._prepPropertyInfo();
this._prepBindings();
this._prepShady();
},
_prepBehavior: function (b) {
this._addPropertyEffects(b.properties);
this._addComplexObserverEffects(b.observers);
this._addHostAttributes(b.hostAttributes);
},
_initFeatures: function () {
this._setupGestures();
this._setupConfigure(this.__data__);
this._setupStyleProperties();
this._setupDebouncers();
this._setupShady();
this._registerHost();
if (this._template) {
this._validateApplyShim();
this._poolContent();
this._beginHosting();
this._stampTemplate();
this._endHosting();
this._marshalAnnotationReferences();
}
this._marshalInstanceEffects();
this._marshalBehaviors();
this._marshalHostAttributes();
this._marshalAttributes();
this._tryReady();
},
_marshalBehavior: function (b) {
if (b.listeners) {
this._listenListeners(b.listeners);
}
}
});(function () {
var propertyUtils = Polymer.StyleProperties;
var styleUtil = Polymer.StyleUtil;
var cssParse = Polymer.CssParse;
var styleDefaults = Polymer.StyleDefaults;
var styleTransformer = Polymer.StyleTransformer;
var applyShim = Polymer.ApplyShim;
var debounce = Polymer.Debounce;
var settings = Polymer.Settings;
var updateDebouncer;
Polymer({
is: 'custom-style',
extends: 'style',
_template: null,
properties: { include: String },
ready: function () {
this.__appliedElement = this.__appliedElement || this;
this.__cssBuild = styleUtil.getCssBuildType(this);
if (this.__appliedElement !== this) {
this.__appliedElement.__cssBuild = this.__cssBuild;
}
this._tryApply();
},
attached: function () {
this._tryApply();
},
_tryApply: function () {
if (!this._appliesToDocument) {
if (this.parentNode && this.parentNode.localName !== 'dom-module') {
this._appliesToDocument = true;
var e = this.__appliedElement;
if (!settings.useNativeCSSProperties) {
this.__needsUpdateStyles = styleDefaults.hasStyleProperties();
styleDefaults.addStyle(e);
}
if (e.textContent || this.include) {
this._apply(true);
} else {
var self = this;
var observer = new MutationObserver(function () {
observer.disconnect();
self._apply(true);
});
observer.observe(e, { childList: true });
}
}
}
},
_updateStyles: function () {
Polymer.updateStyles();
},
_apply: function (initialApply) {
var e = this.__appliedElement;
if (this.include) {
e.textContent = styleUtil.cssFromModules(this.include, true) + e.textContent;
}
if (!e.textContent) {
return;
}
var buildType = this.__cssBuild;
var targetedBuild = styleUtil.isTargetedBuild(buildType);
if (settings.useNativeCSSProperties && targetedBuild) {
return;
}
var styleRules = styleUtil.rulesForStyle(e);
if (!targetedBuild) {
styleUtil.forEachRule(styleRules, function (rule) {
styleTransformer.documentRule(rule);
});
if (settings.useNativeCSSProperties && !buildType) {
applyShim.transform([e]);
}
}
if (settings.useNativeCSSProperties) {
e.textContent = styleUtil.toCssText(styleRules);
} else {
var self = this;
var fn = function fn() {
self._flushCustomProperties();
};
if (initialApply) {
Polymer.RenderStatus.whenReady(fn);
} else {
fn();
}
}
},
_flushCustomProperties: function () {
if (this.__needsUpdateStyles) {
this.__needsUpdateStyles = false;
updateDebouncer = debounce(updateDebouncer, this._updateStyles);
} else {
this._applyCustomProperties();
}
},
_applyCustomProperties: function () {
var element = this.__appliedElement;
this._computeStyleProperties();
var props = this._styleProperties;
var rules = styleUtil.rulesForStyle(element);
if (!rules) {
return;
}
element.textContent = styleUtil.toCssText(rules, function (rule) {
var css = rule.cssText = rule.parsedCssText;
if (rule.propertyInfo && rule.propertyInfo.cssText) {
css = cssParse.removeCustomPropAssignment(css);
rule.cssText = propertyUtils.valueForProperties(css, props);
}
});
}
});
}());Polymer.Templatizer = {
properties: { __hideTemplateChildren__: { observer: '_showHideChildren' } },
_instanceProps: Polymer.nob,
_parentPropPrefix: '_parent_',
templatize: function (template) {
this._templatized = template;
if (!template._content) {
template._content = template.content;
}
if (template._content._ctor) {
this.ctor = template._content._ctor;
this._prepParentProperties(this.ctor.prototype, template);
return;
}
var archetype = Object.create(Polymer.Base);
this._customPrepAnnotations(archetype, template);
this._prepParentProperties(archetype, template);
archetype._prepEffects();
this._customPrepEffects(archetype);
archetype._prepBehaviors();
archetype._prepPropertyInfo();
archetype._prepBindings();
archetype._notifyPathUp = this._notifyPathUpImpl;
archetype._scopeElementClass = this._scopeElementClassImpl;
archetype.listen = this._listenImpl;
archetype._showHideChildren = this._showHideChildrenImpl;
archetype.__setPropertyOrig = this.__setProperty;
archetype.__setProperty = this.__setPropertyImpl;
var _constructor = this._constructorImpl;
var ctor = function TemplateInstance(model, host) {
_constructor.call(this, model, host);
};
ctor.prototype = archetype;
archetype.constructor = ctor;
template._content._ctor = ctor;
this.ctor = ctor;
},
_getRootDataHost: function () {
return this.dataHost && this.dataHost._rootDataHost || this.dataHost;
},
_showHideChildrenImpl: function (hide) {
var c = this._children;
for (var i = 0; i < c.length; i++) {
var n = c[i];
if (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {
if (n.nodeType === Node.TEXT_NODE) {
if (hide) {
n.__polymerTextContent__ = n.textContent;
n.textContent = '';
} else {
n.textContent = n.__polymerTextContent__;
}
} else if (n.style) {
if (hide) {
n.__polymerDisplay__ = n.style.display;
n.style.display = 'none';
} else {
n.style.display = n.__polymerDisplay__;
}
}
}
n.__hideTemplateChildren__ = hide;
}
},
__setPropertyImpl: function (property, value, fromAbove, node) {
if (node && node.__hideTemplateChildren__ && property == 'textContent') {
property = '__polymerTextContent__';
}
this.__setPropertyOrig(property, value, fromAbove, node);
},
_debounceTemplate: function (fn) {
Polymer.dom.addDebouncer(this.debounce('_debounceTemplate', fn));
},
_flushTemplates: function () {
Polymer.dom.flush();
},
_customPrepEffects: function (archetype) {
var parentProps = archetype._parentProps;
for (var prop in parentProps) {
archetype._addPropertyEffect(prop, 'function', this._createHostPropEffector(prop));
}
for (prop in this._instanceProps) {
archetype._addPropertyEffect(prop, 'function', this._createInstancePropEffector(prop));
}
},
_customPrepAnnotations: function (archetype, template) {
archetype._template = template;
var c = template._content;
if (!c._notes) {
var rootDataHost = archetype._rootDataHost;
if (rootDataHost) {
Polymer.Annotations.prepElement = function () {
rootDataHost._prepElement();
};
}
c._notes = Polymer.Annotations.parseAnnotations(template);
Polymer.Annotations.prepElement = null;
this._processAnnotations(c._notes);
}
archetype._notes = c._notes;
archetype._parentProps = c._parentProps;
},
_prepParentProperties: function (archetype, template) {
var parentProps = this._parentProps = archetype._parentProps;
if (this._forwardParentProp && parentProps) {
var proto = archetype._parentPropProto;
var prop;
if (!proto) {
for (prop in this._instanceProps) {
delete parentProps[prop];
}
proto = archetype._parentPropProto = Object.create(null);
if (template != this) {
Polymer.Bind.prepareModel(proto);
Polymer.Base.prepareModelNotifyPath(proto);
}
for (prop in parentProps) {
var parentProp = this._parentPropPrefix + prop;
var effects = [
{
kind: 'function',
effect: this._createForwardPropEffector(prop),
fn: Polymer.Bind._functionEffect
},
{
kind: 'notify',
fn: Polymer.Bind._notifyEffect,
effect: { event: Polymer.CaseMap.camelToDashCase(parentProp) + '-changed' }
}
];
proto._propertyEffects = proto._propertyEffects || {};
proto._propertyEffects[parentProp] = effects;
Polymer.Bind._createAccessors(proto, parentProp, effects);
}
}
var self = this;
if (template != this) {
Polymer.Bind.prepareInstance(template);
template._forwardParentProp = function (source, value) {
self._forwardParentProp(source, value);
};
}
this._extendTemplate(template, proto);
template._pathEffector = function (path, value, fromAbove) {
return self._pathEffectorImpl(path, value, fromAbove);
};
}
},
_createForwardPropEffector: function (prop) {
return function (source, value) {
this._forwardParentProp(prop, value);
};
},
_createHostPropEffector: function (prop) {
var prefix = this._parentPropPrefix;
return function (source, value) {
this.dataHost._templatized[prefix + prop] = value;
};
},
_createInstancePropEffector: function (prop) {
return function (source, value, old, fromAbove) {
if (!fromAbove) {
this.dataHost._forwardInstanceProp(this, prop, value);
}
};
},
_extendTemplate: function (template, proto) {
var n$ = Object.getOwnPropertyNames(proto);
if (proto._propertySetter) {
template._propertySetter = proto._propertySetter;
}
for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
var val = template[n];
if (val && n == '_propertyEffects') {
var pe = Polymer.Base.mixin({}, val);
template._propertyEffects = Polymer.Base.mixin(pe, proto._propertyEffects);
} else {
var pd = Object.getOwnPropertyDescriptor(proto, n);
Object.defineProperty(template, n, pd);
if (val !== undefined) {
template._propertySetter(n, val);
}
}
}
},
_showHideChildren: function (hidden) {
},
_forwardInstancePath: function (inst, path, value) {
},
_forwardInstanceProp: function (inst, prop, value) {
},
_notifyPathUpImpl: function (path, value) {
var dataHost = this.dataHost;
var root = Polymer.Path.root(path);
dataHost._forwardInstancePath.call(dataHost, this, path, value);
if (root in dataHost._parentProps) {
dataHost._templatized._notifyPath(dataHost._parentPropPrefix + path, value);
}
},
_pathEffectorImpl: function (path, value, fromAbove) {
if (this._forwardParentPath) {
if (path.indexOf(this._parentPropPrefix) === 0) {
var subPath = path.substring(this._parentPropPrefix.length);
var model = Polymer.Path.root(subPath);
if (model in this._parentProps) {
this._forwardParentPath(subPath, value);
}
}
}
Polymer.Base._pathEffector.call(this._templatized, path, value, fromAbove);
},
_constructorImpl: function (model, host) {
this._rootDataHost = host._getRootDataHost();
this._setupConfigure(model);
this._registerHost(host);
this._beginHosting();
this.root = this.instanceTemplate(this._template);
this.root.__noContent = !this._notes._hasContent;
this.root.__styleScoped = true;
this._endHosting();
this._marshalAnnotatedNodes();
this._marshalInstanceEffects();
this._marshalAnnotatedListeners();
var children = [];
for (var n = this.root.firstChild; n; n = n.nextSibling) {
children.push(n);
n._templateInstance = this;
}
this._children = children;
if (host.__hideTemplateChildren__) {
this._showHideChildren(true);
}
this._tryReady();
},
_listenImpl: function (node, eventName, methodName) {
var model = this;
var host = this._rootDataHost;
var handler = host._createEventHandler(node, eventName, methodName);
var decorated = function (e) {
e.model = model;
handler(e);
};
host._listen(node, eventName, decorated);
},
_scopeElementClassImpl: function (node, value) {
var host = this._rootDataHost;
if (host) {
return host._scopeElementClass(node, value);
}
return value;
},
stamp: function (model) {
model = model || {};
if (this._parentProps) {
var templatized = this._templatized;
for (var prop in this._parentProps) {
if (model[prop] === undefined) {
model[prop] = templatized[this._parentPropPrefix + prop];
}
}
}
return new this.ctor(model, this);
},
modelForElement: function (el) {
var model;
while (el) {
if (model = el._templateInstance) {
if (model.dataHost != this) {
el = model.dataHost;
} else {
return model;
}
} else {
el = el.parentNode;
}
}
}
};Polymer({
is: 'dom-template',
extends: 'template',
_template: null,
behaviors: [Polymer.Templatizer],
ready: function () {
this.templatize(this);
}
});Polymer._collections = new WeakMap();
Polymer.Collection = function (userArray) {
Polymer._collections.set(userArray, this);
this.userArray = userArray;
this.store = userArray.slice();
this.initMap();
};
Polymer.Collection.prototype = {
constructor: Polymer.Collection,
initMap: function () {
var omap = this.omap = new WeakMap();
var pmap = this.pmap = {};
var s = this.store;
for (var i = 0; i < s.length; i++) {
var item = s[i];
if (item && typeof item == 'object') {
omap.set(item, i);
} else {
pmap[item] = i;
}
}
},
add: function (item) {
var key = this.store.push(item) - 1;
if (item && typeof item == 'object') {
this.omap.set(item, key);
} else {
this.pmap[item] = key;
}
return '#' + key;
},
removeKey: function (key) {
if (key = this._parseKey(key)) {
this._removeFromMap(this.store[key]);
delete this.store[key];
}
},
_removeFromMap: function (item) {
if (item && typeof item == 'object') {
this.omap.delete(item);
} else {
delete this.pmap[item];
}
},
remove: function (item) {
var key = this.getKey(item);
this.removeKey(key);
return key;
},
getKey: function (item) {
var key;
if (item && typeof item == 'object') {
key = this.omap.get(item);
} else {
key = this.pmap[item];
}
if (key != undefined) {
return '#' + key;
}
},
getKeys: function () {
return Object.keys(this.store).map(function (key) {
return '#' + key;
});
},
_parseKey: function (key) {
if (key && key[0] == '#') {
return key.slice(1);
}
},
setItem: function (key, item) {
if (key = this._parseKey(key)) {
var old = this.store[key];
if (old) {
this._removeFromMap(old);
}
if (item && typeof item == 'object') {
this.omap.set(item, key);
} else {
this.pmap[item] = key;
}
this.store[key] = item;
}
},
getItem: function (key) {
if (key = this._parseKey(key)) {
return this.store[key];
}
},
getItems: function () {
var items = [], store = this.store;
for (var key in store) {
items.push(store[key]);
}
return items;
},
_applySplices: function (splices) {
var keyMap = {}, key;
for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
s.addedKeys = [];
for (var j = 0; j < s.removed.length; j++) {
key = this.getKey(s.removed[j]);
keyMap[key] = keyMap[key] ? null : -1;
}
for (j = 0; j < s.addedCount; j++) {
var item = this.userArray[s.index + j];
key = this.getKey(item);
key = key === undefined ? this.add(item) : key;
keyMap[key] = keyMap[key] ? null : 1;
s.addedKeys.push(key);
}
}
var removed = [];
var added = [];
for (key in keyMap) {
if (keyMap[key] < 0) {
this.removeKey(key);
removed.push(key);
}
if (keyMap[key] > 0) {
added.push(key);
}
}
return [{
removed: removed,
added: added
}];
}
};
Polymer.Collection.get = function (userArray) {
return Polymer._collections.get(userArray) || new Polymer.Collection(userArray);
};
Polymer.Collection.applySplices = function (userArray, splices) {
var coll = Polymer._collections.get(userArray);
return coll ? coll._applySplices(splices) : null;
};Polymer({
is: 'dom-repeat',
extends: 'template',
_template: null,
properties: {
items: { type: Array },
as: {
type: String,
value: 'item'
},
indexAs: {
type: String,
value: 'index'
},
sort: {
type: Function,
observer: '_sortChanged'
},
filter: {
type: Function,
observer: '_filterChanged'
},
observe: {
type: String,
observer: '_observeChanged'
},
delay: Number,
renderedItemCount: {
type: Number,
notify: !Polymer.Settings.suppressTemplateNotifications,
readOnly: true
},
initialCount: {
type: Number,
observer: '_initializeChunking'
},
targetFramerate: {
type: Number,
value: 20
},
notifyDomChange: { type: Boolean },
_targetFrameTime: {
type: Number,
computed: '_computeFrameTime(targetFramerate)'
}
},
behaviors: [Polymer.Templatizer],
observers: ['_itemsChanged(items.*)'],
created: function () {
this._instances = [];
this._pool = [];
this._limit = Infinity;
var self = this;
this._boundRenderChunk = function () {
self._renderChunk();
};
},
detached: function () {
this.__isDetached = true;
for (var i = 0; i < this._instances.length; i++) {
this._detachInstance(i);
}
},
attached: function () {
if (this.__isDetached) {
this.__isDetached = false;
var refNode;
var parentNode = Polymer.dom(this).parentNode;
if (parentNode.localName == this.is) {
refNode = parentNode;
parentNode = Polymer.dom(parentNode).parentNode;
} else {
refNode = this;
}
var parent = Polymer.dom(parentNode);
for (var i = 0; i < this._instances.length; i++) {
this._attachInstance(i, parent, refNode);
}
}
},
ready: function () {
this._instanceProps = { __key__: true };
this._instanceProps[this.as] = true;
this._instanceProps[this.indexAs] = true;
if (!this.ctor) {
this.templatize(this);
}
},
_sortChanged: function (sort) {
var dataHost = this._getRootDataHost();
this._sortFn = sort && (typeof sort == 'function' ? sort : function () {
return dataHost[sort].apply(dataHost, arguments);
});
this._needFullRefresh = true;
if (this.items) {
this._debounceTemplate(this._render);
}
},
_filterChanged: function (filter) {
var dataHost = this._getRootDataHost();
this._filterFn = filter && (typeof filter == 'function' ? filter : function () {
return dataHost[filter].apply(dataHost, arguments);
});
this._needFullRefresh = true;
if (this.items) {
this._debounceTemplate(this._render);
}
},
_computeFrameTime: function (rate) {
return Math.ceil(1000 / rate);
},
_initializeChunking: function () {
if (this.initialCount) {
this._limit = this.initialCount;
this._chunkCount = this.initialCount;
this._lastChunkTime = performance.now();
}
},
_tryRenderChunk: function () {
if (this.items && this._limit < this.items.length) {
this.debounce('renderChunk', this._requestRenderChunk);
}
},
_requestRenderChunk: function () {
requestAnimationFrame(this._boundRenderChunk);
},
_renderChunk: function () {
var currChunkTime = performance.now();
var ratio = this._targetFrameTime / (currChunkTime - this._lastChunkTime);
this._chunkCount = Math.round(this._chunkCount * ratio) || 1;
this._limit += this._chunkCount;
this._lastChunkTime = currChunkTime;
this._debounceTemplate(this._render);
},
_observeChanged: function () {
this._observePaths = this.observe && this.observe.replace('.*', '.').split(' ');
},
_itemsChanged: function (change) {
if (change.path == 'items') {
if (Array.isArray(this.items)) {
this.collection = Polymer.Collection.get(this.items);
} else if (!this.items) {
this.collection = null;
} else {
this._error(this._logf('dom-repeat', 'expected array for `items`,' + ' found', this.items));
}
this._keySplices = [];
this._indexSplices = [];
this._needFullRefresh = true;
this._initializeChunking();
this._debounceTemplate(this._render);
} else if (change.path == 'items.splices') {
this._keySplices = this._keySplices.concat(change.value.keySplices);
this._indexSplices = this._indexSplices.concat(change.value.indexSplices);
this._debounceTemplate(this._render);
} else {
var subpath = change.path.slice(6);
this._forwardItemPath(subpath, change.value);
this._checkObservedPaths(subpath);
}
},
_checkObservedPaths: function (path) {
if (this._observePaths) {
path = path.substring(path.indexOf('.') + 1);
var paths = this._observePaths;
for (var i = 0; i < paths.length; i++) {
if (path.indexOf(paths[i]) === 0) {
this._needFullRefresh = true;
if (this.delay) {
this.debounce('render', this._render, this.delay);
} else {
this._debounceTemplate(this._render);
}
return;
}
}
}
},
render: function () {
this._needFullRefresh = true;
this._debounceTemplate(this._render);
this._flushTemplates();
},
_render: function () {
if (this._needFullRefresh) {
this._applyFullRefresh();
this._needFullRefresh = false;
} else if (this._keySplices.length) {
if (this._sortFn) {
this._applySplicesUserSort(this._keySplices);
} else {
if (this._filterFn) {
this._applyFullRefresh();
} else {
this._applySplicesArrayOrder(this._indexSplices);
}
}
} else {
}
this._keySplices = [];
this._indexSplices = [];
var keyToIdx = this._keyToInstIdx = {};
for (var i = this._instances.length - 1; i >= 0; i--) {
var inst = this._instances[i];
if (inst.isPlaceholder && i < this._limit) {
inst = this._insertInstance(i, inst.__key__);
} else if (!inst.isPlaceholder && i >= this._limit) {
inst = this._downgradeInstance(i, inst.__key__);
}
keyToIdx[inst.__key__] = i;
if (!inst.isPlaceholder) {
inst.__setProperty(this.indexAs, i, true);
}
}
this._pool.length = 0;
this._setRenderedItemCount(this._instances.length);
if (!Polymer.Settings.suppressTemplateNotifications || this.notifyDomChange) {
this.fire('dom-change');
}
this._tryRenderChunk();
},
_applyFullRefresh: function () {
var c = this.collection;
var keys;
if (this._sortFn) {
keys = c ? c.getKeys() : [];
} else {
keys = [];
var items = this.items;
if (items) {
for (var i = 0; i < items.length; i++) {
keys.push(c.getKey(items[i]));
}
}
}
var self = this;
if (this._filterFn) {
keys = keys.filter(function (a) {
return self._filterFn(c.getItem(a));
});
}
if (this._sortFn) {
keys.sort(function (a, b) {
return self._sortFn(c.getItem(a), c.getItem(b));
});
}
for (i = 0; i < keys.length; i++) {
var key = keys[i];
var inst = this._instances[i];
if (inst) {
inst.__key__ = key;
if (!inst.isPlaceholder && i < this._limit) {
inst.__setProperty(this.as, c.getItem(key), true);
}
} else if (i < this._limit) {
this._insertInstance(i, key);
} else {
this._insertPlaceholder(i, key);
}
}
for (var j = this._instances.length - 1; j >= i; j--) {
this._detachAndRemoveInstance(j);
}
},
_numericSort: function (a, b) {
return a - b;
},
_applySplicesUserSort: function (splices) {
var c = this.collection;
var keyMap = {};
var key;
for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
for (var j = 0; j < s.removed.length; j++) {
key = s.removed[j];
keyMap[key] = keyMap[key] ? null : -1;
}
for (j = 0; j < s.added.length; j++) {
key = s.added[j];
keyMap[key] = keyMap[key] ? null : 1;
}
}
var removedIdxs = [];
var addedKeys = [];
for (key in keyMap) {
if (keyMap[key] === -1) {
removedIdxs.push(this._keyToInstIdx[key]);
}
if (keyMap[key] === 1) {
addedKeys.push(key);
}
}
if (removedIdxs.length) {
removedIdxs.sort(this._numericSort);
for (i = removedIdxs.length - 1; i >= 0; i--) {
var idx = removedIdxs[i];
if (idx !== undefined) {
this._detachAndRemoveInstance(idx);
}
}
}
var self = this;
if (addedKeys.length) {
if (this._filterFn) {
addedKeys = addedKeys.filter(function (a) {
return self._filterFn(c.getItem(a));
});
}
addedKeys.sort(function (a, b) {
return self._sortFn(c.getItem(a), c.getItem(b));
});
var start = 0;
for (i = 0; i < addedKeys.length; i++) {
start = this._insertRowUserSort(start, addedKeys[i]);
}
}
},
_insertRowUserSort: function (start, key) {
var c = this.collection;
var item = c.getItem(key);
var end = this._instances.length - 1;
var idx = -1;
while (start <= end) {
var mid = start + end >> 1;
var midKey = this._instances[mid].__key__;
var cmp = this._sortFn(c.getItem(midKey), item);
if (cmp < 0) {
start = mid + 1;
} else if (cmp > 0) {
end = mid - 1;
} else {
idx = mid;
break;
}
}
if (idx < 0) {
idx = end + 1;
}
this._insertPlaceholder(idx, key);
return idx;
},
_applySplicesArrayOrder: function (splices) {
for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
for (var j = 0; j < s.removed.length; j++) {
this._detachAndRemoveInstance(s.index);
}
for (j = 0; j < s.addedKeys.length; j++) {
this._insertPlaceholder(s.index + j, s.addedKeys[j]);
}
}
},
_detachInstance: function (idx) {
var inst = this._instances[idx];
if (!inst.isPlaceholder) {
for (var i = 0; i < inst._children.length; i++) {
var el = inst._children[i];
Polymer.dom(inst.root).appendChild(el);
}
return inst;
}
},
_attachInstance: function (idx, parent, refNode) {
var inst = this._instances[idx];
if (!inst.isPlaceholder) {
parent.insertBefore(inst.root, refNode);
}
},
_detachAndRemoveInstance: function (idx) {
var inst = this._detachInstance(idx);
if (inst) {
this._pool.push(inst);
}
this._instances.splice(idx, 1);
},
_insertPlaceholder: function (idx, key) {
this._instances.splice(idx, 0, {
isPlaceholder: true,
__key__: key
});
},
_stampInstance: function (idx, key) {
var model = { __key__: key };
model[this.as] = this.collection.getItem(key);
model[this.indexAs] = idx;
return this.stamp(model);
},
_insertInstance: function (idx, key) {
var inst = this._pool.pop();
if (inst) {
inst.__setProperty(this.as, this.collection.getItem(key), true);
inst.__setProperty('__key__', key, true);
} else {
inst = this._stampInstance(idx, key);
}
var beforeRow = this._instances[idx + 1];
var beforeNode = beforeRow && !beforeRow.isPlaceholder ? beforeRow._children[0] : this;
var parentNode = Polymer.dom(this).parentNode;
if (parentNode.localName == this.is) {
if (beforeNode == this) {
beforeNode = parentNode;
}
parentNode = Polymer.dom(parentNode).parentNode;
}
Polymer.dom(parentNode).insertBefore(inst.root, beforeNode);
this._instances[idx] = inst;
return inst;
},
_downgradeInstance: function (idx, key) {
var inst = this._detachInstance(idx);
if (inst) {
this._pool.push(inst);
}
inst = {
isPlaceholder: true,
__key__: key
};
this._instances[idx] = inst;
return inst;
},
_showHideChildren: function (hidden) {
for (var i = 0; i < this._instances.length; i++) {
if (!this._instances[i].isPlaceholder)
this._instances[i]._showHideChildren(hidden);
}
},
_forwardInstanceProp: function (inst, prop, value) {
if (prop == this.as) {
var idx;
if (this._sortFn || this._filterFn) {
idx = this.items.indexOf(this.collection.getItem(inst.__key__));
} else {
idx = inst[this.indexAs];
}
this.set('items.' + idx, value);
}
},
_forwardInstancePath: function (inst, path, value) {
if (path.indexOf(this.as + '.') === 0) {
this._notifyPath('items.' + inst.__key__ + '.' + path.slice(this.as.length + 1), value);
}
},
_forwardParentProp: function (prop, value) {
var i$ = this._instances;
for (var i = 0, inst; i < i$.length && (inst = i$[i]); i++) {
if (!inst.isPlaceholder) {
inst.__setProperty(prop, value, true);
}
}
},
_forwardParentPath: function (path, value) {
var i$ = this._instances;
for (var i = 0, inst; i < i$.length && (inst = i$[i]); i++) {
if (!inst.isPlaceholder) {
inst._notifyPath(path, value, true);
}
}
},
_forwardItemPath: function (path, value) {
if (this._keyToInstIdx) {
var dot = path.indexOf('.');
var key = path.substring(0, dot < 0 ? path.length : dot);
var idx = this._keyToInstIdx[key];
var inst = this._instances[idx];
if (inst && !inst.isPlaceholder) {
if (dot >= 0) {
path = this.as + '.' + path.substring(dot + 1);
inst._notifyPath(path, value, true);
} else {
inst.__setProperty(this.as, value, true);
}
}
}
},
itemForElement: function (el) {
var instance = this.modelForElement(el);
return instance && instance[this.as];
},
keyForElement: function (el) {
var instance = this.modelForElement(el);
return instance && instance.__key__;
},
indexForElement: function (el) {
var instance = this.modelForElement(el);
return instance && instance[this.indexAs];
}
});Polymer({
is: 'array-selector',
_template: null,
properties: {
items: {
type: Array,
observer: 'clearSelection'
},
multi: {
type: Boolean,
value: false,
observer: 'clearSelection'
},
selected: {
type: Object,
notify: true
},
selectedItem: {
type: Object,
notify: true
},
toggle: {
type: Boolean,
value: false
}
},
clearSelection: function () {
if (Array.isArray(this.selected)) {
for (var i = 0; i < this.selected.length; i++) {
this.unlinkPaths('selected.' + i);
}
} else {
this.unlinkPaths('selected');
this.unlinkPaths('selectedItem');
}
if (this.multi) {
if (!this.selected || this.selected.length) {
this.selected = [];
this._selectedColl = Polymer.Collection.get(this.selected);
}
} else {
this.selected = null;
this._selectedColl = null;
}
this.selectedItem = null;
},
isSelected: function (item) {
if (this.multi) {
return this._selectedColl.getKey(item) !== undefined;
} else {
return this.selected == item;
}
},
deselect: function (item) {
if (this.multi) {
if (this.isSelected(item)) {
var skey = this._selectedColl.getKey(item);
this.arrayDelete('selected', item);
this.unlinkPaths('selected.' + skey);
}
} else {
this.selected = null;
this.selectedItem = null;
this.unlinkPaths('selected');
this.unlinkPaths('selectedItem');
}
},
select: function (item) {
var icol = Polymer.Collection.get(this.items);
var key = icol.getKey(item);
if (this.multi) {
if (this.isSelected(item)) {
if (this.toggle) {
this.deselect(item);
}
} else {
this.push('selected', item);
var skey = this._selectedColl.getKey(item);
this.linkPaths('selected.' + skey, 'items.' + key);
}
} else {
if (this.toggle && item == this.selected) {
this.deselect();
} else {
this.selected = item;
this.selectedItem = item;
this.linkPaths('selected', 'items.' + key);
this.linkPaths('selectedItem', 'items.' + key);
}
}
}
});Polymer({
is: 'dom-if',
extends: 'template',
_template: null,
properties: {
'if': {
type: Boolean,
value: false,
observer: '_queueRender'
},
restamp: {
type: Boolean,
value: false,
observer: '_queueRender'
},
notifyDomChange: { type: Boolean }
},
behaviors: [Polymer.Templatizer],
_queueRender: function () {
this._debounceTemplate(this._render);
},
detached: function () {
var parentNode = this.parentNode;
if (parentNode && parentNode.localName == this.is) {
parentNode = Polymer.dom(parentNode).parentNode;
}
if (!parentNode || parentNode.nodeType == Node.DOCUMENT_FRAGMENT_NODE && (!Polymer.Settings.hasShadow || !(parentNode instanceof ShadowRoot))) {
this._teardownInstance();
}
},
attached: function () {
if (this.if && this.ctor) {
this.async(this._ensureInstance);
}
},
render: function () {
this._flushTemplates();
},
_render: function () {
if (this.if) {
if (!this.ctor) {
this.templatize(this);
}
this._ensureInstance();
this._showHideChildren();
} else if (this.restamp) {
this._teardownInstance();
}
if (!this.restamp && this._instance) {
this._showHideChildren();
}
if (this.if != this._lastIf) {
if (!Polymer.Settings.suppressTemplateNotifications || this.notifyDomChange) {
this.fire('dom-change');
}
this._lastIf = this.if;
}
},
_ensureInstance: function () {
var refNode;
var parentNode = Polymer.dom(this).parentNode;
if (parentNode && parentNode.localName == this.is) {
refNode = parentNode;
parentNode = Polymer.dom(parentNode).parentNode;
} else {
refNode = this;
}
if (parentNode) {
if (!this._instance) {
this._instance = this.stamp();
var root = this._instance.root;
Polymer.dom(parentNode).insertBefore(root, refNode);
} else {
var c$ = this._instance._children;
if (c$ && c$.length) {
var lastChild = Polymer.dom(refNode).previousSibling;
if (lastChild !== c$[c$.length - 1]) {
for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
Polymer.dom(parentNode).insertBefore(n, refNode);
}
}
}
}
}
},
_teardownInstance: function () {
if (this._instance) {
var c$ = this._instance._children;
if (c$ && c$.length) {
var parent = Polymer.dom(Polymer.dom(c$[0]).parentNode);
for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
parent.removeChild(n);
}
}
this._instance = null;
}
},
_showHideChildren: function () {
var hidden = this.__hideTemplateChildren__ || !this.if;
if (this._instance) {
this._instance._showHideChildren(hidden);
}
},
_forwardParentProp: function (prop, value) {
if (this._instance) {
this._instance.__setProperty(prop, value, true);
}
},
_forwardParentPath: function (path, value) {
if (this._instance) {
this._instance._notifyPath(path, value, true);
}
}
});Polymer({
is: 'dom-bind',
properties: { notifyDomChange: { type: Boolean } },
extends: 'template',
_template: null,
created: function () {
var self = this;
Polymer.RenderStatus.whenReady(function () {
if (document.readyState == 'loading') {
document.addEventListener('DOMContentLoaded', function () {
self._markImportsReady();
});
} else {
self._markImportsReady();
}
});
},
_ensureReady: function () {
if (!this._readied) {
this._readySelf();
}
},
_markImportsReady: function () {
this._importsReady = true;
this._ensureReady();
},
_registerFeatures: function () {
this._prepConstructor();
},
_insertChildren: function () {
var refNode;
var parentNode = Polymer.dom(this).parentNode;
if (parentNode.localName == this.is) {
refNode = parentNode;
parentNode = Polymer.dom(parentNode).parentNode;
} else {
refNode = this;
}
Polymer.dom(parentNode).insertBefore(this.root, refNode);
},
_removeChildren: function () {
if (this._children) {
for (var i = 0; i < this._children.length; i++) {
this.root.appendChild(this._children[i]);
}
}
},
_initFeatures: function () {
},
_scopeElementClass: function (element, selector) {
if (this.dataHost) {
return this.dataHost._scopeElementClass(element, selector);
} else {
return selector;
}
},
_configureInstanceProperties: function () {
},
_prepConfigure: function () {
var config = {};
for (var prop in this._propertyEffects) {
config[prop] = this[prop];
}
var setupConfigure = this._setupConfigure;
this._setupConfigure = function () {
setupConfigure.call(this, config);
};
},
attached: function () {
if (this._importsReady) {
this.render();
}
},
detached: function () {
this._removeChildren();
},
render: function () {
this._ensureReady();
if (!this._children) {
this._template = this;
this._prepAnnotations();
this._prepEffects();
this._prepBehaviors();
this._prepConfigure();
this._prepBindings();
this._prepPropertyInfo();
Polymer.Base._initFeatures.call(this);
this._children = Polymer.TreeApi.arrayCopyChildNodes(this.root);
}
this._insertChildren();
if (!Polymer.Settings.suppressTemplateNotifications || this.notifyDomChange) {
this.fire('dom-change');
}
}
});</script></div><dom-module id="inkd-console-styles" assetpath="inkd-styles/">
    <template>
        <style>
            @import url("https://fonts.googleapis.com/css?family=Roboto");

            .console-container {
                font-family: 'Roboto', Arial, sans-serif;
                -webkit-font-smoothing: antialiased;
                text-rendering: optimizeLegibility;
                border-bottom-left-radius: 0.31em;
                border-top-left-radius: 0.31em;
                background-color: #34495e;
                box-shadow: 2px 2px 15px #000;    
            }
            
            .console-header {
                display: -webkit-box;
                display: -ms-flexbox;
                display: flex;
                -webkit-box-orient: horizontal;
                -webkit-box-direction: normal;
                    -ms-flex-direction: row;
                        flex-direction: row;
                -webkit-box-pack: justify;
                    -ms-flex-pack: justify;
                        justify-content: space-between;
                background-color: #7f8c8d;
                border-top-left-radius: 0.31em;
                cursor: pointer;
            }
            
            .console-header__title {
                font-size: 1em;
                padding-left: 1em;
            }
            
            .console-header__button {
                border: none;
                margin-right: 1em;
                background: url("inkd-images/down.svg");
                /* By Google Inc., CC BY 4.0, https://commons.wikimedia.org/w/index.php?curid=36333571 */
            }
            
            .hide-console .console-header__button {
                background: url("inkd-images/up.svg");
                /* By Google Inc., CC BY 4.0, https://commons.wikimedia.org/w/index.php?curid=36333583 */
            }
            
            .console-header__button, .hide-console .console-header__button {
                background-size: 30px 30px;
                background-position: center;
                background-repeat: no-repeat;
            }
            
            .console-body {
                font-size: 0.8em;
                padding: 0.8em;
                color: #ecf0f1;
                -webkit-animation: fadein 1s ease-in;
                        animation: fadein 1s ease-in;
                max-height: 25em;
                overflow-y: scroll;
            }
            
            .console-list {
                padding: 0;
                margin: 0;
                list-style: none;
            }
            
            .console-list__item {
                margin-bottom: 0.3em;
            }
            
            .console-list__icon {
                height: 20px;
                width: 20px;
                vertical-align: middle;
                cursor: pointer;
                border: none;
                background: url("inkd-images/console.svg");
                /* By Google Inc., CC BY 4.0, https://commons.wikimedia.org/w/index.php?curid=36333945 */
            }
            
            .console-list__icon.error {
                background: url("inkd-images/error.svg");
                /* By Google Inc., CC BY 4.0, https://commons.wikimedia.org/w/index.php?curid=36333906 */
            }
            
            .console-list__icon.warning {
                background: url("inkd-images/warning.svg");
                /* By Google Inc., CC BY 4.0, https://commons.wikimedia.org/w/index.php?curid=36336699 */
            }
            
            .console-list__icon.log {
                background: url("inkd-images/log.svg");
                /* By Google Inc., CC BY 4.0, https://commons.wikimedia.org/w/index.php?curid=36334738 */
            }
            
            .console-list__icon, .console-list__icon.error, .console-list__icon.warning, .console-list__icon.log {
                background-size: 20px 20px;
                background-position: center;
                background-repeat: no-repeat;
            }
            
            .console-list__text {
                vertical-align: middle;
            }
            
            .console-list__info {
                display: block;
                white-space: pre-line;
                color: #bbb;
                margin: 0 0 0 20px;
            }
            
            .hide-info ~ .console-list__info {
                display: none;
            }
            
            @-webkit-keyframes fadein {
                from {
                    opacity: 0.5;
                    -ms-filter: "progid:DXImageTransform.Microsoft.Alpha(Opacity=50)";
                }
                to {
                    opacity: 1;
                    -ms-filter: "progid:DXImageTransform.Microsoft.Alpha(Opacity=100)";
                }
            }
            
            @keyframes fadein {
                from {
                    opacity: 0.5;
                    -ms-filter: "progid:DXImageTransform.Microsoft.Alpha(Opacity=50)";
                }
                to {
                    opacity: 1;
                    -ms-filter: "progid:DXImageTransform.Microsoft.Alpha(Opacity=100)";
                }
            }
        </style>
    </template>
</dom-module><dom-module id="inkd-console" assetpath="inkd-elements/">
    
    <template>
        <style include="inkd-console-styles"></style>
        
        <div id="container" class="console-container">
            <div class="console-header" on-tap="_handleHeaderTap">
                <h1 class="console-header__title">[[header]] ([[list.length]])</h1>
                <button type="button" class="console-header__button"></button>
            </div>
            
            <template is="dom-if" if="[[_showConsole]]">
                <div class="console-body" id="list-container">
                    <ul class="console-list">
                        <template is="dom-repeat" items="[[list]]">
                            <li class="console-list__item">
                                <button type="button" on-tap="_handleIconTap" class$="console-list__icon hide-info [[item.type]]"></button>
                                <span class="console-list__text">[[item.text]]</span>
                                <p class="console-list__info">[[item.info]]</p>
                            </li>
                        </template>
                    </ul>
                </div>    
            </template>
        </div>
    </template>
    
    </dom-module><dom-module id="inkd-ml" assetpath="inkd-elements/">
    
    <template>
        <style>
            .container {
                position: fixed;
                bottom: 0;
                right: 0;
                z-index: 10;
                width: 25%;
            }
        </style>
        
        <content></content>
        
        <div class="container">
            <template is="dom-if" if="[[debug]]">
                <inkd-console list="[[debugList]]" header="Debugger"></inkd-console>
            </template>

            <template is="dom-if" if="[[_trackLog]]">
                <inkd-console list="[[trackLogList]]" header="Tracker"></inkd-console>
            </template>
        </div>
    </template>
    
    </dom-module><dom-module id="inkd-include" assetpath="inkd-elements/">

    </dom-module>


<dom-module id="inkd-content" assetpath="inkd-elements/">

    </dom-module><dom-module id="inkd-if" assetpath="inkd-elements/">

    <template strip-whitespace="">
        <template is="dom-if" if="[[_ruleTrue]]" restamp="">
            <content></content>
        </template>
        <template is="dom-if" if="[[!_ruleTrue]]" restamp="">
            <content select="inkd-else"></content>
        </template>
    </template>
    
    </dom-module>

<dom-module id="inkd-else" assetpath="inkd-elements/">

    <template strip-whitespace="">
        <content></content>
    </template>
    
    </dom-module><dom-module id="inkd-value" assetpath="inkd-elements/">

    <template>
        <style>
            :host {
                display: inline-block;
            }
        </style>
        
        <span inner-h-t-m-l="[[_value]]"></span>        
    </template>
    
    </dom-module><dom-module id="inkd-button" assetpath="inkd-elements/">

    <template>
        <content></content>
    </template>

    </dom-module>


<dom-module id="inkd-action" assetpath="inkd-elements/">

    <template>
        <content></content>
    </template>

    </dom-module><dom-module id="inkd-node" assetpath="inkd-elements/cyoa/">

    </dom-module><dom-module id="inkd-cyoa" assetpath="inkd-elements/cyoa/">

    <template>
        <content select="[active-node]"></content>
    </template>

    </dom-module><style>
/* Pannellum 2.3.2, https://github.com/mpetroff/pannellum */
.pnlm-container{margin:0;padding:0;overflow:hidden;position:relative;cursor:default;width:100%;height:100%;font-family:Helvetica,"Nimbus Sans L","Liberation Sans",Arial,sans-serif;background:#f4f4f4 url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2267%22%20height%3D%22100%22%20viewBox%3D%220%200%2067%20100%22%3E%0A%3Cpath%20stroke%3D%22%23ccc%22%20fill%3D%22none%22%20d%3D%22M33.5%2C50%2C0%2C63%2C33.5%2C75%2C67%2C63%2C33.5%2C50m-33.5-50%2C67%2C25m-0.5%2C0%2C0%2C75m-66.5-75%2C67-25m-33.5%2C75%2C0%2C25m0-100%2C0%2C50%22%2F%3E%0A%3C%2Fsvg%3E%0A") repeat;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-o-user-select:none;-ms-user-select:none;user-select:none;outline:0;line-height:1.4;contain:content}
.pnlm-container *{box-sizing:content-box}
.pnlm-grab{cursor:url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20height%3D%2226%22%20width%3D%2226%22%3E%0A%3Cpath%20stroke%3D%22%23000%22%20stroke-width%3D%221px%22%20fill%3D%22%23fff%22%20d%3D%22m15.3%2020.5s6.38-6.73%204.64-8.24-3.47%201.01-3.47%201.01%203.61-5.72%201.41-6.49c-2.2-0.769-3.33%204.36-3.33%204.36s0.873-5.76-1.06-5.76-1.58%205.39-1.58%205.39-0.574-4.59-2.18-4.12c-1.61%200.468-0.572%205.51-0.572%205.51s-1.58-4.89-2.93-3.79c-1.35%201.11%200.258%205.25%200.572%206.62%200.836%202.43%202.03%202.94%202.17%205.55%22%2F%3E%0A%3C%2Fsvg%3E%0A") 12 8,default}
.pnlm-grabbing{cursor:url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20height%3D%2226%22%20width%3D%2226%22%3E%0A%3Cpath%20stroke%3D%22%23000%22%20stroke-width%3D%221px%22%20fill%3D%22%23fff%22%20d%3D%22m15.3%2020.5s5.07-5.29%203.77-6.74c-1.31-1.45-2.53%200.14-2.53%200.14s2.74-3.29%200.535-4.06c-2.2-0.769-2.52%201.3-2.52%201.3s0.81-2.13-1.12-2.13-1.52%201.77-1.52%201.77-0.261-1.59-1.87-1.12c-1.61%200.468-0.874%202.17-0.874%202.17s-0.651-1.55-2-0.445c-1.35%201.11-0.68%202.25-0.365%203.62%200.836%202.43%202.03%202.94%202.17%205.55%22%2F%3E%0A%3C%2Fsvg%3E%0A") 12 8,default}
.pnlm-sprite{
    background-image:url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2226%22%20height%3D%22208%22%3E%0A%3Ccircle%20fill-opacity%3D%22.78%22%20cy%3D%22117%22%20cx%3D%2213%22%20r%3D%2211%22%20fill%3D%22%23fff%22%2F%3E%0A%3Ccircle%20fill-opacity%3D%22.78%22%20cy%3D%22143%22%20cx%3D%2213%22%20r%3D%2211%22%20fill%3D%22%23fff%22%2F%3E%0A%3Ccircle%20cy%3D%22169%22%20cx%3D%2213%22%20r%3D%227%22%20fill%3D%22none%22%20stroke%3D%22%23000%22%20stroke-width%3D%222%22%2F%3E%0A%3Ccircle%20cy%3D%22195%22%20cx%3D%2213%22%20r%3D%227%22%20fill%3D%22none%22%20stroke%3D%22%23000%22%20stroke-width%3D%222%22%2F%3E%0A%3Ccircle%20cx%3D%2213%22%20cy%3D%22195%22%20r%3D%222.5%22%2F%3E%0A%3Cpath%20d%3D%22m5%2083v6h2v-4h4v-2zm10%200v2h4v4h2v-6zm-5%205v6h6v-6zm-5%205v6h6v-2h-4v-4zm14%200v4h-4v2h6v-6z%22%2F%3E%0A%3Cpath%20d%3D%22m13%20110a7%207%200%200%200%20-7%207%207%207%200%200%200%207%207%207%207%200%200%200%207%20-7%207%207%200%200%200%20-7%20-7zm-1%203h2v2h-2zm0%203h2v5h-2z%22%2F%3E%0A%3Cpath%20d%3D%22m5%2057v6h2v-4h4v-2zm10%200v2h4v4h2v-6zm-10%2010v6h6v-2h-4v-4zm14%200v4h-4v2h6v-6z%22%2F%3E%0A%3Cpath%20d%3D%22m17%2038v2h-8v-2z%22%2F%3E%0A%3Cpath%20d%3D%22m12%209v3h-3v2h3v3h2v-3h3v-2h-3v-3z%22%2F%3E%0A%3Cpath%20d%3D%22m13%20136-6.125%206.125h4.375v7.875h3.5v-7.875h4.375z%22%2F%3E%0A%3Cpath%20d%3D%22m10.428%20173.33v-5.77l5-2.89v5.77zm1-1.73%203-1.73-3.001-1.74z%22%2F%3E%0A%3C%2Fsvg%3E%0A")
}
.pnlm-container:-moz-full-screen{height:100%!important;width:100%!important}
.pnlm-container:-webkit-full-screen{height:100%!important;width:100%!important}
.pnlm-container:-ms-fullscreen{height:100%!important;width:100%!important}
.pnlm-container:fullscreen{height:100%!important;width:100%!important}
.pnlm-render-container{cursor:inherit;position:absolute;height:100%;width:100%}
.pnlm-controls{margin-top:4px;background-color:#fff;border:1px solid #999;border-color:rgba(0,0,0,0.4);border-radius:3px;cursor:pointer;z-index:2;-webkit-transform:translateZ(9999px);transform:translateZ(9999px)}
.pnlm-control:hover{background-color:#f8f8f8}
.pnlm-controls-container{position:absolute;top:0;left:4px;z-index:1}
.pnlm-zoom-controls{width:26px;height:52px}
.pnlm-zoom-in{width:100%;height:50%;position:absolute;top:0;border-radius:3px 3px 0 0}
.pnlm-zoom-out{width:100%;height:50%;position:absolute;bottom:0;background-position:0 -26px;border-top:1px solid #ddd;border-top-color:rgba(0,0,0,0.10);border-radius:0 0 3px 3px}
.pnlm-fullscreen-toggle-button,.pnlm-orientation-button,.pnlm-hot-spot-debug-indicator{width:26px;height:26px}
.pnlm-hot-spot-debug-indicator{position:absolute;top:50%;left:50%;width:26px;height:26px;margin:-13px 0 0 -13px;background-color:rgba(255,255,255,0.5);border-radius:13px;display:none}
.pnlm-orientation-button-inactive{background-position:0 -156px}
.pnlm-orientation-button-active{background-position:0 -182px}
.pnlm-fullscreen-toggle-button-inactive{background-position:0 -52px}
.pnlm-fullscreen-toggle-button-active{background-position:0 -78px}
.pnlm-panorama-info{position:absolute;bottom:4px;background-color:rgba(0,0,0,0.7);border-radius:0 3px 3px 0;padding-right:10px;color:#fff;text-align:left;display:none;z-index:2;-webkit-transform:translateZ(9999px);transform:translateZ(9999px)}
.pnlm-title-box{position:relative;font-size:20px;display:table;padding-left:5px;margin-bottom:3px}
.pnlm-author-box{position:relative;font-size:12px;display:table;padding-left:5px}
.pnlm-load-box{position:absolute;top:50%;left:50%;width:200px;height:150px;margin:-75px 0 0 -100px;background-color:rgba(0,0,0,0.7);border-radius:3px;text-align:center;font-size:20px;display:none;color:#fff}
.pnlm-load-box p{margin:20px 0}
.pnlm-lbox{position:absolute;top:50%;left:50%;width:20px;height:20px;margin:-10px 0 0 -10px;display:none}
.pnlm-loading{animation-duration:1.5s;-webkit-animation-duration:1.5s;animation-name:pnlm-mv;-webkit-animation-name:pnlm-mv;animation-iteration-count:infinite;-webkit-animation-iteration-count:infinite;animation-timing-function:linear;-webkit-animation-timing-function:linear;height:10px;width:10px;background-color:#fff;position:relative}@keyframes pnlm-mv{from{left:0;top:0}25%{left:10px;top:0}50%{left:10px;top:10px}75%{left:0;top:10px}to{left:0;top:0}}@-webkit-keyframes pnlm-mv{from{left:0;top:0}25%{left:10px;top:0}50%{left:10px;top:10px}75%{left:0;top:10px}to{left:0;top:0}}
.pnlm-load-button{position:absolute;top:50%;left:50%;width:200px;height:100px;margin:-50px 0 0 -100px;background-color:rgba(0,0,0,.7);border-radius:3px;text-align:center;font-size:20px;display:table;color:#fff;cursor:pointer}
.pnlm-load-button:hover{background-color:rgba(0,0,0,.8)}
.pnlm-load-button p{display:table-cell;vertical-align:middle}
.pnlm-info-box{font-size:15px;position:absolute;top:50%;left:50%;width:200px;height:150px;margin:-75px 0 0 -100px;background-color:#000;border-radius:3px;display:table;text-align:center;color:#fff;table-layout:fixed}
.pnlm-info-box a{color:#fff;word-wrap:break-word;overflow-wrap:break-word}
.pnlm-info-box p{display:table-cell;vertical-align:middle;padding:0 5px 0 5px}
.pnlm-error-msg{display:none}
.pnlm-about-msg{font-size:11px;line-height:11px;color:#fff;padding:5px 8px 5px 8px;background:rgba(0,0,0,0.7);border-radius:3px;position:absolute;top:50px;left:50px;display:none;opacity:0;-moz-transition:opacity .3s ease-in-out;-webkit-transition:opacity .3s ease-in-out;-o-transition:opacity .3s ease-in-out;-ms-transition:opacity .3s ease-in-out;transition:opacity .3s ease-in-out;z-index:1}
.pnlm-about-msg a:link,.pnlm-about-msg a:visited{color:#fff}.pnlm-about-msg a:hover,.pnlm-about-msg a:active{color:#eee}
.pnlm-hotspot-base{position:absolute;visibility:hidden;cursor:default;vertical-align:middle;top:0;z-index:1}
/*
.pnlm-hotspot{height:26px;width:26px;border-radius:13px}
.pnlm-hotspot:hover{background-color:rgba(255,255,255,0.2)}
.pnlm-hotspot.pnlm-info{background-position:0 -104px}
.pnlm-hotspot.pnlm-scene{background-position:0 -130px}
*/
div.pnlm-tooltip span{visibility:hidden;position:absolute;border-radius:3px;background-color:rgba(0,0,0,0.7);color:#fff;text-align:center;max-width:200px;padding:5px 10px;margin-left:-220px;cursor:default}
div.pnlm-tooltip:hover span{visibility:visible}
div.pnlm-tooltip:hover span:after{content:'';position:absolute;width:0;height:0;border-width:10px;border-style:solid;border-color:rgba(0,0,0,0.7) transparent transparent transparent;bottom:-20px;left:-10px;margin:0 50%}
.pnlm-compass{position:absolute;width:50px;height:50px;right:4px;bottom:4px;border-radius:25px;background-image:url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20height%3D%2250%22%20width%3D%2250%22%3E%0A%3Cpath%20d%3D%22m24.5078%206-3.2578%2018h7.5l-3.25781-18h-0.984376zm-3.2578%2020%203.2578%2018h0.9844l3.2578-18h-7.5zm1.19531%200.9941h5.10938l-2.5547%2014.1075-2.5547-14.1075z%22%2F%3E%0A%3C%2Fsvg%3E%0A");cursor:default;display:none}
.pnlm-world{position:absolute;left:50%;top:50%}
.pnlm-face{position:absolute;-webkit-transform-origin:0 0;transform-origin:0 0}
.pnlm-dragfix,.pnlm-preview-img{position:absolute;height:100%;width:100%}
.pnlm-preview-img{background-size:cover;background-position:center}
.pnlm-lbar{width:150px;margin:0 auto;border:#fff 1px solid;height:6px}
.pnlm-lbar-fill{background:#fff;height:100%;width:0}
.pnlm-lmsg{font-size:12px}
.pnlm-fade-img{position:absolute;top:0;left:0}
</style>
<script type="text/javascript">/*
 * libpannellum - A WebGL and CSS 3D transform based Panorama Renderer
 * Copyright (c) 2012-2017 Matthew Petroff
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

window.libpannellum = (function(window, document, undefined) {

'use strict';

/**
 * Creates a new panorama renderer.
 * @constructor
 * @param {HTMLElement} container - The container element for the renderer.
 */
function Renderer(container) {
    var canvas = document.createElement('canvas');
    canvas.style.width = canvas.style.height = '100%';
    Polymer.dom(container).appendChild(canvas);

    var program, gl, vs, fs;
    var fallbackImgSize;
    var world;
    var vtmps;
    var pose;
    var image, imageType, dynamic;
    var texCoordBuffer, cubeVertBuf, cubeVertTexCoordBuf, cubeVertIndBuf;

    /**
     * Initialize renderer.
     * @memberof Renderer
     * @instance
     * @param {Image|Array|Object} image - Input image; format varies based on
     *      `imageType`. For `equirectangular`, this is an image; for
     *      `cubemap`, this is an array of images for the cube faces in the
     *      order [+z, +x, -z, -x, +y, -y]; for `multires`, this is a
     *      configuration object.
     * @param {string} imageType - The type of the image: `equirectangular`,
     *      `cubemap`, or `multires`.
     * @param {boolean} dynamic - Whether or not the image is dynamic (e.g. video).
     * @param {number} haov - Initial horizontal angle of view.
     * @param {number} vaov - Initial vertical angle of view.
     * @param {number} voffset - Initial vertical offset angle.
     * @param {function} callback - Load callback function.
     * @param {Object} [params] - Other configuration parameters (`horizonPitch`, `horizonRoll`, `backgroundColor`).
     */
    this.init = function(_image, _imageType, _dynamic, haov, vaov, voffset, callback, params) {
        // Default argument for image type
        if (typeof _imageType === undefined)
            _imageType = 'equirectangular';

        if (_imageType != 'equirectangular' && _imageType != 'cubemap' &&
            _imageType != 'multires') {
            console.log('Error: invalid image type specified!');
            throw {type: 'config error'};
        }

        imageType = _imageType;
        image = _image;
        dynamic = _dynamic;

        // Clear old data
        if (program) {
            if (vs) {
                gl.detachShader(program, vs);
                gl.deleteShader(vs);
            }
            if (fs) {
                gl.detachShader(program, fs);
                gl.deleteShader(fs);
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
            if (program.texture)
                gl.deleteTexture(program.texture);
            if (program.nodeCache)
                for (var i = 0; i < program.nodeCache.length; i++)
                    gl.deleteTexture(program.nodeCache[i].texture);
            gl.deleteProgram(program);
            program = undefined;
        }
        pose = undefined;

        var s;
        
        // This awful browser specific test exists because iOS 8/9 and IE 11
        // don't display non-power-of-two cubemap textures but also don't
        // throw an error (tested on an iPhone 5c / iOS 8.1.3 / iOS 9.2).
        // Therefore, the WebGL context is never created for these browsers for
        // NPOT cubemaps, and the CSS 3D transform fallback renderer is used
        // instead.
        if (!(imageType == 'cubemap' &&
            (image[0].width & (image[0].width - 1)) !== 0 &&
            (navigator.userAgent.toLowerCase().match(/(iphone|ipod|ipad).* os 8_/) ||
            navigator.userAgent.toLowerCase().match(/(iphone|ipod|ipad).* os 9_/) ||
            navigator.userAgent.match(/Trident.*rv[ :]*11\./)))) {
            // Enable WebGL on canvas
            if (!gl)
                gl = canvas.getContext('experimental-webgl', {alpha: false, depth: false});
        }
        
        // If there is no WebGL, fall back to CSS 3D transform renderer.
        // While browser specific tests are usually frowned upon, the
        // fallback viewer only really works with WebKit/Blink and IE 10/11
        // (it doesn't work properly in Firefox).
        if (!gl && ((imageType == 'multires' && image.hasOwnProperty('fallbackPath')) ||
            imageType == 'cubemap') &&
            ('WebkitAppearance' in document.documentElement.style ||
            navigator.userAgent.match(/Trident.*rv[ :]*11\./) ||
            navigator.appVersion.indexOf('MSIE 10') !== -1)) {
            // Remove old world if it exists
            if (world) {
                Polymer.dom(container).removeChild(world);
            }
            
            // Initialize renderer
            world = document.createElement('div');
            world.className = 'pnlm-world';
            
            // Add images
            var path;
            if (image.basePath) {
                path = image.basePath + image.fallbackPath;
            } else {
                path = image.fallbackPath;
            }
            var sides = ['f', 'r', 'b', 'l', 'u', 'd'];
            var loaded = 0;
            var onLoad = function() {
                // Draw image on canvas
                var faceCanvas = document.createElement('canvas');
                faceCanvas.className = 'pnlm-face pnlm-' + sides[this.side] + 'face';
                Polymer.dom(world).appendChild(faceCanvas);
                var faceContext = faceCanvas.getContext('2d');
                faceCanvas.style.width = this.width + 4 + 'px';
                faceCanvas.style.height = this.height + 4 + 'px';
                faceCanvas.width = this.width + 4;
                faceCanvas.height = this.height + 4;
                faceContext.drawImage(this, 2, 2);
                var imgData = faceContext.getImageData(0, 0, faceCanvas.width, faceCanvas.height);
                var data = imgData.data;
                
                // Duplicate edge pixels
                var i;
                var j;
                for (i = 2; i < faceCanvas.width - 2; i++) {
                    for (j = 0; j < 4; j++) {
                        data[(i + faceCanvas.width) * 4 + j] = data[(i + faceCanvas.width * 2) * 4 + j];
                        data[(i + faceCanvas.width * (faceCanvas.height - 2)) * 4 + j] = data[(i + faceCanvas.width * (faceCanvas.height - 3)) * 4 + j];
                    }
                }
                for (i = 2; i < faceCanvas.height - 2; i++) {
                    for (j = 0; j < 4; j++) {
                        data[(i * faceCanvas.width + 1) * 4 + j] = data[(i * faceCanvas.width + 2) * 4 + j];
                        data[((i + 1) * faceCanvas.width - 2) * 4 + j] = data[((i + 1) * faceCanvas.width - 3) * 4 + j];
                    }
                }
                for (j = 0; j < 4; j++) {
                    data[(faceCanvas.width + 1) * 4 + j] = data[(faceCanvas.width * 2 + 2) * 4 + j];
                    data[(faceCanvas.width * 2 - 2) * 4 + j] = data[(faceCanvas.width * 3 - 3) * 4 + j];
                    data[(faceCanvas.width * (faceCanvas.height - 2) + 1) * 4 + j] = data[(faceCanvas.width * (faceCanvas.height - 3) + 2) * 4 + j];
                    data[(faceCanvas.width * (faceCanvas.height - 1) - 2) * 4 + j] = data[(faceCanvas.width * (faceCanvas.height - 2) - 3) * 4 + j];
                }
                for (i = 1; i < faceCanvas.width - 1; i++) {
                    for (j = 0; j < 4; j++) {
                        data[i * 4 + j] = data[(i + faceCanvas.width) * 4 + j];
                        data[(i + faceCanvas.width * (faceCanvas.height - 1)) * 4 + j] = data[(i + faceCanvas.width * (faceCanvas.height - 2)) * 4 + j];
                    }
                }
                for (i = 1; i < faceCanvas.height - 1; i++) {
                    for (j = 0; j < 4; j++) {
                        data[(i * faceCanvas.width) * 4 + j] = data[(i * faceCanvas.width + 1) * 4 + j];
                        data[((i + 1) * faceCanvas.width - 1) * 4 + j] = data[((i + 1) * faceCanvas.width - 2) * 4 + j];
                    }
                }
                for (j = 0; j < 4; j++) {
                    data[j] = data[(faceCanvas.width + 1) * 4 + j];
                    data[(faceCanvas.width - 1) * 4 + j] = data[(faceCanvas.width * 2 - 2) * 4 + j];
                    data[(faceCanvas.width * (faceCanvas.height - 1)) * 4 + j] = data[(faceCanvas.width * (faceCanvas.height - 2) + 1) * 4 + j];
                    data[(faceCanvas.width * faceCanvas.height - 1) * 4 + j] = data[(faceCanvas.width * (faceCanvas.height - 1) - 2) * 4 + j];
                }
                
                // Draw image width duplicated edge pixels on canvas
                faceContext.putImageData(imgData, 0, 0);
                
                loaded++;
                if (loaded == 6) {
                    fallbackImgSize = this.width;
                    Polymer.dom(container).appendChild(world);
                    callback();
                }
            };
            for (s = 0; s < 6; s++) {
                var faceImg = new Image();
                faceImg.crossOrigin = 'anonymous';
                faceImg.side = s;
                faceImg.onload = onLoad;
                if (imageType == 'multires') {
                    faceImg.src = encodeURI(path.replace('%s', sides[s]) + '.' + image.extension);
                } else {
                    faceImg.src = encodeURI(image[s].src);
                }
            }
            
            return;
        } else if (!gl) {
            console.log('Error: no WebGL support detected!');
            throw {type: 'no webgl'};
        }
        if (image.basePath) {
            image.fullpath = image.basePath + image.path;
        } else {
            image.fullpath = image.path;
        }
        image.invTileResolution = 1 / image.tileResolution;
        
        var vertices = createCube();
        vtmps = [];
        for (s = 0; s < 6; s++) {
            vtmps[s] = vertices.slice(s * 12, s * 12 + 12);
            vertices = createCube();
        }
        
        // Make sure image isn't too big
        var width, maxWidth;
        if (imageType == 'equirectangular') {
            width = Math.max(image.width, image.height);
            maxWidth = gl.getParameter(gl.MAX_TEXTURE_SIZE);
            if (width > maxWidth) {
                console.log('Error: The image is too big; it\'s ' + width + 'px wide, but this device\'s maximum supported width is ' + maxWidth + 'px.');
                throw {type: 'webgl size error', width: width, maxWidth: maxWidth};
            }
        } else if (imageType == 'cubemap') {
            width = image[0].width;
            maxWidth = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
            if (width > maxWidth) {
                console.log('Error: The cube face image is too big; it\'s ' + width + 'px wide, but this device\'s maximum supported width is ' + maxWidth + 'px.');
                throw {type: 'webgl size error', width: width, maxWidth: maxWidth};
            }
        }

        // Store horizon pitch and roll if applicable
        if (params !== undefined && (params.horizonPitch !== undefined || params.horizonRoll !== undefined))
            pose = [params.horizonPitch == undefined ? 0 : params.horizonPitch,
                    params.horizonRoll == undefined ? 0 : params.horizonRoll];

        // Set 2d texture binding
        var glBindType = gl.TEXTURE_2D;

        // Create viewport for entire canvas
        gl.viewport(0, 0, canvas.width, canvas.height);

        // Create vertex shader
        vs = gl.createShader(gl.VERTEX_SHADER);
        var vertexSrc = v;
        if (imageType == 'multires') {
            vertexSrc = vMulti;
        }
        gl.shaderSource(vs, vertexSrc);
        gl.compileShader(vs);

        // Create fragment shader
        fs = gl.createShader(gl.FRAGMENT_SHADER);
        var fragmentSrc = fragEquirectangular;
        if (imageType == 'cubemap') {
            glBindType = gl.TEXTURE_CUBE_MAP;
            fragmentSrc = fragCube;
        } else if (imageType == 'multires') {
            fragmentSrc = fragMulti;
        }
        gl.shaderSource(fs, fragmentSrc);
        gl.compileShader(fs);

        // Link WebGL program
        program = gl.createProgram();
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);

        // Log errors
        if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS))
            console.log(gl.getShaderInfoLog(vs));
        if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS))
            console.log(gl.getShaderInfoLog(fs));
        if (!gl.getProgramParameter(program, gl.LINK_STATUS))
            console.log(gl.getProgramInfoLog(program));

        // Use WebGL program
        gl.useProgram(program);

        program.drawInProgress = false;

        // Look up texture coordinates location
        program.texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');
        gl.enableVertexAttribArray(program.texCoordLocation);

        if (imageType != 'multires') {
            // Provide texture coordinates for rectangle
            if (!texCoordBuffer)
                texCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,1,1,1,1,-1,-1,1,1,-1,-1,-1]), gl.STATIC_DRAW);
            gl.vertexAttribPointer(program.texCoordLocation, 2, gl.FLOAT, false, 0, 0);

            // Pass aspect ratio
            program.aspectRatio = gl.getUniformLocation(program, 'u_aspectRatio');
            gl.uniform1f(program.aspectRatio, canvas.width / canvas.height);

            // Locate psi, theta, focal length, horizontal extent, vertical extent, and vertical offset
            program.psi = gl.getUniformLocation(program, 'u_psi');
            program.theta = gl.getUniformLocation(program, 'u_theta');
            program.f = gl.getUniformLocation(program, 'u_f');
            program.h = gl.getUniformLocation(program, 'u_h');
            program.v = gl.getUniformLocation(program, 'u_v');
            program.vo = gl.getUniformLocation(program, 'u_vo');
            program.rot = gl.getUniformLocation(program, 'u_rot');

            // Pass horizontal extent, vertical extent, and vertical offset
            gl.uniform1f(program.h, haov / (Math.PI * 2.0));
            gl.uniform1f(program.v, vaov / Math.PI);
            gl.uniform1f(program.vo, voffset / Math.PI * 2);

            // Set background color
            if (imageType == 'equirectangular') {
                program.backgroundColor = gl.getUniformLocation(program, 'u_backgroundColor');
                var color = params.backgroundColor ? params.backgroundColor : [0, 0, 0];
                gl.uniform4fv(program.backgroundColor, color.concat([1]));
            }

            // Create texture
            program.texture = gl.createTexture();
            gl.bindTexture(glBindType, program.texture);

            // Upload images to texture depending on type
            if (imageType == 'cubemap') {
                // Load all six sides of the cube map
                gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image[1]);
                gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image[3]);
                gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image[4]);
                gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image[5]);
                gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image[0]);
                gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image[2]);
            } else {
                // Upload image to the texture
                gl.texImage2D(glBindType, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image);
            }

            // Set parameters for rendering any size
            gl.texParameteri(glBindType, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(glBindType, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(glBindType, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(glBindType, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

        } else {
            // Look up vertex coordinates location
            program.vertPosLocation = gl.getAttribLocation(program, 'a_vertCoord');
            gl.enableVertexAttribArray(program.vertPosLocation);

            // Create buffers
            if (!cubeVertBuf)
                cubeVertBuf = gl.createBuffer();
            if (!cubeVertTexCoordBuf)
                cubeVertTexCoordBuf = gl.createBuffer();
            if (!cubeVertIndBuf)
                cubeVertIndBuf = gl.createBuffer();

            // Bind texture coordinate buffer and pass coordinates to WebGL
            gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertTexCoordBuf);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0,0,1,0,1,1,0,1]), gl.STATIC_DRAW);

            // Bind square index buffer and pass indicies to WebGL
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertIndBuf);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0,1,2,0,2,3]), gl.STATIC_DRAW);

            // Find uniforms
            program.perspUniform = gl.getUniformLocation(program, 'u_perspMatrix');
            program.cubeUniform = gl.getUniformLocation(program, 'u_cubeMatrix');
            //program.colorUniform = gl.getUniformLocation(program, 'u_color');

            program.level = -1;

            program.currentNodes = [];
            program.nodeCache = [];
            program.nodeCacheTimestamp = 0;
        }

        // Check if there was an error
        if (gl.getError() !== 0) {
            console.log('Error: Something went wrong with WebGL!');
            throw {type: 'webgl error'};
        }

        callback();
     };

    /**
     * Destroy renderer.
     * @memberof Renderer
     * @instance
     */
    this.destroy = function() {
        if (container !== undefined) {
            if (canvas !== undefined) {
                Polymer.dom(container).removeChild(canvas);
            }
            if (world !== undefined) {
                Polymer.dom(container).removeChild(world);
            }
        }
        if (gl) {
            // The spec says this is only supposed to simulate losing the WebGL
            // context, but in practice it tends to actually free the memory.
            var extension = gl.getExtension('WEBGL_lose_context');
            if (extension)
                extension.loseContext();
        }
    };

    /**
     * Resize renderer (call after resizing container).
     * @memberof Renderer
     * @instance
     */
    this.resize = function() {
        var pixelRatio = window.devicePixelRatio || 1;
        canvas.width = canvas.clientWidth * pixelRatio;
        canvas.height = canvas.clientHeight * pixelRatio;
        if (gl) {
            gl.viewport(0, 0, canvas.width, canvas.height);
            if (imageType != 'multires') {
                gl.uniform1f(program.aspectRatio, canvas.width / canvas.height);
            }
        }
    };
    // Initialize canvas size
    this.resize();

    /**
     * Render new view of panorama.
     * @memberof Renderer
     * @instance
     * @param {number} pitch - Pitch to render at (in radians).
     * @param {number} yaw - Yaw to render at (in radians).
     * @param {number} hfov - Horizontal field of view to render with (in radians).
     * @param {Object} [params] - Extra configuration parameters. 
     * @param {number} [params.roll] - Camera roll (in radians).
     * @param {boolean} [params.returnImage] - Return rendered image?
     */
    this.render = function(pitch, yaw, hfov, params) {
        var focal, i, s, roll = 0;
        if (params === undefined)
            params = {};
        if (params.roll)
            roll = params.roll;

        // Apply pitch and roll transformation if applicable
        if (pose !== undefined) {
            var horizonPitch = pose[0],
                horizonRoll = pose[1];

            // Calculate new pitch and yaw
            var orig_pitch = pitch,
                orig_yaw = yaw,
                x = Math.cos(horizonRoll) * Math.sin(pitch) * Math.sin(horizonPitch) +
                    Math.cos(pitch) * (Math.cos(horizonPitch) * Math.cos(yaw) +
                    Math.sin(horizonRoll) * Math.sin(horizonPitch) * Math.sin(yaw)),
                y = -Math.sin(pitch) * Math.sin(horizonRoll) +
                    Math.cos(pitch) * Math.cos(horizonRoll) * Math.sin(yaw),
                z = Math.cos(horizonRoll) * Math.cos(horizonPitch) * Math.sin(pitch) +
                    Math.cos(pitch) * (-Math.cos(yaw) * Math.sin(horizonPitch) +
                    Math.cos(horizonPitch) * Math.sin(horizonRoll) * Math.sin(yaw));
            pitch = Math.asin(Math.max(Math.min(z, 1), -1));
            yaw = Math.atan2(y, x);

            // Calculate roll
            var v = [Math.cos(orig_pitch) * (Math.sin(horizonRoll) * Math.sin(horizonPitch) * Math.cos(orig_yaw) -
                    Math.cos(horizonPitch) * Math.sin(orig_yaw)),
                    Math.cos(orig_pitch) * Math.cos(horizonRoll) * Math.cos(orig_yaw),
                    Math.cos(orig_pitch) * (Math.cos(horizonPitch) * Math.sin(horizonRoll) * Math.cos(orig_yaw) +
                    Math.sin(orig_yaw) * Math.sin(horizonPitch))],
                w = [-Math.cos(pitch) * Math.sin(yaw), Math.cos(pitch) * Math.cos(yaw)];
            var roll_adj = Math.acos(Math.max(Math.min((v[0]*w[0] + v[1]*w[1]) /
                (Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]) *
                Math.sqrt(w[0]*w[0]+w[1]*w[1])), 1), -1));
            if (v[2] < 0)
                roll_adj = 2 * Math.PI - roll_adj;
            roll += roll_adj;
        }

        // If no WebGL
        if (!gl && (imageType == 'multires' || imageType == 'cubemap')) {
            // Determine face transforms
            s = fallbackImgSize / 2;
            
            var transforms = {
                f: 'translate3d(-' + (s + 2) + 'px, -' + (s + 2) + 'px, -' + s + 'px)',
                b: 'translate3d(' + (s + 2) + 'px, -' + (s + 2) + 'px, ' + s + 'px) rotateX(180deg) rotateZ(180deg)',
                u: 'translate3d(-' + (s + 2) + 'px, -' + s + 'px, ' + (s + 2) + 'px) rotateX(270deg)',
                d: 'translate3d(-' + (s + 2) + 'px, ' + s + 'px, -' + (s + 2) + 'px) rotateX(90deg)',
                l: 'translate3d(-' + s + 'px, -' + (s + 2) + 'px, ' + (s + 2) + 'px) rotateX(180deg) rotateY(90deg) rotateZ(180deg)',
                r: 'translate3d(' + s + 'px, -' + (s + 2) + 'px, -' + (s + 2) + 'px) rotateY(270deg)'
            };
            focal = 1 / Math.tan(hfov / 2);
            var zoom = focal * canvas.width / (window.devicePixelRatio || 1) / 2 + 'px';
            var transform = 'perspective(' + zoom + ') translateZ(' + zoom + ') rotateX(' + pitch + 'rad) rotateY(' + yaw + 'rad) ';
            
            // Apply face transforms
            var faces = Object.keys(transforms);
            for (i = 0; i < 6; i++) {
                var face = Polymer.dom(world).querySelector('.pnlm-' + faces[i] + 'face').style;
                face.webkitTransform = transform + transforms[faces[i]];
                face.transform = transform + transforms[faces[i]];
            }
            return;
        }
        
        if (imageType != 'multires') {
            // Calculate focal length from vertical field of view
            var vfov = 2 * Math.atan(Math.tan(hfov * 0.5) / (canvas.width / canvas.height));
            focal = 1 / Math.tan(vfov * 0.5);

            // Pass psi, theta, roll, and focal length
            gl.uniform1f(program.psi, yaw);
            gl.uniform1f(program.theta, pitch);
            gl.uniform1f(program.rot, roll);
            gl.uniform1f(program.f, focal);
            
            if (dynamic === true) {
                // Update texture if dynamic
                if (imageType == 'equirectangular') {
                    gl.bindTexture(gl.TEXTURE_2D, program.texture);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image);
                }
            }
            
            // Draw using current buffer
            gl.drawArrays(gl.TRIANGLES, 0, 6);
        
        } else {
            // Create perspective matrix
            var perspMatrix = makePersp(hfov, canvas.width / canvas.height, 0.1, 100.0);
            
            // Find correct zoom level
            checkZoom(hfov);
            
            // Create rotation matrix
            var matrix = identityMatrix3();
            matrix = rotateMatrix(matrix, -roll, 'z');
            matrix = rotateMatrix(matrix, -pitch, 'x');
            matrix = rotateMatrix(matrix, yaw, 'y');
            matrix = makeMatrix4(matrix);
            
            // Set matrix uniforms
            gl.uniformMatrix4fv(program.perspUniform, false, new Float32Array(transposeMatrix4(perspMatrix)));
            gl.uniformMatrix4fv(program.cubeUniform, false, new Float32Array(transposeMatrix4(matrix)));
            
            // Find current nodes
            var rotPersp = rotatePersp(perspMatrix, matrix);
            program.nodeCache.sort(multiresNodeSort);
            if (program.nodeCache.length > 200 &&
                program.nodeCache.length > program.currentNodes.length + 50) {
                // Remove older nodes from cache
                var removed = program.nodeCache.splice(200, program.nodeCache.length - 200);
                for (var i = 0; i < removed.length; i++) {
                    // Explicitly delete textures
                    gl.deleteTexture(removed[i].texture);
                }
            }
            program.currentNodes = [];
            
            var sides = ['f', 'b', 'u', 'd', 'l', 'r'];
            for (s = 0; s < 6; s++) {
                var ntmp = new MultiresNode(vtmps[s], sides[s], 1, 0, 0, image.fullpath);
                testMultiresNode(rotPersp, ntmp, pitch, yaw, hfov);
            }
            program.currentNodes.sort(multiresNodeRenderSort);
            // Only process one tile per frame to improve responsiveness
            for (i = 0; i < program.currentNodes.length; i++) {
                if (!program.currentNodes[i].texture) {
                    setTimeout(processNextTile(program.currentNodes[i]), 0);
                    break;
                }
            }
            
            // Draw tiles
            multiresDraw();
        }
        
        if (params.returnImage !== undefined) {
            return canvas.toDataURL('image/png');
        }
    };
    
    /**
     * Check if images are loading.
     * @memberof Renderer
     * @instance
     * @returns {boolean} Whether or not images are loading.
     */
    this.isLoading = function() {
        if (gl && imageType == 'multires') {
            for ( var i = 0; i < program.currentNodes.length; i++ ) {
                if (!program.currentNodes[i].textureLoaded) {
                    return true;
                }
            }
        }
        return false;
    };
    
    /**
     * Retrieve renderer's canvas.
     * @memberof Renderer
     * @instance
     * @returns {HTMLElement} Renderer's canvas.
     */
    this.getCanvas = function() {
        return canvas;
    };
    
    /**
     * Sorting method for multires nodes.
     * @private
     * @param {MultiresNode} a - First node.
     * @param {MultiresNode} b - Second node.
     * @returns {number} Base tiles first, then higher timestamp first.
     */
    function multiresNodeSort(a, b) {
        // Base tiles are always first
        if (a.level == 1 && b.level != 1) {
            return -1;
        }
        if (b. level == 1 && a.level != 1) {
            return 1;
        }
        
        // Higher timestamp first
        return b.timestamp - a.timestamp;
    }
    
    /**
     * Sorting method for multires node rendering.
     * @private
     * @param {MultiresNode} a - First node.
     * @param {MultiresNode} b - Second node.
     * @returns {number} Lower zoom levels first, then closest to center first.
     */
    function multiresNodeRenderSort(a, b) {
        // Lower zoom levels first
        if (a.level != b.level) {
            return a.level - b.level;
        }
        
        // Lower distance from center first
        return a.diff - b.diff;
    }
    
    /**
     * Draws multires nodes.
     * @private
     */
    function multiresDraw() {
        if (!program.drawInProgress) {
            program.drawInProgress = true;
            for ( var i = 0; i < program.currentNodes.length; i++ ) {
                if (program.currentNodes[i].textureLoaded) {
                    //var color = program.currentNodes[i].color;
                    //gl.uniform4f(program.colorUniform, color[0], color[1], color[2], 1.0);
                    
                    // Bind vertex buffer and pass vertices to WebGL
                    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertBuf);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(program.currentNodes[i].vertices), gl.STATIC_DRAW);
                    gl.vertexAttribPointer(program.vertPosLocation, 3, gl.FLOAT, false, 0, 0);
                    
                    // Prep for texture
                    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertTexCoordBuf);
                    gl.vertexAttribPointer(program.texCoordLocation, 2, gl.FLOAT, false, 0, 0);
                    
                    // Bind texture and draw tile
                    gl.bindTexture(gl.TEXTURE_2D, program.currentNodes[i].texture); // Bind program.currentNodes[i].texture to TEXTURE0
                    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
                }
            }
            program.drawInProgress = false;
        }
    }

    /**
     * Creates new multires node.
     * @constructor
     * @private
     * @param {number[]} vertices - Node's verticies.
     * @param {string} side - Node's cube face.
     * @param {number} level - Node's zoom level.
     * @param {number} x - Node's x position.
     * @param {number} y - Node's y position.
     * @param {string} path - Node's path.
     */
    function MultiresNode(vertices, side, level, x, y, path) {
        this.vertices = vertices;
        this.side = side;
        this.level = level;
        this.x = x;
        this.y = y;
        this.path = path.replace('%s',side).replace('%l',level).replace('%x',x).replace('%y',y);
    }

    /**
     * Test if multires node is visible. If it is, add it to current nodes,
     * load its texture, and load appropriate child nodes.
     * @private
     * @param {number[]} rotPersp - Rotated perspective matrix.
     * @param {MultiresNode} node - Multires node to check.
     * @param {number} pitch - Pitch to check at.
     * @param {number} yaw - Yaw to check at.
     * @param {number} hfov - Horizontal field of view to check at.
     */
    function testMultiresNode(rotPersp, node, pitch, yaw, hfov) {
        if (checkSquareInView(rotPersp, node.vertices)) {
            // Calculate central angle between center of view and center of tile
            var v = node.vertices;
            var x = v[0] + v[3] + v[6] + v[ 9];
            var y = v[1] + v[4] + v[7] + v[10];
            var z = v[2] + v[5] + v[8] + v[11];
            var r = Math.sqrt(x*x + y*y + z*z);
            var theta = Math.asin(z / r);
            var phi = Math.atan2(y, x);
            var ydiff = phi - yaw;
            ydiff += (ydiff > Math.PI) ? -2 * Math.PI : (ydiff < -Math.PI) ? 2 * Math.PI : 0;
            ydiff = Math.abs(ydiff);
            node.diff = Math.acos(Math.sin(pitch) * Math.sin(theta) + Math.cos(pitch) * Math.cos(theta) * Math.cos(ydiff));
            
            // Add node to current nodes and load texture if needed
            var inCurrent = false;
            for (var k = 0; k < program.nodeCache.length; k++) {
                if (program.nodeCache[k].path == node.path) {
                    inCurrent = true;
                    program.nodeCache[k].timestamp = program.nodeCacheTimestamp++;
                    program.nodeCache[k].diff = node.diff;
                    program.currentNodes.push(program.nodeCache[k]);
                    break;
                }
            }
            if (!inCurrent) {
                //node.color = [Math.random(), Math.random(), Math.random()];
                node.timestamp = program.nodeCacheTimestamp++;
                program.currentNodes.push(node);
                program.nodeCache.push(node);
            }
            
            // TODO: Test error
            // Create child nodes
            if (node.level < program.level) {
                var cubeSize = image.cubeResolution * Math.pow(2, node.level - image.maxLevel);
                var numTiles = Math.ceil(cubeSize * image.invTileResolution) - 1;
                var doubleTileSize = cubeSize % image.tileResolution * 2;
                var lastTileSize = (cubeSize * 2) % image.tileResolution;
                if (lastTileSize === 0) {
                    lastTileSize = image.tileResolution;
                }
                if (doubleTileSize === 0) {
                    doubleTileSize = image.tileResolution * 2;
                }
                var f = 0.5;
                if (node.x == numTiles || node.y == numTiles) {
                    f = 1.0 - image.tileResolution / (image.tileResolution + lastTileSize);
                }
                var i = 1.0 - f;
                var children = [];
                var vtmp, ntmp;
                var f1 = f, f2 = f, f3 = f, i1 = i, i2 = i, i3 = i;
                // Handle non-symmetric tiles
                if (lastTileSize < image.tileResolution) {
                    if (node.x == numTiles && node.y != numTiles) {
                        f2 = 0.5;
                        i2 = 0.5;
                        if (node.side == 'd' || node.side == 'u') {
                            f3 = 0.5;
                            i3 = 0.5;
                        }
                    } else if (node.x != numTiles && node.y == numTiles) {
                        f1 = 0.5;
                        i1 = 0.5;
                        if (node.side == 'l' || node.side == 'r') {
                            f3 = 0.5;
                            i3 = 0.5;
                        }
                    }
                }
                // Handle small tiles that have fewer than four children
                if (doubleTileSize <= image.tileResolution) {
                    if (node.x == numTiles) {
                        f1 = 0;
                        i1 = 1;
                        if (node.side == 'l' || node.side == 'r') {
                            f3 = 0;
                            i3 = 1;
                        }
                    }
                    if (node.y == numTiles) {
                        f2 = 0;
                        i2 = 1;
                        if (node.side == 'd' || node.side == 'u') {
                            f3 = 0;
                            i3 = 1;
                        }
                    }
                }
                
                vtmp = [           v[0],             v[1],             v[2],
                        v[0]*f1+v[3]*i1,    v[1]*f+v[4]*i,  v[2]*f3+v[5]*i3,
                        v[0]*f1+v[6]*i1,  v[1]*f2+v[7]*i2,  v[2]*f3+v[8]*i3,
                          v[0]*f+v[9]*i, v[1]*f2+v[10]*i2, v[2]*f3+v[11]*i3
                ];
                ntmp = new MultiresNode(vtmp, node.side, node.level + 1, node.x*2, node.y*2, image.fullpath);
                children.push(ntmp);
                if (!(node.x == numTiles && doubleTileSize <= image.tileResolution)) {
                    vtmp = [v[0]*f1+v[3]*i1,    v[1]*f+v[4]*i,  v[2]*f3+v[5]*i3,
                                       v[3],             v[4],             v[5],
                              v[3]*f+v[6]*i,  v[4]*f2+v[7]*i2,  v[5]*f3+v[8]*i3,
                            v[0]*f1+v[6]*i1,  v[1]*f2+v[7]*i2,  v[2]*f3+v[8]*i3
                    ];
                    ntmp = new MultiresNode(vtmp, node.side, node.level + 1, node.x*2+1, node.y*2, image.fullpath);
                    children.push(ntmp);
                }
                if (!(node.x == numTiles && doubleTileSize <= image.tileResolution) &&
                    !(node.y == numTiles && doubleTileSize <= image.tileResolution)) {
                    vtmp = [v[0]*f1+v[6]*i1,  v[1]*f2+v[7]*i2,  v[2]*f3+v[8]*i3,
                              v[3]*f+v[6]*i,  v[4]*f2+v[7]*i2,  v[5]*f3+v[8]*i3,
                                       v[6],             v[7],             v[8],
                            v[9]*f1+v[6]*i1,   v[10]*f+v[7]*i, v[11]*f3+v[8]*i3
                    ];
                    ntmp = new MultiresNode(vtmp, node.side, node.level + 1, node.x*2+1, node.y*2+1, image.fullpath);
                    children.push(ntmp);
                }
                if (!(node.y == numTiles && doubleTileSize <= image.tileResolution)) {
                    vtmp = [  v[0]*f+v[9]*i, v[1]*f2+v[10]*i2, v[2]*f3+v[11]*i3,
                            v[0]*f1+v[6]*i1,  v[1]*f2+v[7]*i2,  v[2]*f3+v[8]*i3,
                            v[9]*f1+v[6]*i1,   v[10]*f+v[7]*i, v[11]*f3+v[8]*i3,
                                       v[9],            v[10],            v[11]
                    ];
                    ntmp = new MultiresNode(vtmp, node.side, node.level + 1, node.x*2, node.y*2+1, image.fullpath);
                    children.push(ntmp);
                }
                for (var j = 0; j < children.length; j++) {
                    testMultiresNode(rotPersp, children[j], pitch, yaw, hfov);
                }
            }
        }
    }
    
    /**
     * Creates cube vertex array.
     * @private
     * @returns {number[]} Cube vertex array.
     */
    function createCube() {
        return [-1,  1, -1,  1,  1, -1,  1, -1, -1, -1, -1, -1, // Front face
                 1,  1,  1, -1,  1,  1, -1, -1,  1,  1, -1,  1, // Back face
                -1,  1,  1,  1,  1,  1,  1,  1, -1, -1,  1, -1, // Up face
                -1, -1, -1,  1, -1, -1,  1, -1,  1, -1, -1,  1, // Down face
                -1,  1,  1, -1,  1, -1, -1, -1, -1, -1, -1,  1, // Left face
                 1,  1, -1,  1,  1,  1,  1, -1,  1,  1, -1, -1  // Right face
        ];
    }
    
    /**
     * Creates 3x3 identity matrix.
     * @private
     * @returns {number[]} Identity matrix.
     */
    function identityMatrix3() {
        return [
            1, 0, 0,
            0, 1, 0,
            0, 0, 1
        ];
    }
    
    /**
     * Rotates a 3x3 matrix.
     * @private
     * @param {number[]} m - Matrix to rotate.
     * @param {number[]} angle - Angle to rotate by in radians.
     * @param {string} axis - Axis to rotate about (`x`, `y`, or `z`).
     * @returns {number[]} Rotated matrix.
     */
    function rotateMatrix(m, angle, axis) {
        var s = Math.sin(angle);
        var c = Math.cos(angle);
        if (axis == 'x') {
            return [
                m[0], c*m[1] + s*m[2], c*m[2] - s*m[1],
                m[3], c*m[4] + s*m[5], c*m[5] - s*m[4],
                m[6], c*m[7] + s*m[8], c*m[8] - s*m[7]
            ];
        }
        if (axis == 'y') {
            return [
                c*m[0] - s*m[2], m[1], c*m[2] + s*m[0],
                c*m[3] - s*m[5], m[4], c*m[5] + s*m[3],
                c*m[6] - s*m[8], m[7], c*m[8] + s*m[6]
            ];
        }
        if (axis == 'z') {
            return [
                c*m[0] + s*m[1], c*m[1] - s*m[0], m[2],
                c*m[3] + s*m[4], c*m[4] - s*m[3], m[5],
                c*m[6] + s*m[7], c*m[7] - s*m[6], m[8]
            ];
        }
    }
    
    /**
     * Turns a 3x3 matrix into a 4x4 matrix.
     * @private
     * @param {number[]} m - Input matrix.
     * @returns {number[]} Expanded matrix.
     */
    function makeMatrix4(m) {
        return [
            m[0], m[1], m[2],    0,
            m[3], m[4], m[5],    0,
            m[6], m[7], m[8],    0,
               0,    0,    0,    1
        ];
    }
    
    /**
     * Transposes a 4x4 matrix.
     * @private
     * @param {number[]} m - Input matrix.
     * @returns {number[]} Transposed matrix.
     */
    function transposeMatrix4(m) {
        return [
            m[ 0], m[ 4], m[ 8], m[12],
            m[ 1], m[ 5], m[ 9], m[13],
            m[ 2], m[ 6], m[10], m[14],
            m[ 3], m[ 7], m[11], m[15]
        ];
    }
    
    /**
     * Creates a perspective matrix.
     * @private
     * @param {number} hfov - Desired horizontal field of view.
     * @param {number} aspect - Desired aspect ratio.
     * @param {number} znear - Near distance.
     * @param {number} zfar - Far distance.
     * @returns {number[]} Generated perspective matrix.
     */
    function makePersp(hfov, aspect, znear, zfar) {
        var fovy = 2 * Math.atan(Math.tan(hfov/2) * canvas.height / canvas.width);
        var f = 1 / Math.tan(fovy/2);
        return [
            f/aspect,   0,  0,  0,
                   0,   f,  0,  0,
                   0,   0,  (zfar+znear)/(znear-zfar), (2*zfar*znear)/(znear-zfar),
                   0,   0, -1,  0
        ];
    }
    
    /**
     * Processes a loaded texture image into a WebGL texture.
     * @private
     * @param {Image} img - Input image.
     * @param {WebGLTexture} tex - Texture to bind image to.
     */
    function processLoadedTexture(img, tex) {
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, img);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.bindTexture(gl.TEXTURE_2D, null);
    }

    // Based on http://blog.tojicode.com/2012/03/javascript-memory-optimization-and.html
    var loadTexture = (function() {
        var cacheTop = 4;   // Maximum number of concurrents loads
        var textureImageCache = {};
        var pendingTextureRequests = [];

        function TextureImageLoader() {
            var self = this;
            this.texture = this.callback = null;
            this.image = new Image();
            this.image.crossOrigin = 'anonymous';
            this.image.addEventListener('load', function() {
                processLoadedTexture(self.image, self.texture);
                self.callback(self.texture);
                releaseTextureImageLoader(self);
            });
        };

        TextureImageLoader.prototype.loadTexture = function(src, texture, callback) {
            this.texture = texture;
            this.callback = callback;
            this.image.src = src;
        };

        function PendingTextureRequest(src, texture, callback) {
            this.src = src;
            this.texture = texture;
            this.callback = callback;
        };

        function releaseTextureImageLoader(til) {
            if (pendingTextureRequests.length) {
                var req = pendingTextureRequests.shift();
                til.loadTexture(req.src, req.texture, req.callback);
            } else
                textureImageCache[cacheTop++] = til;
        }

        for (var i = 0; i < cacheTop; i++)
            textureImageCache[i] = new TextureImageLoader();

        return function(src, callback) {
            var texture = gl.createTexture();
            if (cacheTop)
                textureImageCache[--cacheTop].loadTexture(src, texture, callback);
            else
                pendingTextureRequests.push(new PendingTextureRequest(src, texture, callback));
            return texture;
        };
    })();

    /**
     * Loads image and creates texture for a multires node / tile.
     * @private
     * @param {MultiresNode} node - Input node.
     */
    function processNextTile(node) {
        if (!node.textureLoad) {
            node.textureLoad = true;
            loadTexture(encodeURI(node.path + '.' + image.extension), function(texture) {
                node.texture = texture;
                node.textureLoaded = true;
            });
        }
    }
    
    /**
     * Finds and applies optimal multires zoom level.
     * @private
     * @param {number} hfov - Horizontal field of view to check at.
     */
    function checkZoom(hfov) {
        // Find optimal level
        var newLevel = 1;
        while ( newLevel < image.maxLevel &&
            canvas.width > image.tileResolution *
            Math.pow(2, newLevel - 1) * Math.tan(hfov / 2) * 0.707 ) {
            newLevel++;
        }
        
        // Apply change
        program.level = newLevel;
    }
    
    /**
     * Rotates perspective matrix.
     * @private
     * @param {number[]} p - Perspective matrix.
     * @param {number[]} r - Rotation matrix.
     * @returns {number[]} Rotated matrix.
     */
    function rotatePersp(p, r) {
        return [
            p[ 0]*r[0], p[ 0]*r[1], p[ 0]*r[ 2],     0,
            p[ 5]*r[4], p[ 5]*r[5], p[ 5]*r[ 6],     0,
            p[10]*r[8], p[10]*r[9], p[10]*r[10], p[11],
                 -r[8],      -r[9],      -r[10],     0
        ];
    }
    
    /**
     * Applies rotated perspective matrix to a 3-vector
     * (last element is inverted).
     * @private
     * @param {number[]} m - Rotated perspective matrix.
     * @param {number[]} v - Input 3-vector.
     * @returns {number[]} Resulting 4-vector.
     */
    function applyRotPerspToVec(m, v) {
        return [
                    m[ 0]*v[0] + m[ 1]*v[1] + m[ 2]*v[2],
                    m[ 4]*v[0] + m[ 5]*v[1] + m[ 6]*v[2],
            m[11] + m[ 8]*v[0] + m[ 9]*v[1] + m[10]*v[2],
                 1/(m[12]*v[0] + m[13]*v[1] + m[14]*v[2])
        ];
    }
    
    /**
     * Checks if a vertex is visible.
     * @private
     * @param {number[]} m - Rotated perspective matrix.
     * @param {number[]} v - Input vertex.
     * @returns {number} 1 or -1 if the vertex is or is not visible,
     *      respectively.
     */
    function checkInView(m, v) {
        var vpp = applyRotPerspToVec(m, v);
        var winX = vpp[0]*vpp[3];
        var winY = vpp[1]*vpp[3];
        var winZ = vpp[2]*vpp[3];
        var ret = [0, 0, 0];
        
        if ( winX < -1 )
            ret[0] = -1;
        if ( winX > 1 )
            ret[0] = 1;
        if ( winY < -1 )
            ret[1] = -1;
        if ( winY > 1 )
            ret[1] = 1;
        if ( winZ < -1 || winZ > 1 )
            ret[2] = 1;
        return ret;
    }
    
    /**
     * Checks if a square (tile) is visible.
     * @private
     * @param {number[]} m - Rotated perspective matrix.
     * @param {number[]} v - Square's vertex array.
     * @returns {boolean} Whether or not the square is visible.
     */
    function checkSquareInView(m, v) {
        var check1 = checkInView(m, v.slice(0, 3));
        var check2 = checkInView(m, v.slice(3, 6));
        var check3 = checkInView(m, v.slice(6, 9));
        var check4 = checkInView(m, v.slice(9, 12));
        var testX = check1[0] + check2[0] + check3[0] + check4[0];
        if ( testX == -4 || testX == 4 )
            return false;
        var testY = check1[1] + check2[1] + check3[1] + check4[1];
        if ( testY == -4 || testY == 4 )
            return false;
        var testZ = check1[2] + check2[2] + check3[2] + check4[2];
        return testZ != 4;
        

    }
}

// Vertex shader for equirectangular and cube
var v = [
'attribute vec2 a_texCoord;',
'varying vec2 v_texCoord;',

'void main() {',
    // Set position
    'gl_Position = vec4(a_texCoord, 0.0, 1.0);',
    
    // Pass the coordinates to the fragment shader
    'v_texCoord = a_texCoord;',
'}'
].join('');

// Vertex shader for multires
var vMulti = [
'attribute vec3 a_vertCoord;',
'attribute vec2 a_texCoord;',

'uniform mat4 u_cubeMatrix;',
'uniform mat4 u_perspMatrix;',

'varying mediump vec2 v_texCoord;',

'void main(void) {',
    // Set position
    'gl_Position = u_perspMatrix * u_cubeMatrix * vec4(a_vertCoord, 1.0);',
    
    // Pass the coordinates to the fragment shader
    'v_texCoord = a_texCoord;',
'}'
].join('');

// Fragment shader
var fragEquiCubeBase = [
'precision mediump float;',

'uniform float u_aspectRatio;',
'uniform float u_psi;',
'uniform float u_theta;',
'uniform float u_f;',
'uniform float u_h;',
'uniform float u_v;',
'uniform float u_vo;',
'uniform float u_rot;',

'const float PI = 3.14159265358979323846264;',

// Texture
'uniform sampler2D u_image;',
'uniform samplerCube u_imageCube;',

// Coordinates passed in from vertex shader
'varying vec2 v_texCoord;',

// Background color (display for partial panoramas)
'uniform vec4 u_backgroundColor;',

'void main() {',
    // Map canvas/camera to sphere
    'float x = v_texCoord.x * u_aspectRatio;',
    'float y = v_texCoord.y;',
    'float sinrot = sin(u_rot);',
    'float cosrot = cos(u_rot);',
    'float rot_x = x * cosrot - y * sinrot;',
    'float rot_y = x * sinrot + y * cosrot;',
    'float sintheta = sin(u_theta);',
    'float costheta = cos(u_theta);',
    'float a = u_f * costheta - rot_y * sintheta;',
    'float root = sqrt(rot_x * rot_x + a * a);',
    'float lambda = atan(rot_x / root, a / root) + u_psi;',
    'float phi = atan((rot_y * costheta + u_f * sintheta) / root);',
].join('\n');

// Fragment shader
var fragCube = fragEquiCubeBase + [
    // Look up color from texture
    'float cosphi = cos(phi);',
    'gl_FragColor = textureCube(u_imageCube, vec3(cosphi*sin(lambda), sin(phi), cosphi*cos(lambda)));',
'}'
].join('\n');

// Fragment shader
var fragEquirectangular = fragEquiCubeBase + [
    // Wrap image
    'lambda = mod(lambda + PI, PI * 2.0) - PI;',

    // Map texture to sphere
    'vec2 coord = vec2(lambda / PI, phi / (PI / 2.0));',

    // Look up color from texture
    // Map from [-1,1] to [0,1] and flip y-axis
    'if(coord.x < -u_h || coord.x > u_h || coord.y < -u_v + u_vo || coord.y > u_v + u_vo)',
        'gl_FragColor = u_backgroundColor;',
    'else',
        'gl_FragColor = texture2D(u_image, vec2((coord.x + u_h) / (u_h * 2.0), (-coord.y + u_v + u_vo) / (u_v * 2.0)));',
'}'
].join('\n');

// Fragment shader
var fragMulti = [
'varying mediump vec2 v_texCoord;',
'uniform sampler2D u_sampler;',
//'uniform mediump vec4 u_color;',

'void main(void) {',
    // Look up color from texture
    'gl_FragColor = texture2D(u_sampler, v_texCoord);',
//    'gl_FragColor = u_color;',
'}'
].join('');

return {
    renderer: function(container, image, imagetype, dynamic) {
        return new Renderer(container, image, imagetype, dynamic);
    }
};

})(window, document);
</script>
<script type="text/javascript">/**
 * Provides requestAnimationFrame in a cross browser way.
 * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
 */

if ( !window.requestAnimationFrame ) {

    window.requestAnimationFrame = ( function() {

        return window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function( /* function FrameRequestCallback */ callback, /* DOMElement Element */ element ) {

            window.setTimeout( callback, 1000 / 60 );

        };

    } )();

}
</script>
<script type="text/javascript">/*
 * Pannellum - An HTML5 based Panorama Viewer
 * Copyright (c) 2011-2016 Matthew Petroff
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

window.pannellum = (function(window, document, undefined) {

'use strict';

/**
 * Creates a new panorama viewer.
 * @constructor
 * @param {HTMLElement|string} container - The container (div) element for the
 *      viewer, or its ID.
 * @param {Object} initialConfig - Inital configuration for viewer.
 */
function Viewer(container, initialConfig) {

var _this = this;

// Declare variables
var config,
    renderer,
    preview,
    isUserInteracting = false,
    latestInteraction = Date.now(),
    onPointerDownPointerX = 0,
    onPointerDownPointerY = 0,
    onPointerDownPointerDist = -1,
    onPointerDownYaw = 0,
    onPointerDownPitch = 0,
    keysDown = new Array(10),
    fullscreenActive = false,
    loaded = false,
    error = false,
    isTimedOut = false,
    listenersAdded = false,
    panoImage,
    prevTime,
    speed = {'yaw': 0, 'pitch': 0, 'hfov': 0},
    animating = false,
    orientation = false,
    autoRotateStart,
    autoRotateSpeed = 0,
    origHfov,
    origPitch,
    animatedMove = {},
    externalEventListeners = {},
    specifiedPhotoSphereExcludes = [],
    update = false, // Should we update when still to render dynamic content
    hotspotsCreated = false;

var defaultConfig = {
    hfov: 100,
    minHfov: 50,
    maxHfov: 120,
    pitch: 0,
    minPitch: undefined,
    maxPitch: undefined,
    yaw: 0,
    minYaw: -180,
    maxYaw: 180,
    roll: 0,
    haov: 360,
    vaov: 180,
    vOffset: 0,
    autoRotate: false,
    autoRotateInactivityDelay: -1,
    autoRotateStopDelay: undefined,
    type: 'equirectangular',
    northOffset: 0,
    showFullscreenCtrl: true,
    dynamic: false,
    keyboardZoom: true,
    mouseZoom: true,
    showZoomCtrl: true,
    autoLoad: false,
    showControls: true,
    orientationOnByDefault: false,
    hotSpotDebug: false,
    backgroundColor: [0, 0, 0],
};

// Initialize container
container = typeof container === 'string' ? document.getElementById(container) : container;
container.classList.add('pnlm-container');
container.tabIndex = 0;

// Create container for renderer
var renderContainer = document.createElement('div');
renderContainer.className = 'pnlm-render-container';
Polymer.dom(container).appendChild(renderContainer);
var dragFix = document.createElement('div');
dragFix.className = 'pnlm-dragfix';
Polymer.dom(container).appendChild(dragFix);

// Display about information on right click
var aboutMsg = document.createElement('span');
aboutMsg.className = 'pnlm-about-msg';
aboutMsg.innerHTML = '<a href="https://pannellum.org/" target="_blank">Pannellum</a>';
Polymer.dom(container).appendChild(aboutMsg);
dragFix.addEventListener('contextmenu', aboutMessage);

// Create info display
var infoDisplay = {};

// Hot spot debug indicator
var hotSpotDebugIndicator = document.createElement('div');
hotSpotDebugIndicator.className = 'pnlm-sprite pnlm-hot-spot-debug-indicator';
Polymer.dom(container).appendChild(hotSpotDebugIndicator);

// Panorama info
infoDisplay.container = document.createElement('div');
infoDisplay.container.className = 'pnlm-panorama-info';
infoDisplay.title = document.createElement('div');
infoDisplay.title.className = 'pnlm-title-box';
Polymer.dom(infoDisplay.container).appendChild(infoDisplay.title);
infoDisplay.author = document.createElement('div');
infoDisplay.author.className = 'pnlm-author-box';
Polymer.dom(infoDisplay.container).appendChild(infoDisplay.author);
Polymer.dom(container).appendChild(infoDisplay.container);

// Load box
infoDisplay.load = {};
infoDisplay.load.box = document.createElement('div');
infoDisplay.load.box.className = 'pnlm-load-box';
infoDisplay.load.box.innerHTML = '<p>Loading...</p>';
infoDisplay.load.lbox = document.createElement('div');
infoDisplay.load.lbox.className = 'pnlm-lbox';
infoDisplay.load.lbox.innerHTML = '<div class="pnlm-loading"></div>';
Polymer.dom(infoDisplay.load.box).appendChild(infoDisplay.load.lbox);
infoDisplay.load.lbar = document.createElement('div');
infoDisplay.load.lbar.className = 'pnlm-lbar';
infoDisplay.load.lbarFill = document.createElement('div');
infoDisplay.load.lbarFill.className = 'pnlm-lbar-fill';
Polymer.dom(infoDisplay.load.lbar).appendChild(infoDisplay.load.lbarFill);
Polymer.dom(infoDisplay.load.box).appendChild(infoDisplay.load.lbar);
infoDisplay.load.msg = document.createElement('p');
infoDisplay.load.msg.className = 'pnlm-lmsg';
Polymer.dom(infoDisplay.load.box).appendChild(infoDisplay.load.msg);
Polymer.dom(container).appendChild(infoDisplay.load.box);

// Error message
infoDisplay.errorMsg = document.createElement('div');
infoDisplay.errorMsg.className = 'pnlm-error-msg pnlm-info-box';
Polymer.dom(container).appendChild(infoDisplay.errorMsg);

// Create controls
var controls = {};
controls.container = document.createElement('div');
controls.container.className = 'pnlm-controls-container';
Polymer.dom(container).appendChild(controls.container);

// Load button
controls.load = document.createElement('div');
controls.load.className = 'pnlm-load-button';
controls.load.innerHTML = '<p>Click to<br>Load<br>Panorama<p>';
controls.load.addEventListener('click', load);
Polymer.dom(container).appendChild(controls.load);

// Zoom controls
controls.zoom = document.createElement('div');
controls.zoom.className = 'pnlm-zoom-controls pnlm-controls';
controls.zoomIn = document.createElement('div');
controls.zoomIn.className = 'pnlm-zoom-in pnlm-sprite pnlm-control';
controls.zoomIn.addEventListener('click', zoomIn);
Polymer.dom(controls.zoom).appendChild(controls.zoomIn);
controls.zoomOut = document.createElement('div');
controls.zoomOut.className = 'pnlm-zoom-out pnlm-sprite pnlm-control';
controls.zoomOut.addEventListener('click', zoomOut);
Polymer.dom(controls.zoom).appendChild(controls.zoomOut);
Polymer.dom(controls.container).appendChild(controls.zoom);

// Fullscreen toggle
controls.fullscreen = document.createElement('div');
controls.fullscreen.addEventListener('click', toggleFullscreen);
controls.fullscreen.className = 'pnlm-fullscreen-toggle-button pnlm-sprite pnlm-fullscreen-toggle-button-inactive pnlm-controls pnlm-control';
if (document.fullscreenEnabled || document.mozFullScreenEnabled || document.webkitFullscreenEnabled || document.msFullscreenEnabled)
    Polymer.dom(controls.container).appendChild(controls.fullscreen);

// Device orientation toggle
controls.orientation = document.createElement('div');
controls.orientation.addEventListener('click', function(e) {
    if (orientation)
        stopOrientation();
    else
        startOrientation();
});
controls.orientation.addEventListener('mousedown', function(e) {e.stopPropagation();});
controls.orientation.addEventListener('touchstart', function(e) {e.stopPropagation();});
controls.orientation.addEventListener('pointerdown', function(e) {e.stopPropagation();});
controls.orientation.className = 'pnlm-orientation-button pnlm-orientation-button-inactive pnlm-sprite pnlm-controls pnlm-control';
if (window.DeviceOrientationEvent) {
    window.addEventListener('deviceorientation', function(e) {
        window.removeEventListener('deviceorientation', this);
        if (e && e.alpha !== null && e.beta !== null && e.gamma !== null)
            Polymer.dom(controls.container).appendChild(controls.orientation);
    });
}

// Compass
var compass = document.createElement('div');
compass.className = 'pnlm-compass pnlm-controls pnlm-control';
Polymer.dom(container).appendChild(compass);

// Load and process configuration
if (initialConfig.firstScene) {
    // Activate first scene if specified in URL
    mergeConfig(initialConfig.firstScene);
} else if (initialConfig.default && initialConfig.default.firstScene) {
    // Activate first scene if specified in file
    mergeConfig(initialConfig.default.firstScene);
} else {
    mergeConfig(null);
}
processOptions();

/**
 * Initializes viewer.
 * @private
 */
function init() {
    // Display an error for IE 9 as it doesn't work but also doesn't otherwise
    // show an error (older versions don't work at all)
    // Based on: http://stackoverflow.com/a/10965203
    var div = document.createElement("div");
    div.innerHTML = "\x3c!--[if lte IE 9]><i></i><![endif]--\x3e";
    if (div.getElementsByTagName("i").length == 1) {
        anError();
        return;
    }

    origHfov = config.hfov;
    origPitch = config.pitch;

    var i, p;
    
    if (config.type == 'cubemap') {
        panoImage = [];
        for (i = 0; i < 6; i++) {
            panoImage.push(new Image());
            panoImage[i].crossOrigin = 'anonymous';
        }
        infoDisplay.load.lbox.style.display = 'block';
        infoDisplay.load.lbar.style.display = 'none';
    } else if (config.type == 'multires') {
        var c = JSON.parse(JSON.stringify(config.multiRes));    // Deep copy
        // Avoid "undefined" in path, check (optional) multiRes.basePath, too
        // Use only multiRes.basePath if it's an absolute URL
        if (config.basePath && config.multiRes.basePath &&
            !(/^(?:[a-z]+:)?\/\//i.test(config.multiRes.basePath))) {
            c.basePath = config.basePath + config.multiRes.basePath;
        } else if (config.multiRes.basePath) {
            c.basePath = config.multiRes.basePath;
        } else if(config.basePath) {
            c.basePath = config.basePath;
        }
        panoImage = c;
    } else {
        if (config.dynamic === true) {
            panoImage = config.panorama;
        } else {
            if (config.panorama === undefined) {
                anError('No panorama image was specified.');
                return;
            }
            panoImage = new Image();
        }
    }

    // Configure image loading
    if (config.type == 'cubemap') {
        // Quick loading counter for synchronous loading
        var itemsToLoad = 6;
        
        var onLoad = function() {
            itemsToLoad--;
            if (itemsToLoad === 0) {
                onImageLoad();
            }
        };
        
        var onError = function(e) {
            var a = document.createElement('a');
            a.href = e.target.src;
            a.innerHTML = a.href;
            anError('The file ' + a.outerHTML + ' could not be accessed.');
        };
        
        for (i = 0; i < panoImage.length; i++) {
            panoImage[i].onload = onLoad;
            panoImage[i].onerror = onError;
            p = config.cubeMap[i];
            if (config.basePath && !absoluteURL(p)) {
                p = config.basePath + p;
            }
            panoImage[i].src = encodeURI(p);
        }
    } else if (config.type == 'multires') {
        onImageLoad();
    } else {
        p = '';
        if (config.basePath) {
            p = config.basePath;
        }
        
        if (config.dynamic !== true) {
            // Still image
            p = absoluteURL(config.panorama) ? config.panorama : p + config.panorama;
            
            panoImage.onload = function() {
                window.URL.revokeObjectURL(this.src);  // Clean up
                onImageLoad();
            };
            
            var xhr = new XMLHttpRequest();
            xhr.onloadend = function() {
                if (xhr.status != 200) {
                    // Display error if image can't be loaded
                    var a = document.createElement('a');
                    a.href = encodeURI(p);
                    a.innerHTML = a.href;
                    anError('The file ' + a.outerHTML + ' could not be accessed.');
                }
                var img = this.response;
                parseGPanoXMP(img);
                infoDisplay.load.msg.innerHTML = '';
            };
            xhr.onprogress = function(e) {
                if (e.lengthComputable) {
                    // Display progress
                    var percent = e.loaded / e.total * 100;
                    infoDisplay.load.lbarFill.style.width = percent + '%';
                    var unit, numerator, denominator;
                    if (e.total > 1e6) {
                        unit = 'MB';
                        numerator = (e.loaded / 1e6).toFixed(2);
                        denominator = (e.total / 1e6).toFixed(2);
                    } else if (e.total > 1e3) {
                        unit = 'kB';
                        numerator = (e.loaded / 1e3).toFixed(1);
                        denominator = (e.total / 1e3).toFixed(1);
                    } else {
                        unit = 'B';
                        numerator = e.loaded;
                        denominator = e.total;
                    }
                    infoDisplay.load.msg.innerHTML = numerator + ' / ' + denominator + ' ' + unit;
                } else {
                    // Display loading spinner
                    infoDisplay.load.lbox.style.display = 'block';
                    infoDisplay.load.lbar.style.display = 'none';
                }
            };
            try {
                xhr.open('GET', p, true);
            } catch (e) {
                // Malformed URL
                anError('There is something wrong with the panorama URL.');
            }
            xhr.responseType = 'blob';
            xhr.setRequestHeader('Accept', 'image/*,*/*;q=0.9');
            xhr.send();
        }
    }
    
    container.classList.add('pnlm-grab');
    container.classList.remove('pnlm-grabbing');
}

/**
 * Test if URL is absolute or relative.
 * @private
 * @param {string} url - URL to test
 * @returns {boolean} True if absolute, else false
 */
function absoluteURL(url) {
    // From http://stackoverflow.com/a/19709846
    return new RegExp('^(?:[a-z]+:)?//', 'i').test(url) || url[0] == '/' || url.slice(0, 5) == 'blob:';
};

/**
 * Create renderer and initialize event listeners once image is loaded.
 * @private
 */
function onImageLoad() {
    if (!renderer)
        renderer = new libpannellum.renderer(renderContainer);

    // Only add event listeners once
    if (!listenersAdded) {
        listenersAdded = true;
        dragFix.addEventListener('mousedown', onDocumentMouseDown, false);
        document.addEventListener('mousemove', onDocumentMouseMove, false);
        document.addEventListener('mouseup', onDocumentMouseUp, false);
        if (config.mouseZoom) {
            container.addEventListener('mousewheel', onDocumentMouseWheel, false);
            container.addEventListener('DOMMouseScroll', onDocumentMouseWheel, false);
        }
        container.addEventListener('mozfullscreenchange', onFullScreenChange, false);
        container.addEventListener('webkitfullscreenchange', onFullScreenChange, false);
        container.addEventListener('msfullscreenchange', onFullScreenChange, false);
        container.addEventListener('fullscreenchange', onFullScreenChange, false);
        window.addEventListener('resize', onDocumentResize, false);
        window.addEventListener('orientationchange', onDocumentResize, false);
        container.addEventListener('keydown', onDocumentKeyPress, false);
        container.addEventListener('keyup', onDocumentKeyUp, false);
        container.addEventListener('blur', clearKeys, false);
        document.addEventListener('mouseleave', onDocumentMouseUp, false);
        dragFix.addEventListener('touchstart', onDocumentTouchStart, false);
        dragFix.addEventListener('touchmove', onDocumentTouchMove, false);
        dragFix.addEventListener('touchend', onDocumentTouchEnd, false);
        dragFix.addEventListener('pointerdown', onDocumentPointerDown, false);
        dragFix.addEventListener('pointermove', onDocumentPointerMove, false);
        dragFix.addEventListener('pointerup', onDocumentPointerUp, false);
        dragFix.addEventListener('pointerleave', onDocumentPointerUp, false);

        // Deal with MS pointer events
        if (window.navigator.pointerEnabled)
            container.style.touchAction = 'none';
    }

    renderInit();
    setTimeout(function(){isTimedOut = true;}, 500);
}

/**
 * Parses Google Photo Sphere XMP Metadata.
 * https://developers.google.com/photo-sphere/metadata/
 * @private
 * @param {Image} image - Image to read XMP metadata from.
 */
function parseGPanoXMP(image) {
    var reader = new FileReader();
    reader.addEventListener('loadend', function() {
        var img = reader.result;

        // This awful browser specific test exists because iOS 8 does not work
        // with non-progressive encoded JPEGs.
        if (navigator.userAgent.toLowerCase().match(/(iphone|ipod|ipad).* os 8_/)) {
            var flagIndex = img.indexOf('\xff\xc2');
            if (flagIndex < 0 || flagIndex > 65536) {
                anError("Due to iOS 8's broken WebGL implementation, only " +
                    "progressive encoded JPEGs work for your device (this " +
                    "panorama uses standard encoding).");
            }
        }

        var start = img.indexOf('<x:xmpmeta');
        if (start > -1 && config.ignoreGPanoXMP !== true) {
            var xmpData = img.substring(start, img.indexOf('</x:xmpmeta>') + 12);
            
            // Extract the requested tag from the XMP data
            var getTag = function(tag) {
                var result;
                if (xmpData.indexOf(tag + '="') >= 0) {
                    result = xmpData.substring(xmpData.indexOf(tag + '="') + tag.length + 2);
                    result = result.substring(0, result.indexOf('"'));
                } else if (xmpData.indexOf(tag + '>') >= 0) {
                    result = xmpData.substring(xmpData.indexOf(tag + '>') + tag.length + 1);
                    result = result.substring(0, result.indexOf('<'));
                }
                if (result !== undefined) {
                    return Number(result);
                }
                return null;
            };
            
            // Relevant XMP data
            var xmp = {
                fullWidth: getTag('GPano:FullPanoWidthPixels'),
                croppedWidth: getTag('GPano:CroppedAreaImageWidthPixels'),
                fullHeight: getTag('GPano:FullPanoHeightPixels'),
                croppedHeight: getTag('GPano:CroppedAreaImageHeightPixels'),
                topPixels: getTag('GPano:CroppedAreaTopPixels'),
                heading: getTag('GPano:PoseHeadingDegrees'),
                horizonPitch: getTag('GPano:PosePitchDegrees'),
                horizonRoll: getTag('GPano:PoseRollDegrees')
            };
            
            if (xmp.fullWidth !== null && xmp.croppedWidth !== null &&
                xmp.fullHeight !== null && xmp.croppedHeight !== null &&
                xmp.topPixels !== null) {
                
                // Set up viewer using GPano XMP data
                if (specifiedPhotoSphereExcludes.indexOf('haov') < 0)
                    config.haov = xmp.croppedWidth / xmp.fullWidth * 360;
                if (specifiedPhotoSphereExcludes.indexOf('vaov') < 0)
                    config.vaov = xmp.croppedHeight / xmp.fullHeight * 180;
                if (specifiedPhotoSphereExcludes.indexOf('vOffset') < 0)
                    config.vOffset = ((xmp.topPixels + xmp.croppedHeight / 2) / xmp.fullHeight - 0.5) * -180;
                if (xmp.heading !== null && specifiedPhotoSphereExcludes.indexOf('northOffset') < 0) {
                    // TODO: make sure this works correctly for partial panoramas
                    config.northOffset = xmp.heading;
                    if (config.compass !== false) {
                        config.compass = true;
                    }
                }
                if (xmp.horizonPitch !== null && xmp.horizonRoll !== null) {
                    if (specifiedPhotoSphereExcludes.indexOf('horizonPitch') < 0)
                        config.horizonPitch = xmp.horizonPitch;
                    if (specifiedPhotoSphereExcludes.indexOf('horizonRoll') < 0)
                        config.horizonRoll = xmp.horizonRoll;
                }
                
                // TODO: add support for initial view settings
            }
        }
        
        // Load panorama
        panoImage.src = window.URL.createObjectURL(image);
    });
    if (reader.readAsBinaryString !== undefined)
        reader.readAsBinaryString(image);
    else
        reader.readAsText(image);
}

/**
 * Displays an error message.
 * @private
 * @param {string} errorMsg - Error message to display. If not specified, a
 *      generic WebGL error is displayed.
 */
function anError(errorMsg) {
    if (errorMsg === undefined)
        errorMsg = 'Your browser does not have the necessary WebGL support to display this panorama.';
    infoDisplay.errorMsg.innerHTML = '<p>' + errorMsg + '</p>';
    controls.load.style.display = 'none';
    infoDisplay.load.box.style.display = 'none';
    infoDisplay.errorMsg.style.display = 'table';
    error = true;
    renderContainer.style.display = 'none';
    fireEvent('error', errorMsg);
}

/**
 * Hides error message display.
 * @private
 */
function clearError() {
    if (error) {
        infoDisplay.load.box.style.display = 'none';
        infoDisplay.errorMsg.style.display = 'none';
        error = false;
        fireEvent('errorcleared');
    }
}

/**
 * Displays about message.
 * @private
 * @param {MouseEvent} event - Right click location
 */
function aboutMessage(event) {
    var pos = mousePosition(event);
    aboutMsg.style.left = pos.x + 'px';
    aboutMsg.style.top = pos.y + 'px';
    clearTimeout(aboutMessage.t1);
    clearTimeout(aboutMessage.t2);
    aboutMsg.style.display = 'block';
    aboutMsg.style.opacity = 1;
    aboutMessage.t1 = setTimeout(function() {aboutMsg.style.opacity = 0;}, 2000);
    aboutMessage.t2 = setTimeout(function() {aboutMsg.style.display = 'none';}, 2500);
    event.preventDefault();
}

/**
 * Calculate mouse position relative to top left of viewer container.
 * @private
 * @param {MouseEvent} event - Mouse event to use in calculation
 * @returns {Object} Calculated X and Y coordinates
 */
function mousePosition(event) {
    var bounds = container.getBoundingClientRect();
    var pos = {};
    pos.x = event.clientX - bounds.left;
    pos.y = event.clientY - bounds.top;
    return pos;
}

/**
 * Event handler for mouse clicks. Initializes panning. Prints center and click
 * location coordinates when hot spot debugging is enabled.
 * @private
 * @param {MouseEvent} event - Document mouse down event.
 */
function onDocumentMouseDown(event) {
    // Override default action
    event.preventDefault();
    // But not all of it
    container.focus();
    
    // Only do something if the panorama is loaded
    if (!loaded) {
        return;
    }
    
    // Calculate mouse position relative to top left of viewer container
    var pos = mousePosition(event);

    // Log pitch / yaw of mouse click when debugging / placing hot spots
    if (config.hotSpotDebug) {
        var coords = mouseEventToCoords(event);
        console.log('Pitch: ' + coords[0] + ', Yaw: ' + coords[1] + ', Center Pitch: ' +
            config.pitch + ', Center Yaw: ' + config.yaw + ', HFOV: ' + config.hfov);
    }
    
    // Turn off auto-rotation if enabled
    stopAnimation();

    stopOrientation();
    config.roll = 0;

    speed.hfov = 0;

    isUserInteracting = true;
    latestInteraction = Date.now();
    
    onPointerDownPointerX = pos.x;
    onPointerDownPointerY = pos.y;
    
    onPointerDownYaw = config.yaw;
    onPointerDownPitch = config.pitch;
    
    container.classList.add('pnlm-grabbing');
    container.classList.remove('pnlm-grab');
    
    fireEvent('mousedown', event);
    animateInit();
}

/**
 * Calculate panorama pitch and yaw from location of mouse event.
 * @private
 * @param {MouseEvent} event - Document mouse down event.
 * @returns {number[]} [pitch, yaw]
 */
function mouseEventToCoords(event) {
    var pos = mousePosition(event);
    var canvas = renderer.getCanvas();
    var canvasWidth = canvas.width / (window.devicePixelRatio || 1),
        canvasHeight = canvas.height / (window.devicePixelRatio || 1);
    var x = pos.x / canvasWidth * 2 - 1;
    var y = (1 - pos.y / canvasHeight * 2) * canvasHeight / canvasWidth;
    var focal = 1 / Math.tan(config.hfov * Math.PI / 360);
    var s = Math.sin(config.pitch * Math.PI / 180);
    var c = Math.cos(config.pitch * Math.PI / 180);
    var a = focal * c - y * s;
    var root = Math.sqrt(x*x + a*a);
    var pitch = Math.atan((y * c + focal * s) / root) * 180 / Math.PI;
    var yaw = Math.atan2(x / root, a / root) * 180 / Math.PI + config.yaw;
    return [pitch, yaw];
}

/**
 * Event handler for mouse moves. Pans center of view.
 * @private
 * @param {MouseEvent} event - Document mouse move event.
 */
function onDocumentMouseMove(event) {
    if (isUserInteracting && loaded) {
        latestInteraction = Date.now();
        var canvas = renderer.getCanvas();
        var canvasWidth = canvas.width / (window.devicePixelRatio || 1),
            canvasHeight = canvas.height / (window.devicePixelRatio || 1);
        var pos = mousePosition(event);
        //TODO: This still isn't quite right
        var yaw = ((Math.atan(onPointerDownPointerX / canvasWidth * 2 - 1) - Math.atan(pos.x / canvasWidth * 2 - 1)) * 180 / Math.PI * config.hfov / 90) + onPointerDownYaw;
        speed.yaw = (yaw - config.yaw) % 360 * 0.2;
        config.yaw = yaw;
        
        var vfov = 2 * Math.atan(Math.tan(config.hfov/360*Math.PI) * canvasHeight / canvasWidth) * 180 / Math.PI;
        
        var pitch = ((Math.atan(pos.y / canvasHeight * 2 - 1) - Math.atan(onPointerDownPointerY / canvasHeight * 2 - 1)) * 180 / Math.PI * vfov / 90) + onPointerDownPitch;
        speed.pitch = (pitch - config.pitch) * 0.2;
        config.pitch = pitch;
    }
}

/**
 * Event handler for mouse up events. Stops panning.
 * @private
 */
function onDocumentMouseUp(event) {
    if (!isUserInteracting) {
        return;
    }
    isUserInteracting = false;
    if (Date.now() - latestInteraction > 15) {
        // Prevents jump when user rapidly moves mouse, stops, and then
        // releases the mouse button
        speed.pitch = speed.yaw = 0;
    }
    container.classList.add('pnlm-grab');
    container.classList.remove('pnlm-grabbing');
    latestInteraction = Date.now();

    fireEvent('mouseup', event);
}

/**
 * Event handler for touches. Initializes panning if one touch or zooming if
 * two touches.
 * @private
 * @param {TouchEvent} event - Document touch start event.
 */
function onDocumentTouchStart(event) {
    // Only do something if the panorama is loaded
    if (!loaded) {
        return;
    }

    // Turn off auto-rotation if enabled
    stopAnimation();

    stopOrientation();
    config.roll = 0;

    speed.hfov = 0;

    // Calculate touch position relative to top left of viewer container
    var pos0 = mousePosition(event.targetTouches[0]);

    onPointerDownPointerX = pos0.x;
    onPointerDownPointerY = pos0.y;
    
    if (event.targetTouches.length == 2) {
        // Down pointer is the center of the two fingers
        var pos1 = mousePosition(event.targetTouches[1]);
        onPointerDownPointerX += (pos1.x - pos0.x) * 0.5;
        onPointerDownPointerY += (pos1.y - pos0.y) * 0.5;
        onPointerDownPointerDist = Math.sqrt((pos0.x - pos1.x) * (pos0.x - pos1.x) +
                                             (pos0.y - pos1.y) * (pos0.y - pos1.y));
    }
    isUserInteracting = true;
    latestInteraction = Date.now();
    
    onPointerDownYaw = config.yaw;
    onPointerDownPitch = config.pitch;

    animateInit();
}

/**
 * Event handler for touch movements. Pans center of view if one touch or
 * adjusts zoom if two touches.
 * @private
 * @param {TouchEvent} event - Document touch move event.
 */
function onDocumentTouchMove(event) {
    // Override default action
    event.preventDefault();
    if (loaded) {
        latestInteraction = Date.now();
    }
    if (isUserInteracting && loaded) {
        var pos0 = mousePosition(event.targetTouches[0]);
        var clientX = pos0.x;
        var clientY = pos0.y;
        
        if (event.targetTouches.length == 2 && onPointerDownPointerDist != -1) {
            var pos1 = mousePosition(event.targetTouches[1]);
            clientX += (pos1.x - pos0.x) * 0.5;
            clientY += (pos1.y - pos0.y) * 0.5;
            var clientDist = Math.sqrt((pos0.x - pos1.x) * (pos0.x - pos1.x) +
                                       (pos0.y - pos1.y) * (pos0.y - pos1.y));
            setHfov(config.hfov + (onPointerDownPointerDist - clientDist) * 0.1);
            onPointerDownPointerDist = clientDist;
        }

        // The smaller the config.hfov value (the more zoomed-in the user is), the faster
        // yaw/pitch are perceived to change on one-finger touchmove (panning) events and vice versa.
        // To improve usability at both small and large zoom levels (config.hfov values)
        // we introduce a dynamic pan speed coefficient.
        //
        // Currently this seems to *roughly* keep initial drag/pan start position close to
        // the user's finger while panning regardless of zoom level / config.hfov value.
        var touchmovePanSpeedCoeff = config.hfov / 360;

        var yaw = (onPointerDownPointerX - clientX) * touchmovePanSpeedCoeff + onPointerDownYaw;
        speed.yaw = (yaw - config.yaw) % 360 * 0.2;
        config.yaw = yaw;

        var pitch = (clientY - onPointerDownPointerY) * touchmovePanSpeedCoeff + onPointerDownPitch;
        speed.pitch = (pitch - config.pitch) * 0.2;
        config.pitch = pitch;
    }
}

/**
 * Event handler for end of touches. Stops panning and/or zooming.
 * @private
 */
function onDocumentTouchEnd() {
    isUserInteracting = false;
    if (Date.now() - latestInteraction > 150) {
        speed.pitch = speed.yaw = 0;
    }
    onPointerDownPointerDist = -1;
    latestInteraction = Date.now();
}

var pointerIDs = [],
    pointerCoordinates = [];
/**
 * Event handler for touch starts in IE / Edge.
 * @private
 * @param {PointerEvent} event - Document pointer down event.
 */
function onDocumentPointerDown(event) {
    if (event.pointerType == 'touch') {
        pointerIDs.push(event.pointerId);
        pointerCoordinates.push({clientX: event.clientX, clientY: event.clientY});
        event.targetTouches = pointerCoordinates;
        onDocumentTouchStart(event);
        event.preventDefault();
    }
}

/**
 * Event handler for touch moves in IE / Edge.
 * @private
 * @param {PointerEvent} event - Document pointer move event.
 */
function onDocumentPointerMove(event) {
    if (event.pointerType == 'touch') {
        for (var i = 0; i < pointerIDs.length; i++) {
            if (event.pointerId == pointerIDs[i]) {
                pointerCoordinates[i] = {clientX: event.clientX, clientY: event.clientY};
                event.targetTouches = pointerCoordinates;
                onDocumentTouchMove(event);
                //event.preventDefault();
                return;
            }
        }
    }
}

/**
 * Event handler for touch ends in IE / Edge.
 * @private
 * @param {PointerEvent} event - Document pointer up event.
 */
function onDocumentPointerUp(event) {
    if (event.pointerType == 'touch') {
        var defined = false;
        for (var i = 0; i < pointerIDs.length; i++) {
            if (event.pointerId == pointerIDs[i])
                pointerIDs[i] = undefined;
            if (pointerIDs[i])
                defined = true;
        }
        if (!defined) {
            pointerIDs = [];
            pointerCoordinates = [];
            onDocumentTouchEnd();
        }
        event.preventDefault();
    }
}

/**
 * Event handler for mouse wheel. Changes zoom.
 * @private
 * @param {WheelEvent} event - Document mouse wheel event.
 */
function onDocumentMouseWheel(event) {
    event.preventDefault();
    
    // Only do something if the panorama is loaded
    if (!loaded) {
        return;
    }

    // Turn off auto-rotation if enabled
    stopAnimation();
    latestInteraction = Date.now();

    if (event.wheelDeltaY) {
        // WebKit
        setHfov(config.hfov - event.wheelDeltaY * 0.05);
        speed.hfov = event.wheelDelta < 0 ? 1 : -1;
    } else if (event.wheelDelta) {
        // Opera / Explorer 9
        setHfov(config.hfov - event.wheelDelta * 0.05);
        speed.hfov = event.wheelDelta < 0 ? 1 : -1;
    } else if (event.detail) {
        // Firefox
        setHfov(config.hfov + event.detail * 1.5);
        speed.hfov = event.detail > 0 ? 1 : -1;
    }
    
    animateInit();
}

/**
 * Event handler for key presses. Updates list of currently pressed keys.
 * @private
 * @param {KeyboardEvent} event - Document key press event.
 */
function onDocumentKeyPress(event) {
    // Override default action
    event.preventDefault();
    
    // Turn off auto-rotation if enabled
    stopAnimation();
    latestInteraction = Date.now();

    stopOrientation();
    config.roll = 0;

    // Record key pressed
    var keynumber = event.keycode;
    if (event.which) {
        keynumber = event.which;
    }
    
    // If escape key is pressed
    if (keynumber == 27) {
        // If in fullscreen mode
        if (fullscreenActive) {
            toggleFullscreen();
        }
    } else {
        // Change key
        changeKey(keynumber, true);
    }
}

/**
 * Clears list of currently pressed keys.
 * @private
 */
function clearKeys() {
    for (var i = 0; i < 10; i++) {
        keysDown[i] = false;
    }
}

/**
 * Event handler for key releases. Updates list of currently pressed keys.
 * @private
 * @param {KeyboardEvent} event - Document key up event.
 */
function onDocumentKeyUp(event) {
    // Override default action
    event.preventDefault();
    
    // Record key released
    var keynumber = event.keycode;
    if (event.which) {
        keynumber = event.which;
    }
    
    // Change key
    changeKey(keynumber, false);
}

/**
 * Updates list of currently pressed keys.
 * @private
 * @param {number} keynumber - Key number.
 * @param {boolean} value - Whether or not key is pressed.
 */
function changeKey(keynumber, value) {
    var keyChanged = false;
    switch(keynumber) {
        // If minus key is released
        case 109: case 189: case 17:
            if (keysDown[0] != value) { keyChanged = true; }
            keysDown[0] = value; break;
        
        // If plus key is released
        case 107: case 187: case 16:
            if (keysDown[1] != value) { keyChanged = true; }
            keysDown[1] = value; break;
        
        // If up arrow is released
        case 38:
            if (keysDown[2] != value) { keyChanged = true; }
            keysDown[2] = value; break;
        
        // If "w" is released
        case 87:
            if (keysDown[6] != value) { keyChanged = true; }
            keysDown[6] = value; break;
        
        // If down arrow is released
        case 40:
            if (keysDown[3] != value) { keyChanged = true; }
            keysDown[3] = value; break;
        
        // If "s" is released
        case 83:
            if (keysDown[7] != value) { keyChanged = true; }
            keysDown[7] = value; break;
        
        // If left arrow is released
        case 37:
            if (keysDown[4] != value) { keyChanged = true; }
            keysDown[4] = value; break;
        
        // If "a" is released
        case 65:
            if (keysDown[8] != value) { keyChanged = true; }
            keysDown[8] = value; break;
        
        // If right arrow is released
        case 39:
            if (keysDown[5] != value) { keyChanged = true; }
            keysDown[5] = value; break;
        
        // If "d" is released
        case 68:
            if (keysDown[9] != value) { keyChanged = true; }
            keysDown[9] = value;
    }
    
    if (keyChanged && value) {
        if (typeof performance !== 'undefined' && performance.now()) {
            prevTime = performance.now();
        } else {
            prevTime = Date.now();
        }
        animateInit();
    }
}

/**
 * Pans and/or zooms panorama based on currently pressed keys. Also handles
 * panorama "inertia" and auto rotation.
 * @private
 */
function keyRepeat() {
    // Only do something if the panorama is loaded
    if (!loaded) {
        return;
    }

    var isKeyDown = false;

    var prevPitch = config.pitch;
    var prevYaw = config.yaw;
    var prevZoom = config.hfov;
    
    var newTime;
    if (typeof performance !== 'undefined' && performance.now()) {
        newTime = performance.now();
    } else {
        newTime = Date.now();
    }
    if (prevTime === undefined) {
        prevTime = newTime;
    }
    var diff = (newTime - prevTime) * config.hfov / 1700;
    diff = Math.min(diff, 1.0);
    
    // If minus key is down
    if (keysDown[0] && config.keyboardZoom === true) {
        setHfov(config.hfov + (speed.hfov * 0.8 + 0.5) * diff);
        isKeyDown = true;
    }
    
    // If plus key is down
    if (keysDown[1] && config.keyboardZoom === true) {
        setHfov(config.hfov + (speed.hfov * 0.8 - 0.2) * diff);
        isKeyDown = true;
    }
    
    // If up arrow or "w" is down
    if (keysDown[2] || keysDown[6]) {
        // Pan up
        config.pitch += (speed.pitch * 0.8 + 0.2) * diff;
        isKeyDown = true;
    }
    
    // If down arrow or "s" is down
    if (keysDown[3] || keysDown[7]) {
        // Pan down
        config.pitch += (speed.pitch * 0.8 - 0.2) * diff;
        isKeyDown = true;
    }
    
    // If left arrow or "a" is down
    if (keysDown[4] || keysDown[8]) {
        // Pan left
        config.yaw += (speed.yaw * 0.8 - 0.2) * diff;
        isKeyDown = true;
    }
    
    // If right arrow or "d" is down
    if (keysDown[5] || keysDown[9]) {
        // Pan right
        config.yaw += (speed.yaw * 0.8 + 0.2) * diff;
        isKeyDown = true;
    }

    if (isKeyDown)
        latestInteraction = Date.now();

    // If auto-rotate
    var inactivityInterval = Date.now() - latestInteraction;
    if (config.autoRotate) {
        // Pan
        if (newTime - prevTime > 0.001) {
            var timeDiff = (newTime - prevTime) / 1000;
            var yawDiff = (speed.yaw / timeDiff * diff - config.autoRotate * 0.2) * timeDiff
            yawDiff = (-config.autoRotate > 0 ? 1 : -1) * Math.min(Math.abs(config.autoRotate * timeDiff), Math.abs(yawDiff));
            config.yaw += yawDiff;
        }
        
        // Deal with stopping auto rotation after a set delay
        if (config.autoRotateStopDelay) {
            config.autoRotateStopDelay -= newTime - prevTime;
            if (config.autoRotateStopDelay <= 0) {
                config.autoRotateStopDelay = false;
                autoRotateSpeed = config.autoRotate;
                config.autoRotate = 0;
            }
        }
    }

    // Animated moves
    if (animatedMove.pitch) {
        animateMove('pitch');
        prevPitch = config.pitch;
    }
    if (animatedMove.yaw) {
        animateMove('yaw');
        prevYaw = config.yaw;
    }
    if (animatedMove.hfov) {
        animateMove('hfov');
        prevZoom = config.hfov;
    }

    // "Inertia"
    if (diff > 0 && !config.autoRotate) {
        // "Friction"
        var friction = 0.85;
        
        // Yaw
        if (!keysDown[4] && !keysDown[5] && !keysDown[8] && !keysDown[9] && !animatedMove.yaw) {
            config.yaw += speed.yaw * diff * friction;
        }
        // Pitch
        if (!keysDown[2] && !keysDown[3] && !keysDown[6] && !keysDown[7] && !animatedMove.pitch) {
            config.pitch += speed.pitch * diff * friction;
        }
        // Zoom
        if (!keysDown[0] && !keysDown[1] && !animatedMove.hfov) {
            setHfov(config.hfov + speed.hfov * diff * friction);
        }
    }

    prevTime = newTime;
    if (diff > 0) {
        speed.yaw = speed.yaw * 0.8 + (config.yaw - prevYaw) / diff * 0.2;
        speed.pitch = speed.pitch * 0.8 + (config.pitch - prevPitch) / diff * 0.2;
        speed.hfov = speed.hfov * 0.8 + (config.hfov - prevZoom) / diff * 0.2;
        
        // Limit speed
        var maxSpeed = config.autoRotate ? Math.abs(config.autoRotate) : 5;
        speed.yaw = Math.min(maxSpeed, Math.max(speed.yaw, -maxSpeed));
        speed.pitch = Math.min(maxSpeed, Math.max(speed.pitch, -maxSpeed));
        speed.hfov = Math.min(maxSpeed, Math.max(speed.hfov, -maxSpeed));
    }
    
    // Stop movement if opposite controls are pressed
    if (keysDown[0] && keysDown[0]) {
        speed.hfov = 0;
    }
    if ((keysDown[2] || keysDown[6]) && (keysDown[3] || keysDown[7])) {
        speed.pitch = 0;
    }
    if ((keysDown[4] || keysDown[8]) && (keysDown[5] || keysDown[9])) {
        speed.yaw = 0;
    }
}

/**
 * Animates moves.
 * @param {string} axis - Axis to animate
 * @private
 */
function animateMove(axis) {
    var t = animatedMove[axis];
    var normTime = Math.min(1, Math.max((Date.now() - t.startTime) / 1000 / (t.duration / 1000), 0));
    var result = t.startPosition + timingFunction(normTime) * (t.endPosition - t.startPosition);
    if ((t.endPosition > t.startPosition && result >= t.endPosition) ||
        (t.endPosition < t.startPosition && result <= t.endPosition)) {
        result = t.endPosition;
        speed[axis] = 0;
        delete animatedMove[axis];
    }
    config[axis] = result;
}

/**
 * @param {number} t - Normalized time in animation
 * @return {number} Position in animation
 * @private
 */
function timingFunction(t) {
    // easeInOutQuad from https://gist.github.com/gre/1650294
    return t < 0.5 ? 2*t*t : -1+(4-2*t)*t;
}

/**
 * Event handler for document resizes. Updates viewer size and rerenders view.
 * @private
 */
function onDocumentResize() {
    // Resize panorama renderer (moved to onFullScreenChange)
    //renderer.resize();
    //animateInit();

    // Kludge to deal with WebKit regression: https://bugs.webkit.org/show_bug.cgi?id=93525
    onFullScreenChange();
}

/**
 * Initializes animation.
 * @private
 */
function animateInit() {
    if (animating) {
        return;
    }
    animating = true;
    animate();
}

/**
 * Animates view, using requestAnimationFrame to trigger rendering.
 * @private
 */
function animate() {
    render();
    if (autoRotateStart)
        clearTimeout(autoRotateStart);
    if (isUserInteracting || orientation) {
        requestAnimationFrame(animate);
    } else if (keysDown[0] || keysDown[1] || keysDown[2] || keysDown[3] ||
        keysDown[4] || keysDown[5] || keysDown[6] || keysDown[7] ||
        keysDown[8] || keysDown[9] || config.autoRotate ||
        animatedMove.pitch || animatedMove.yaw || animatedMove.hfov ||
        Math.abs(speed.yaw) > 0.01 || Math.abs(speed.pitch) > 0.01 ||
        Math.abs(speed.hfov) > 0.01) {

        keyRepeat();
        if (config.autoRotateInactivityDelay >= 0 && autoRotateSpeed &&
            Date.now() - latestInteraction > config.autoRotateInactivityDelay &&
            !config.autoRotate) {
            config.autoRotate = autoRotateSpeed;
            _this.lookAt(origPitch, undefined, origHfov, 3000);
        }
        requestAnimationFrame(animate);
    } else if (renderer && (renderer.isLoading() || (config.dynamic === true && update))) {
        requestAnimationFrame(animate);
    } else {
        animating = false;
        prevTime = undefined;
        var autoRotateStartTime = config.autoRotateInactivityDelay -
            (Date.now() - latestInteraction);
        if (autoRotateStartTime > 0) {
            autoRotateStart = setTimeout(function() {
                config.autoRotate = autoRotateSpeed;
                _this.lookAt(origPitch, undefined, origHfov, 3000);
                animateInit();
            }, autoRotateStartTime);
        } else if (config.autoRotateInactivityDelay >= 0 && autoRotateSpeed) {
            config.autoRotate = autoRotateSpeed;
            _this.lookAt(origPitch, undefined, origHfov, 3000);
            animateInit();
        }
    }
}

/**
 * Renders panorama view.
 * @private
 */
function render() {
    var tmpyaw;

    if (loaded) {
        if (config.yaw > 180) {
            config.yaw -= 360;
        } else if (config.yaw < -180) {
            config.yaw += 360;
        }

        // Keep a tmp value of yaw for autoRotate comparison later
        tmpyaw = config.yaw;

        // Ensure the yaw is within min and max allowed
        var yawRange = config.maxYaw - config.minYaw,
            minYaw = -180,
            maxYaw = 180;
        if (yawRange < 360) {
            minYaw = config.minYaw + config.hfov / 2;
            maxYaw = config.maxYaw - config.hfov / 2;
            if (yawRange < config.hfov) {
                // Lock yaw to average of min and max yaw when both can be seen at once
                minYaw = maxYaw = (minYaw + maxYaw) / 2;
            }
        }
        config.yaw = Math.max(minYaw, Math.min(maxYaw, config.yaw));
        
        // Check if we autoRotate in a limited by min and max yaw
        // If so reverse direction
        if (config.autoRotate !== false && tmpyaw != config.yaw) {
            config.autoRotate *= -1;
        }

        // Ensure the calculated pitch is within min and max allowed
        var canvas = renderer.getCanvas();
        var vfov = 2 * Math.atan(Math.tan(config.hfov / 180 * Math.PI * 0.5) /
            (canvas.width / canvas.height)) / Math.PI * 180;
        var minPitch = config.minPitch + vfov / 2,
            maxPitch = config.maxPitch - vfov / 2;
        var pitchRange = config.maxPitch - config.minPitch;
        if (pitchRange < vfov) {
            // Lock pitch to average of min and max pitch when both can be seen at once
            minPitch = maxPitch = (minPitch + maxPitch) / 2;
        }
        if (isNaN(minPitch))
            minPitch = -90;
        if (isNaN(maxPitch))
            maxPitch = 90;
        config.pitch = Math.max(minPitch, Math.min(maxPitch, config.pitch));
        
        renderer.render(config.pitch * Math.PI / 180, config.yaw * Math.PI / 180, config.hfov * Math.PI / 180, {roll: config.roll * Math.PI / 180});
        
        renderHotSpots();
        
        // Update compass
        if (config.compass) {
            compass.style.transform = 'rotate(' + (-config.yaw - config.northOffset) + 'deg)';
            compass.style.webkitTransform = 'rotate(' + (-config.yaw - config.northOffset) + 'deg)';
        }
    }
}

/**
 * Creates a new quaternion.
 * @private
 * @constructor
 * @param {Number} w - W value
 * @param {Number} x - X value
 * @param {Number} y - Y value
 * @param {Number} z - Z value
 */
function Quaternion(w, x, y, z) {
    this.w = w;
    this.x = x;
    this.y = y;
    this.z = z;
}

/**
 * Multiplies quaternions.
 * @private
 * @param {Quaternion} q - Quaternion to multiply
 * @returns {Quaternion} Result of multiplication
 */
Quaternion.prototype.multiply = function(q) {
    return new Quaternion(this.w*q.w - this.x*q.x - this.y*q.y - this.z*q.z,
                          this.x*q.w + this.w*q.x + this.y*q.z - this.z*q.y,
                          this.y*q.w + this.w*q.y + this.z*q.x - this.x*q.z,
                          this.z*q.w + this.w*q.z + this.x*q.y - this.y*q.x);
}

/**
 * Converts quaternion to Euler angles.
 * @private
 * @returns {Number[]} [phi angle, theta angle, psi angle]
 */
Quaternion.prototype.toEulerAngles = function() {
    var phi = Math.atan2(2 * (this.w * this.x + this.y * this.z),
                         1 - 2 * (this.x * this.x + this.y * this.y)),
        theta = Math.asin(2 * (this.w * this.y - this.z * this.x)),
        psi = Math.atan2(2 * (this.w * this.z + this.x * this.y),
                         1 - 2 * (this.y * this.y + this.z * this.z));
    return [phi, theta, psi];
}

/**
 * Converts device orientation API Tait-Bryan angles to a quaternion.
 * @private
 * @param {Number} alpha - Alpha angle (in degrees)
 * @param {Number} beta - Beta angle (in degrees)
 * @param {Number} gamma - Gamma angle (in degrees)
 * @returns {Quaternion} Orientation quaternion
 */
function taitBryanToQuaternion(alpha, beta, gamma) {
    var r = [beta ? beta * Math.PI / 180 / 2 : 0,
             gamma ? gamma * Math.PI / 180 / 2 : 0,
             alpha ? alpha * Math.PI / 180 / 2 : 0];
    var c = [Math.cos(r[0]), Math.cos(r[1]), Math.cos(r[2])],
        s = [Math.sin(r[0]), Math.sin(r[1]), Math.sin(r[2])];

    return new Quaternion(c[0]*c[1]*c[2] - s[0]*s[1]*s[2],
                          s[0]*c[1]*c[2] - c[0]*s[1]*s[2],
                          c[0]*s[1]*c[2] + s[0]*c[1]*s[2],
                          c[0]*c[1]*s[2] + s[0]*s[1]*c[2]);
}

/**
 * Computes current device orientation quaternion from device orientation API
 * Tait-Bryan angles.
 * @private
 * @param {Number} alpha - Alpha angle (in degrees)
 * @param {Number} beta - Beta angle (in degrees)
 * @param {Number} gamma - Gamma angle (in degrees)
 * @returns {Quaternion} Orientation quaternion
 */
function computeQuaternion(alpha, beta, gamma) {
    // Convert Tait-Bryan angles to quaternion
    var quaternion = taitBryanToQuaternion(alpha, beta, gamma);
    // Apply world transform
    quaternion = quaternion.multiply(new Quaternion(Math.sqrt(0.5), -Math.sqrt(0.5), 0, 0));
    // Apply screen transform
    var angle = window.orientation ? -window.orientation * Math.PI / 180 / 2 : 0;
    return quaternion.multiply(new Quaternion(Math.cos(angle), 0, -Math.sin(angle), 0));
}

/**
 * Event handler for device orientation API. Controls pointing.
 * @private
 * @param {DeviceOrientationEvent} event - Device orientation event.
 */
function orientationListener(e) {
    var q = computeQuaternion(e.alpha, e.beta, e.gamma).toEulerAngles();
    config.pitch = q[0] / Math.PI * 180;
    config.roll = -q[1] / Math.PI * 180;
    config.yaw = -q[2] / Math.PI * 180 + config.northOffset;
}

/**
 * Initializes renderer.
 * @private
 */
function renderInit() {
    try {
        var params = {};
        if (config.horizonPitch !== undefined)
            params.horizonPitch = config.horizonPitch * Math.PI / 180;
        if (config.horizonRoll !== undefined)
            params.horizonRoll = config.horizonRoll * Math.PI / 180;
        if (config.backgroundColor !== undefined)
            params.backgroundColor = config.backgroundColor;
        renderer.init(panoImage, config.type, config.dynamic, config.haov * Math.PI / 180, config.vaov * Math.PI / 180, config.vOffset * Math.PI / 180, renderInitCallback, params);
        if (config.dynamic !== true) {
            // Allow image to be garbage collected
            panoImage = undefined;
        }
    } catch(event) {
        // Panorama not loaded
        
        // Display error if there is a bad texture
        if (event.type == 'webgl error' || event.type == 'no webgl') {
            anError();
        } else if (event.type == 'webgl size error') {
            anError('This panorama is too big for your device! It\'s ' +
                event.width + 'px wide, but your device only supports images up to ' +
                event.maxWidth + 'px wide. Try another device.' +
                ' (If you\'re the author, try scaling down the image.)');
        } else {
            anError('Unknown error. Check developer console.');
            throw event;
        }
    }
}

/**
 * Triggered when render initialization finishes. Handles fading between
 * scenes as well as showing the compass and hotspots and hiding the loading
 * display.
 * @private
 */
function renderInitCallback() {
    // Fade if specified
    if (config.sceneFadeDuration && renderer.fadeImg !== undefined) {
        renderer.fadeImg.style.opacity = 0;
        // Remove image
        var fadeImg = renderer.fadeImg;
        delete renderer.fadeImg;
        setTimeout(function() {
            Polymer.dom(renderContainer).removeChild(fadeImg);
        }, config.sceneFadeDuration);
    }
    
    // Show compass if applicable
    if (config.compass) {
        compass.style.display = 'inline';
    } else {
        compass.style.display = 'none';
    }
    
    // Show hotspots
    createHotSpots();
    
    // Hide loading display
    infoDisplay.load.box.style.display = 'none';
    if (preview !== undefined) {
        Polymer.dom(renderContainer).removeChild(preview);
        preview = undefined;
    }
    loaded = true;

    fireEvent('load');
    
    animateInit();
}

/**
 * Creates hot spot element for the current scene.
 * @private
 * @param {Object} hs - The configuration for the hotspot
 */
function createHotSpot(hs) {
    // Make sure hot spot pitch and yaw are numbers
    hs.pitch = Number(hs.pitch) || 0;
    hs.yaw = Number(hs.yaw) || 0;

    var div = document.createElement('div');
    div.className = 'pnlm-hotspot-base'
    if (hs.cssClass)
        div.className += ' ' + hs.cssClass;
    else
    /******* MODIFIED *******/
//        div.className += ' pnlm-hotspot pnlm-sprite pnlm-' + escapeHTML(hs.type);
        div.className += ' pnlm-hotspot pnlm-' + escapeHTML(hs.type);
    /******* MODIFIED *******/

    var span = document.createElement('span');
    if (hs.text)
        span.innerHTML = escapeHTML(hs.text);

    var a;
    if (hs.video) {
        var video = document.createElement('video'),
            p = hs.video;
        if (config.basePath && !absoluteURL(p))
            p = config.basePath + p;
        video.src = encodeURI(p);
        video.controls = true;
        video.style.width = hs.width + 'px';
        Polymer.dom(renderContainer).appendChild(div);
        Polymer.dom(span).appendChild(video);
    } else if (hs.image) {
        var p = hs.image;
        if (config.basePath && !absoluteURL(p))
            p = config.basePath + p;
        a = document.createElement('a');
        a.href = encodeURI(hs.URL ? hs.URL : p);
        a.target = '_blank';
        Polymer.dom(span).appendChild(a);
        var image = document.createElement('img');
        image.src = encodeURI(p);
        image.style.width = hs.width + 'px';
        image.style.paddingTop = '5px';
        Polymer.dom(renderContainer).appendChild(div);
        Polymer.dom(a).appendChild(image);
        span.style.maxWidth = 'initial';
    } else if (hs.URL) {
        a = document.createElement('a');
        a.href = encodeURI(hs.URL);
        a.target = '_blank';
        Polymer.dom(renderContainer).appendChild(a);
        div.style.cursor = 'pointer';
        span.style.cursor = 'pointer';
        Polymer.dom(a).appendChild(div);
    } else {
        if (hs.sceneId) {
            div.onclick = function() {
                loadScene(hs.sceneId, hs.targetPitch, hs.targetYaw, hs.targetHfov);
                return false;
            };
            div.ontouchend = function() {
                loadScene(hs.sceneId, hs.targetPitch, hs.targetYaw, hs.targetHfov);
                return false;
            };
            div.style.cursor = 'pointer';
            span.style.cursor = 'pointer';
        }
        Polymer.dom(renderContainer).appendChild(div);
    }

    if (hs.createTooltipFunc) {
        hs.createTooltipFunc(div, hs.createTooltipArgs);
    } else if (hs.text || hs.video || hs.image) {
        div.classList.add('pnlm-tooltip');
        Polymer.dom(div).appendChild(span);
        span.style.width = span.scrollWidth - 20 + 'px';
        span.style.marginLeft = -(span.scrollWidth - div.offsetWidth) / 2 + 'px';
        span.style.marginTop = -span.scrollHeight - 12 + 'px';
    }
    if (hs.clickHandlerFunc) {
        div.addEventListener('click', function(e) {
            hs.clickHandlerFunc(e, hs.clickHandlerArgs);
        }, 'false');
        div.style.cursor = 'pointer';
        span.style.cursor = 'pointer';
    }
    hs.div = div;
};

/**
 * Creates hot spot elements for the current scene.
 * @private
 */
function createHotSpots() {
    if (hotspotsCreated) return;

    if (!config.hotSpots) {
        config.hotSpots = [];
    } else {
        // Sort by pitch so tooltip is never obscured by another hot spot
        config.hotSpots = config.hotSpots.sort(function(a, b) {
            return a.pitch < b.pitch;
        });
        config.hotSpots.forEach(createHotSpot);
    }
    hotspotsCreated = true;
    renderHotSpots();
}

/**
 * Destroys currently create hot spot elements.
 * @private
 */
function destroyHotSpots() {
    if (config.hotSpots) {
        for (var i = 0; i < config.hotSpots.length; i++) {
            var current = config.hotSpots[i].div;
            while(current.parentNode != renderContainer) {
                current = current.parentNode;
            }
            Polymer.dom(renderContainer).removeChild(current);
            delete config.hotSpots[i].div;
        }
    }
    hotspotsCreated = false;
    delete config.hotSpots;
}

/**
 * Renders hot spot, updating its position and visibility.
 * @private
 */
function renderHotSpot(hs) {
    var hsPitchSin = Math.sin(hs.pitch * Math.PI / 180),
        hsPitchCos = Math.cos(hs.pitch * Math.PI / 180),
        configPitchSin = Math.sin(config.pitch * Math.PI / 180),
        configPitchCos = Math.cos(config.pitch * Math.PI / 180),
        yawCos = Math.cos((-hs.yaw + config.yaw) * Math.PI / 180);
    var z = hsPitchSin * configPitchSin + hsPitchCos * yawCos * configPitchCos;
    if ((hs.yaw <= 90 && hs.yaw > -90 && z <= 0) ||
      ((hs.yaw > 90 || hs.yaw <= -90) && z <= 0)) {
        hs.div.style.visibility = 'hidden';
    } else {
        var yawSin = Math.sin((-hs.yaw + config.yaw) * Math.PI / 180),
            hfovTan = Math.tan(config.hfov * Math.PI / 360);
        hs.div.style.visibility = 'visible';
        // Subpixel rendering doesn't work in Firefox
        // https://bugzilla.mozilla.org/show_bug.cgi?id=739176
        var canvas = renderer.getCanvas(),
            canvasWidth = canvas.width / (window.devicePixelRatio || 1),
            canvasHeight = canvas.height / (window.devicePixelRatio || 1);
        var coord = [-canvasWidth / hfovTan * yawSin * hsPitchCos / z / 2,
            -canvasWidth / hfovTan * (hsPitchSin * configPitchCos -
            hsPitchCos * yawCos * configPitchSin) / z / 2];
        // Apply roll
        var rollSin = Math.sin(config.roll * Math.PI / 180),
            rollCos = Math.cos(config.roll * Math.PI / 180);
        coord = [coord[0] * rollCos - coord[1] * rollSin,
                 coord[0] * rollSin + coord[1] * rollCos];
        // Apply transform
        coord[0] += (canvasWidth - hs.div.offsetWidth) / 2;
        coord[1] += (canvasHeight - hs.div.offsetHeight) / 2;
        var transform = 'translate(' + coord[0] + 'px, ' + coord[1] +
            'px) translateZ(9999px) rotate(' + config.roll + 'deg)';
        hs.div.style.webkitTransform = transform;
        hs.div.style.MozTransform = transform;
        hs.div.style.transform = transform;
    }
}

/**
 * Renders hot spots, updating their positions and visibility.
 * @private
 */
function renderHotSpots() {
    config.hotSpots.forEach(renderHotSpot);
}

/**
 * Merges a scene configuration into the current configuration.
 * @private
 * @param {string} sceneId - Identifier of scene configuration to merge in.
 */
function mergeConfig(sceneId) {
    config = {};
    var k;
    var photoSphereExcludes = ['haov', 'vaov', 'vOffset', 'northOffset', 'horizonPitch', 'horizonRoll'];
    specifiedPhotoSphereExcludes = [];
    
    // Merge default config
    for (k in defaultConfig) {
        if (defaultConfig.hasOwnProperty(k)) {
            config[k] = defaultConfig[k];
        }
    }
    
    // Merge default scene config
    for (k in initialConfig.default) {
        if (initialConfig.default.hasOwnProperty(k)) {
            config[k] = initialConfig.default[k];
            if (photoSphereExcludes.indexOf(k) >= 0) {
                specifiedPhotoSphereExcludes.push(k);
            }
        }
    }
    
    // Merge current scene config
    if ((sceneId !== null) && (sceneId !== '') && (initialConfig.scenes) && (initialConfig.scenes[sceneId])) {
        var scene = initialConfig.scenes[sceneId];
        for (k in scene) {
            if (scene.hasOwnProperty(k)) {
                config[k] = scene[k];
                if (photoSphereExcludes.indexOf(k) >= 0) {
                    specifiedPhotoSphereExcludes.push(k);
                }
            }
        }
        config.scene = sceneId;
    }
    
    // Merge initial config
    for (k in initialConfig) {
        if (initialConfig.hasOwnProperty(k)) {
            config[k] = initialConfig[k];
            if (photoSphereExcludes.indexOf(k) >= 0) {
                specifiedPhotoSphereExcludes.push(k);
            }
        }
    }
}

/**
 * Processes configuration options.
 * @private
 */
function processOptions() {
    // Process preview first so it always loads before the browser hits its
    // maximum number of connections to a server as can happen with cubic
    // panoramas
    if ('preview' in config) {
        var p = config.preview;
        if (config.basePath) {
            p = config.basePath + p;
        }
        preview = document.createElement('div');
        preview.className = 'pnlm-preview-img';
        preview.style.backgroundImage = "url('" + encodeURI(p) + "')";
        Polymer.dom(renderContainer).appendChild(preview);
    }

    // Reset title / author display
    if (!config.hasOwnProperty('title'))
        infoDisplay.title.innerHTML = '';
    if (!config.hasOwnProperty('author'))
        infoDisplay.author.innerHTML = '';
    if (!config.hasOwnProperty('title') && !config.hasOwnProperty('author'))
        infoDisplay.container.style.display = 'none';

    // Process other options
    for (var key in config) {
      if (config.hasOwnProperty(key)) {
        switch(key) {
            case 'title':
                infoDisplay.title.innerHTML = escapeHTML(config[key]);
                infoDisplay.container.style.display = 'inline';
                break;
            
            case 'author':
                infoDisplay.author.innerHTML = 'by ' + escapeHTML(config[key]);
                infoDisplay.container.style.display = 'inline';
                break;
            
            case 'fallback':
                infoDisplay.errorMsg.innerHTML = '<p>Your browser does not support WebGL.<br><a href="' + encodeURI(config[key]) + '" target="_blank">Click here to view this panorama in an alternative viewer.</a></p>';
                break;
            
            case 'hfov':
                setHfov(Number(config[key]));
                break;
            
            case 'autoLoad':
                if (config[key] === true && renderer === undefined) {
                    // Show loading box
                    infoDisplay.load.box.style.display = 'inline';
                    // Hide load button
                    controls.load.style.display = 'none';
                    // Initialize
                    init();
                }
                break;
            
            case 'showZoomCtrl':
                if (config[key] && config.showControls != false) {
                    // Show zoom controls
                    controls.zoom.style.display = 'block';
                } else {
                    // Hide zoom controls
                    controls.zoom.style.display = 'none';
                }
                break;

            case 'showFullscreenCtrl':
                if (config[key] && config.showControls != false && ('fullscreen' in document || 'mozFullScreen' in document ||
                    'webkitIsFullScreen' in document || 'msFullscreenElement' in document)) {
                    
                    // Show fullscreen control
                    controls.fullscreen.style.display = 'block';
                } else {
                    // Hide fullscreen control
                    controls.fullscreen.style.display = 'none';
                }
                break;

            case 'hotSpotDebug':
                if (config[key])
                    hotSpotDebugIndicator.style.display = 'block';
                else
                    hotSpotDebugIndicator.style.display = 'none';
                break;

            case 'showControls':
                if (!config[key]) {
                    controls.orientation.style.display = 'none';
                    controls.zoom.style.display = 'none';
                    controls.fullscreen.style.display = 'none';
                }
                break;

            case 'orientationOnByDefault':
                if (config[key])
                    startOrientation();
                break;
        }
      }
    }
}

/**
 * Toggles fullscreen mode.
 * @private
 */
function toggleFullscreen() {
    if (loaded && !error) {
        if (!fullscreenActive) {
            try {
                if (container.requestFullscreen) {
                    container.requestFullscreen();
                } else if (container.mozRequestFullScreen) {
                    container.mozRequestFullScreen();
                } else if (container.msRequestFullscreen) {
                    container.msRequestFullscreen();
                } else {
                    container.webkitRequestFullScreen();
                }
            } catch(event) {
                // Fullscreen doesn't work
            }
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.mozCancelFullScreen) {
                document.mozCancelFullScreen();
            } else if (document.webkitCancelFullScreen) {
                document.webkitCancelFullScreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
        }
    }
}

/**
 * Event handler for fullscreen changes.
 * @private
 */
function onFullScreenChange() {
    if (document.fullscreen || document.mozFullScreen || document.webkitIsFullScreen || document.msFullscreenElement) {
        controls.fullscreen.classList.add('pnlm-fullscreen-toggle-button-active');
        fullscreenActive = true;
    } else {
        controls.fullscreen.classList.remove('pnlm-fullscreen-toggle-button-active');
        fullscreenActive = false;
    }

    // Resize renderer (deal with browser quirks and fixes #155)
    renderer.resize();
    setHfov(config.hfov);
    animateInit();
}

/**
 * Increases panorama zoom. For use with zoom button.
 * @private
 */
function zoomIn() {
    if (loaded) {
        setHfov(config.hfov - 5);
        animateInit();
    }
}

/**
 * Decreases panorama zoom. For use with zoom button.
 * @private
 */
function zoomOut() {
    if (loaded) {
        setHfov(config.hfov + 5);
        animateInit();
    }
}

/**
 * Clamps horzontal field of view to viewer's limits.
 * @private
 * @param {number} hfov - Input horizontal field of view (in degrees)
 * @return {number} - Clamped horizontal field of view (in degrees)
 */
function constrainHfov(hfov) {
    // Keep field of view within bounds
    var minHfov = config.minHfov;
    if (config.type == 'multires' && renderer) {
        minHfov = Math.min(minHfov, renderer.getCanvas().width / (config.multiRes.cubeResolution / 90 * 0.9));
    }
    if (minHfov > config.maxHfov) {
        // Don't change view if bounds don't make sense
        console.log('HFOV bounds do not make sense (minHfov > maxHfov).')
        return config.hfov;
    } if (hfov < minHfov) {
        return minHfov;
    } else if (hfov > config.maxHfov) {
        return config.maxHfov;
    } else {
        return hfov;
    }
}

/**
 * Sets viewer's horizontal field of view.
 * @private
 * @param {number} hfov - Desired horizontal field of view in degrees.
 */
function setHfov(hfov) {
    config.hfov = constrainHfov(hfov);
}

/**
 * Stops auto rotation and animated moves.
 * @private
 */
function stopAnimation() {
    animatedMove = {};
    autoRotateSpeed = config.autoRotate ? config.autoRotate : autoRotateSpeed;
    config.autoRotate = false;
}

/**
 * Loads panorama.
 * @private
 */
function load() {
    // Since WebGL error handling is very general, first we clear any error box
    // since it is a new scene and the error from previous maybe because of lacking
    // memory etc and not because of a lack of WebGL support etc
    clearError();

    controls.load.style.display = 'none';
    infoDisplay.load.box.style.display = 'inline';
    init();
}

/**
 * Loads scene.
 * @private
 * @param {string} sceneId - Identifier of scene configuration to merge in.
 * @param {number} targetPitch - Pitch viewer should be centered on once scene loads.
 * @param {number} targetYaw - Yaw viewer should be centered on once scene loads.
 * @param {number} targetHfov - HFOV viewer should use once scene loads.
 * @param {boolean} [fadeDone] - If `true`, fade setup is skipped.
 */
function loadScene(sceneId, targetPitch, targetYaw, targetHfov, fadeDone) {
    loaded = false;
    animatedMove = {};
    
    // Set up fade if specified
    var fadeImg, workingPitch, workingYaw, workingHfov;
    if (config.sceneFadeDuration && !fadeDone) {
        fadeImg = new Image();
        fadeImg.className = 'pnlm-fade-img';
        fadeImg.style.transition = 'opacity ' + (config.sceneFadeDuration / 1000) + 's';
        fadeImg.style.width = '100%';
        fadeImg.style.height = '100%';
        fadeImg.onload = function() {
            loadScene(sceneId, targetPitch, targetYaw, targetHfov, true);
        };
        var data = renderer.render(config.pitch * Math.PI / 180, config.yaw * Math.PI / 180, config.hfov * Math.PI / 180, {returnImage: true});
        if (data !== undefined) {
            fadeImg.src = data;
        }
        Polymer.dom(renderContainer).appendChild(fadeImg);
        renderer.fadeImg = fadeImg;
        return;
    }
    
    // Set new pointing
    if (targetPitch === 'same') {
        workingPitch = config.pitch;
    } else {
        workingPitch = targetPitch;
    }
    if (targetYaw === 'same') {
        workingYaw = config.yaw;
    } else if (targetYaw === 'sameAzimuth') {
        workingYaw = config.yaw + config.northOffset - initialConfig.scenes[sceneId].northOffset;
    } else {
        workingYaw = targetYaw;
    }
    if (targetHfov === 'same') {
        workingHfov = config.hfov;
    } else {
        workingHfov = targetHfov;
    }
    
    // Destroy hot spots from previous scene
    destroyHotSpots();
    
    // Create the new config for the scene
    mergeConfig(sceneId);

    // Stop motion
    speed.yaw = speed.pitch = speed.hfov = 0;

    // Reload scene
    processOptions();
    if (workingPitch !== undefined) {
        config.pitch = workingPitch;
    }
    if (workingYaw !== undefined) {
        config.yaw = workingYaw;
    }
    if (workingHfov !== undefined) {
        config.hfov = workingHfov;
    }
    fireEvent('scenechange', sceneId);
    load();
}

/**
 * Stop using device orientation.
 * @private
 */
function stopOrientation() {
    window.removeEventListener('deviceorientation', orientationListener);
    controls.orientation.classList.remove('pnlm-orientation-button-active');
    orientation = false;
}

/**
 * Start using device orientation.
 * @private
 */
function startOrientation() {
    orientation = true;
    window.addEventListener('deviceorientation', orientationListener);
    controls.orientation.classList.add('pnlm-orientation-button-active');
    requestAnimationFrame(animate);
}

/**
 * Escapes HTML string (to mitigate possible DOM XSS attacks).
 * @private
 * @param {string} s - String to escape
 * @returns {string} Escaped string
 */
function escapeHTML(s) {
    return String(s).replace(/&/g, '&amp;')
        .replace('"', '&quot;')
        .replace("'", '&#39;')
        .replace('<', '&lt;')
        .replace('>', '&gt;')
        .replace('/', '&#x2f;');
}

/**
 * Returns the pitch of the center of the view.
 * @memberof Viewer
 * @instance
 * @returns {number} Pitch in degrees
 */
this.getPitch = function() {
    return config.pitch;
};

/**
 * Sets the pitch of the center of the view.
 * @memberof Viewer
 * @instance
 * @param {number} pitch - Pitch in degrees
 * @param {boolean|number} [animated=1000] - Animation duration in milliseconds or false for no animation
 * @returns {Viewer} `this`
 */
this.setPitch = function(pitch, animated) {
    animated = animated == undefined ? 1000: Number(animated);
    if (animated) {
        animatedMove.pitch = {
            'startTime': Date.now(),
            'startPosition': config.pitch,
            'endPosition': pitch,
            'duration': animated
        }
    } else {
        config.pitch = pitch;
    }
    animateInit();
    return this;
};

/**
 * Returns the minimum and maximum allowed pitches (in degrees).
 * @memberof Viewer
 * @instance
 * @returns {number[]} [minimum pitch, maximum pitch]
 */
this.getPitchBounds = function() {
    return [config.minPitch, config.maxPitch];
};

/**
 * Set the minimum and maximum allowed pitches (in degrees).
 * @memberof Viewer
 * @instance
 * @param {number[]} bounds - [minimum pitch, maximum pitch]
 * @returns {Viewer} `this`
 */
this.setPitchBounds = function(bounds) {
    config.minPitch = Math.max(-90, Math.min(bounds[0], 90));
    config.maxPitch = Math.max(-90, Math.min(bounds[1], 90));
    return this;
};

/**
 * Returns the yaw of the center of the view.
 * @memberof Viewer
 * @instance
 * @returns {number} Yaw in degrees
 */
this.getYaw = function() {
    return config.yaw;
};

/**
 * Sets the yaw of the center of the view.
 * @memberof Viewer
 * @instance
 * @param {number} yaw - Yaw in degrees [-180, 180]
 * @param {boolean|number} [animated=1000] - Animation duration in milliseconds or false for no animation
 * @returns {Viewer} `this`
 */
this.setYaw = function(yaw, animated) {
    while (yaw > 180) {
        yaw -= 360;
    }
    while (yaw < -180) {
        yaw += 360;
    }
    animated = animated == undefined ? 1000: Number(animated);
    if (animated) {
        animatedMove.yaw = {
            'startTime': Date.now(),
            'startPosition': config.yaw,
            'endPosition': yaw,
            'duration': animated
        }
    } else {
        config.yaw = yaw;
    }
    animateInit();
    return this;
};

/**
 * Returns the minimum and maximum allowed pitches (in degrees).
 * @memberof Viewer
 * @instance
 * @returns {number[]} [yaw pitch, maximum yaw]
 */
this.getYawBounds = function() {
    return [config.minYaw, config.maxYaw];
};

/**
 * Set the minimum and maximum allowed yaws (in degrees [-180, 180]).
 * @memberof Viewer
 * @instance
 * @param {number[]} bounds - [minimum yaw, maximum yaw]
 * @returns {Viewer} `this`
 */
this.setYawBounds = function(bounds) {
    config.minYaw = Math.max(-180, Math.min(bounds[0], 180));
    config.maxYaw = Math.max(-180, Math.min(bounds[1], 180));
    return this;
};

/**
 * Returns the horizontal field of view.
 * @memberof Viewer
 * @instance
 * @returns {number} Horizontal field of view in degrees
 */
this.getHfov = function() {
    return config.hfov;
};

/**
 * Sets the horizontal field of view.
 * @memberof Viewer
 * @instance
 * @param {number} hfov - Horizontal field of view in degrees
 * @param {boolean|number} [animated=1000] - Animation duration in milliseconds or false for no animation
 * @returns {Viewer} `this`
 */
this.setHfov = function(hfov, animated) {
    animated = animated == undefined ? 1000: Number(animated);
    if (animated) {
        animatedMove.hfov = {
            'startTime': Date.now(),
            'startPosition': config.hfov,
            'endPosition': constrainHfov(hfov),
            'duration': animated
        }
    } else {
        setHfov(hfov);
    }
    animateInit();
    return this;
};

/**
 * Returns the minimum and maximum allowed horizontal fields of view
 * (in degrees).
 * @memberof Viewer
 * @instance
 * @returns {number[]} [minimum hfov, maximum hfov]
 */
this.getHfovBounds = function() {
    return [config.minHfov, config.maxHfov];
};

/**
 * Set the minimum and maximum allowed horizontal fields of view (in degrees).
 * @memberof Viewer
 * @instance
 * @param {number[]} bounds - [minimum hfov, maximum hfov]
 * @returns {Viewer} `this`
 */
this.setHfovBounds = function(bounds) {
    config.minHfov = Math.max(0, bounds[0]);
    config.maxHfov = Math.max(0, bounds[1]);
    return this;
};

/**
 * Set a new view. Any parameters not specified remain the same.
 * @memberof Viewer
 * @instance
 * @param {number} [pitch] - Target pitch
 * @param {number} [yaw] - Target yaw
 * @param {number} [hfov] - Target hfov
 * @param {boolean|number} [animated=1000] - Animation duration in milliseconds or false for no animation
 * @returns {Viewer} `this`
 */
this.lookAt = function(pitch, yaw, hfov, animated) {
    animated = animated == undefined ? 1000: Number(animated);
    if (pitch !== undefined)
        this.setPitch(pitch, animated);
    if (yaw !== undefined)
        this.setYaw(yaw, animated);
    if (hfov !== undefined)
        this.setHfov(hfov, animated);
    return this;
}

/**
 * Returns the panorama's north offset.
 * @memberof Viewer
 * @instance
 * @returns {number} North offset in degrees
 */
this.getNorthOffset = function() {
    return config.northOffset;
};

/**
 * Sets the panorama's north offset.
 * @memberof Viewer
 * @instance
 * @param {number} heading - North offset in degrees
 * @returns {Viewer} `this`
 */
this.setNorthOffset = function(heading) {
    config.northOffset = Math.min(360, Math.max(0, heading));
    animateInit();
    return this;
};

/**
 * Start auto rotation.
 * @memberof Viewer
 * @instance
 * @param {number} [speed] - Auto rotation speed / direction. If not specified, previous value is used.
 * @returns {Viewer} `this`
 */
this.startAutoRotate = function(speed) {
    speed = speed || autoRotateSpeed || 1;
    config.autoRotate = speed;
    _this.lookAt(origPitch, undefined, origHfov, 3000);
    animateInit();
    return this;
};

/**
 * Stop auto rotation.
 * @memberof Viewer
 * @instance
 * @returns {Viewer} `this`
 */
this.stopAutoRotate = function() {
    autoRotateSpeed = config.autoRotate ? config.autoRotate : autoRotateSpeed;
    config.autoRotate = false;
    config.autoRotateInactivityDelay = -1;
    return this;
};

/**
 * Returns the panorama renderer.
 * @memberof Viewer
 * @instance
 * @returns {Renderer}
 */
this.getRenderer = function() {
    return renderer;
};

/**
 * Sets update flag for dynamic content.
 * @memberof Viewer
 * @instance
 * @param {boolean} bool - Whether or not viewer should update even when still
 * @returns {Viewer} `this`
 */
this.setUpdate = function(bool) {
    update = bool === true;
    if (renderer === undefined)
        onImageLoad();
    else
        animateInit();
    return this;
}

/**
 * Calculate panorama pitch and yaw from location of mouse event.
 * @memberof Viewer
 * @instance
 * @param {MouseEvent} event - Document mouse down event.
 * @returns {number[]} [pitch, yaw]
 */
this.mouseEventToCoords = function(event) {
    return mouseEventToCoords(event);
}

/**
 * Change scene being viewed.
 * @memberof Viewer
 * @instance
 * @param {string} sceneId - Identifier of scene to switch to.
 * @param {number} [pitch] - Pitch to use with new scene
 * @param {number} [yaw] - Yaw to use with new scene
 * @param {number} [hfov] - HFOV to use with new scene
 * @returns {Viewer} `this`
 */
this.loadScene = function(sceneId, pitch, yaw, hfov) {
    if (loaded)
        loadScene(sceneId, pitch, yaw, hfov);
    return this;
}

/**
 * Get ID of current scene.
 * @memberof Viewer
 * @instance
 * @returns {string} ID of current scene
 */
this.getScene = function() {
    return config.scene;
}

/**
 * Add a new scene.
 * @memberof Viewer
 * @instance
 * @param {string} sceneId - The ID of the new scene
 * @param {string} config - The configuration of the new scene
 * @returns {Viewer} `this`
 */
this.addScene = function(sceneId, config) {
    initialConfig.scenes[sceneId] = config;
    return this;
};

/**
 * Remove a scene.
 * @memberof Viewer
 * @instance
 * @param {string} sceneId - The ID of the scene
 * @returns {boolean} False if the scene is the current scene or if the scene doesn't exists, else true
 */
this.removeScene = function(sceneId) {
    if (config.scene === sceneId || !initialConfig.scenes.hasOwnProperty(sceneId))
        return false;
    delete initialConfig.scenes[sceneId];
    return true;
};

/**
 * Toggle fullscreen.
 * @memberof Viewer
 * @instance
 * @returns {Viewer} `this`
 */
this.toggleFullscreen = function() {
    toggleFullscreen();
    return this;
}

/**
 * Get configuration of current scene.
 * @memberof Viewer
 * @instance
 * @returns {Object} Configuration of current scene
 */
this.getConfig = function() {
    return config;
}

/**
 * Add a new hot spot.
 * @memberof Viewer
 * @instance
 * @param {Object} hs - The configuration for the hot spot
 * @param {string} [sceneId] - Adds hot spot to specified scene if provided, else to current scene
 * @returns {Viewer} `this`
 * @throws Throws an error if the scene ID is provided but invalid
 */
this.addHotSpot = function(hs, sceneId) {
    if (sceneId === undefined || config.scene == sceneId) {
        // Add to current scene
        createHotSpot(hs);
        config.hotSpots.push(hs);
        renderHotSpot(hs);
    } else {
        // Add to a different scene
        if (initialConfig.scenes.hasOwnProperty(sceneId))
            initialConfig.scenes[sceneId].hotSpots.push(hs);
        else
            throw 'Invalid scene ID!'
    }
    return this;
}

/**
 * Remove a hot spot.
 * @memberof Viewer
 * @instance
 * @param {string} hotSpotId - The ID of the hot spot
 * @returns {boolean} True if deletion is successful, else false
 */
//this.removeHotSpot = function(hotSpotId) {
//    if (!config.hotSpots)
//        return false;
//    for (var i = 0; i < config.hotSpots.length; i++) {
//        if (config.hotSpots[i].hasOwnProperty('id') &&
//            config.hotSpots[i].id === hotSpotId) {
//            // Delete hot spot DOM elements
//            var current = config.hotSpots[i].div;
//            while (current.parentNode != renderContainer)
//                current = current.parentNode;
//            renderContainer.removeChild(current);
//            delete config.hotSpots[i].div;
//            // Remove hot spot from configuration
//            config.hotSpots.splice(i, 1);
//            return true;
//        }
//    }
//    return false;
//}

/******* MODIFIED *******/
this.removeHotSpot = function(hotSpotId, sceneId) {
    if (sceneId === undefined || config.scene == sceneId) {
        if (!config.hotSpots)
        return false;
        for (var i = 0; i < config.hotSpots.length; i++) {
            if (config.hotSpots[i].hasOwnProperty('id') &&
                config.hotSpots[i].id === hotSpotId) {
                // Delete hot spot DOM elements
                var current = config.hotSpots[i].div;
                while (current.parentNode != renderContainer)
                    current = current.parentNode;
                Polymer.dom(renderContainer).removeChild(current);
                delete config.hotSpots[i].div;
                // Remove hot spot from configuration
                config.hotSpots.splice(i, 1);
                return true;
            }
        }
        return false;
    } else {
        if (initialConfig.scenes.hasOwnProperty(sceneId)) { 
            if (!initialConfig.scenes[sceneId].hotSpots)
            return false;
            for (var i = 0; i < initialConfig.scenes[sceneId].hotSpots.length; i++) {
                if (initialConfig.scenes[sceneId].hotSpots[i].hasOwnProperty('id') &&
                    initialConfig.scenes[sceneId].hotSpots[i].id === hotSpotId) {
                    // Remove hot spot from configuration
                    initialConfig.scenes[sceneId].hotSpots.splice(i, 1);
                    return true;
                }
            }
            return false;
        }
        else
            throw 'Invalid scene ID!'
    } 
}
/******* MODIFIED *******/

/**
 * Subscribe listener to specified event.
 * @memberof Viewer
 * @instance
 * @param {string} type - Type of event to subscribe to.
 * @param {Function} listener - Listener function to subscribe to event.
 * @returns {Viewer} `this`
 */
this.on = function(type, listener) {
    externalEventListeners[type] = externalEventListeners[type] || [];
    externalEventListeners[type].push(listener);
    return this;
}

/**
 * Remove an event listener (or listeners).
 * @memberof Viewer
 * @param {string} [type] - Type of event to remove listeners from. If not specified, all listeners are removed.
 * @param {Function} [listener] - Listener function to remove. If not specified, all listeners of specified type are removed.
 * @returns {Viewer} `this`
 */
this.off = function(type, listener) {
    if (!type) {
        // Remove all listeners if type isn't specified
        externalEventListeners = {};
        return this;
    }
    if (listener) {
        var i = externalEventListeners[type].indexOf(listener);
        if (i >= 0) {
            // Remove listener if found
            externalEventListeners[type].splice(i, 1);
        }
        if (externalEventListeners[type].length = 0) {
            // Remove category if empty
            delete externalEventListeners[type];
        }
    } else {
        // Remove category of listeners if listener isn't specified
        delete externalEventListeners[type];
    }
    return this;
}

/**
 * Fire listeners attached to specified event.
 * @private
 * @param {string} [type] - Type of event to fire listeners for.
 */
function fireEvent(type) {
    if (type in externalEventListeners) {
        for (var i = 0; i < externalEventListeners[type].length; i++) {
            externalEventListeners[type][i].apply(null, [].slice.call(arguments, 1));
        }
    }
}

/**
 * Destructor.
 * @instance
 * @memberof Viewer
 */
this.destroy = function() {
    if (renderer)
        renderer.destroy()
    if (listenersAdded) {
        dragFix.removeEventListener('mousedown', onDocumentMouseDown, false);
        document.removeEventListener('mousemove', onDocumentMouseMove, false);
        document.removeEventListener('mouseup', onDocumentMouseUp, false);
        container.removeEventListener('mousewheel', onDocumentMouseWheel, false);
        container.removeEventListener('DOMMouseScroll', onDocumentMouseWheel, false);
        container.removeEventListener('mozfullscreenchange', onFullScreenChange, false);
        container.removeEventListener('webkitfullscreenchange', onFullScreenChange, false);
        container.removeEventListener('msfullscreenchange', onFullScreenChange, false);
        container.removeEventListener('fullscreenchange', onFullScreenChange, false);
        window.removeEventListener('resize', onDocumentResize, false);
        window.removeEventListener('orientationchange', onDocumentResize, false);
        container.removeEventListener('keydown', onDocumentKeyPress, false);
        container.removeEventListener('keyup', onDocumentKeyUp, false);
        container.removeEventListener('blur', clearKeys, false);
        document.removeEventListener('mouseleave', onDocumentMouseUp, false);
        dragFix.removeEventListener('touchstart', onDocumentTouchStart, false);
        dragFix.removeEventListener('touchmove', onDocumentTouchMove, false);
        dragFix.removeEventListener('touchend', onDocumentTouchEnd, false);
        dragFix.removeEventListener('pointerdown', onDocumentPointerDown, false);
        dragFix.removeEventListener('pointermove', onDocumentPointerMove, false);
        dragFix.removeEventListener('pointerup', onDocumentPointerUp, false);
        dragFix.removeEventListener('pointerleave', onDocumentPointerUp, false);
    }
    container.innerHTML = '';
    container.classList.remove('pnlm-container');
    container.classList.remove('pnlm-grab');
    container.classList.remove('pnlm-grabbing');
}

}

return {
    viewer: function(container, config) {
        return new Viewer(container, config);
    }
};

})(window, document);
</script>

<dom-module id="inkd-pano-scene" assetpath="inkd-elements/panorama/">
    
    <template>
        <content></content>
    </template>
    
    </dom-module><dom-module id="inkd-pano-hotspot" assetpath="inkd-elements/panorama/">
        
    </dom-module><dom-module id="inkd-pano" assetpath="inkd-elements/panorama/">
    
    <template>   
        <style>
            :host {
                display: block;
                position: relative;
                width: var(--width);
                height: var(--height);
            }
            
            #panorama {
                position: relative;
                z-index: 0;
                width: 100%;
                height: 100%;
            }
            
            .errorWrapper {
                position: absolute;
                width: 100%;
                height: 100%;
                background-color: lightgray;
                z-index: 3;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            .errorText {
                max-width: 60%;
                text-align: center;
            }
        </style>
        
        <div id="panorama">
            <template is="dom-if" if="[[_error]]">
                <div class="errorWrapper">
                    <p class="errorText" inner-h-t-m-l="[[_errorText]]"></p>
                </div>
            </template>
            <content select="inkd-modal"></content>
        </div>
        <content></content>
    </template>
    
    </dom-module><dom-module id="inkd-img" assetpath="inkd-elements/">

    <template>
        <style>
            :host {
                visibility: hidden;
                display: inline-block;
                position: relative;
            }
            img {
                all: inherit;
                transform: none;
                visibility: visible;
                top: 0;
                bottom: 0;
                left: 0;
                right: 0;
                width: 100%;
                height: 100%;
            }
        </style>
        
        <img id="image" src="[[src]]" style$="width: {{width}}; height: {{height}};" alt="[[alt]]" longdesc="[[longdesc]]" on-load="_handleLoad" on-error="_handleError">
    </template>

    </dom-module><dom-module id="inkd-audio" assetpath="inkd-elements/">
    
    <template>
        <template is="dom-if" if="[[_createHtmlAudio]]">
            <audio id="audioElement" controls="[[controls]]" loop="[[loop]]" preload="[[preload]]" on-play="_handlePlay" on-pause="_handlePause" on-volumechange="_handleVolumeChange">
                <source src="[[src]]" type="[[_mediaType]]" on-error="_handleError">
            </audio>
        </template>
    </template>
    
    </dom-module>
<div hidden="" by-vulcanize="">
<dom-module id="iron-localstorage" assetpath="libraries/youtube-api/"></dom-module>
<script>

  Polymer({
    is: 'iron-localstorage',

    properties: {
      /**
       * localStorage item key
       */
      name: {
        type: String,
        value: ''
      },
      /**
       * The data associated with this storage.
       * If set to null item will be deleted.
       * @type {*}
       */
      value: {
        type: Object,
        notify: true
      },

      /**
       * If true: do not convert value to JSON on save/load
       */
      useRaw: {
        type: Boolean,
        value: false
      },

      /**
       * Value will not be saved automatically if true. You'll have to do it manually with `save()`
       */
      autoSaveDisabled: {
        type: Boolean,
        value: false
      },
      /**
       * Last error encountered while saving/loading items
       */
      errorMessage: {
        type: String,
        notify: true
      },

      /** True if value has been loaded */
      _loaded: {
        type: Boolean,
        value: false
      }
    },

    observers: [
      '_debounceReload(name,useRaw)',
      '_trySaveValue(autoSaveDisabled)',
      '_trySaveValue(value.*)'
    ],

    ready: function() {
      this._boundHandleStorage = this._handleStorage.bind(this);
    },

    attached: function() {
      window.addEventListener('storage', this._boundHandleStorage);
    },

    detached: function() {
      window.removeEventListener('storage', this._boundHandleStorage);
    },

    _handleStorage: function(ev) {
      if (ev.key == this.name) {
        this._load(true);
      }
    },

    _trySaveValue: function() {
      if (this.autoSaveDisabled === undefined || this._doNotSave) {
        return;
      }

      if (this._loaded && !this.autoSaveDisabled) {
        this.debounce('save', this.save);
      }
    },

    _debounceReload: function() {
      if (this.name !== undefined && this.useRaw !== undefined) {
        this.debounce('reload', this.reload);
      }
    },

    /**
     * Loads the value again. Use if you modify
     * localStorage using DOM calls, and want to
     * keep this element in sync.
     */
    reload: function() {
      this._loaded = false;
      this._load();
    },

    /**
     * loads value from local storage
     * @param {boolean=} externalChange true if loading changes from a different window
     */
    _load: function(externalChange) {
      try {
        var v = window.localStorage.getItem(this.name);
      } catch (ex) {
        this.errorMessage = ex.message;

        this._error("Could not save to localStorage.  Try enabling cookies for this page.", ex);
      };

      if (v === null) {
        this._loaded = true;
        this._doNotSave = true;  // guard for save watchers
        this.value = null;
        this._doNotSave = false;
        this.fire('iron-localstorage-load-empty', { externalChange: externalChange}, {composed: true});
      } else {
        if (!this.useRaw) {
          try { // parse value as JSON
            v = JSON.parse(v);
          } catch(x) {
            this.errorMessage = "Could not parse local storage value";
            Polymer.Base._error("could not parse local storage value", v);
            v = null;
          }
        }
        this._loaded = true;
        this._doNotSave = true;
        this.value = v;
        this._doNotSave = false;
        this.fire('iron-localstorage-load', { externalChange: externalChange}, {composed: true});
      }
    },

    /**
     * Saves the value to localStorage. Call to save if autoSaveDisabled is set.
     * If `value` is null or undefined, deletes localStorage.
     */
    save: function() {
      var v = this.useRaw ? this.value : JSON.stringify(this.value);
      try {
        if (this.value === null || this.value === undefined) {
          window.localStorage.removeItem(this.name);
        } else {
          window.localStorage.setItem(this.name, /** @type {string} */ (v));
        }
      }
      catch(ex) {
        // Happens in Safari incognito mode,
        this.errorMessage = ex.message;
        Polymer.Base._error("Could not save to localStorage. Incognito mode may be blocking this action", ex);
      }
    }

    /**
     * Fired when value loads from localStorage.
     *
     * @event iron-localstorage-load
     * @param {{externalChange:boolean}} detail -
     *     externalChange: true if change occured in different window.
     */

    /**
     * Fired when loaded value does not exist.
     * Event handler can be used to initialize default value.
     *
     * @event iron-localstorage-load-empty
     * @param {{externalChange:boolean}} detail -
     *     externalChange: true if change occured in different window.
     */
  });

</script>

<script>
(function() {
  "use strict";
  /**
   * `Polymer.IronJsonpLibraryBehavior` loads a jsonp library.
   * Multiple components can request same library, only one copy will load.
   *
   * Some libraries require a specific global function be defined.
   * If this is the case, specify the `callbackName` property.
   *
   * You should use an HTML Import to load library dependencies
   * when possible instead of using this element.
   *
   * @hero hero.svg
   * @demo demo/index.html
   * @polymerBehavior
   */
  Polymer.IronJsonpLibraryBehavior = {

    properties: {
      /**
       * True if library has been successfully loaded
       */
      libraryLoaded: {
        type: Boolean,
        value: false,
        notify: true,
        readOnly: true
      },
      /**
       * Not null if library has failed to load
       */
      libraryErrorMessage: {
        type: String,
        value: null,
        notify: true,
        readOnly: true
      }
      // Following properties are to be set by behavior users
      /**
       * Library url. Must contain string `%%callback%%`.
       *
       * `%%callback%%` is a placeholder for jsonp wrapper function name
       *
       * Ex: https://maps.googleapis.com/maps/api/js?callback=%%callback%%
       * @property libraryUrl
       */
      /**
       * Set if library requires specific callback name.
       * Name will be automatically generated if not set.
       * @property callbackName
       */
      /**
       * name of event to be emitted when library loads. Standard is `api-load`
       * @property notifyEvent
       */
      /**
       * event with name specified in `notifyEvent` attribute
       * will fire upon successful load2
       * @event `notifyEvent`
       */
    },

    observers: [
      '_libraryUrlChanged(libraryUrl)'
    ],

    _libraryUrlChanged: function(libraryUrl) {
      // can't load before ready because notifyEvent might not be set
      if (this._isReady && this.libraryUrl)
        this._loadLibrary();
    },

    _libraryLoadCallback: function(err, result) {
      if (err) {
        Polymer.Base._warn("Library load failed:", err.message);
        this._setLibraryErrorMessage(err.message);
      }
      else {
        this._setLibraryErrorMessage(null);
        this._setLibraryLoaded(true);
        if (this.notifyEvent)
          this.fire(this.notifyEvent, result, {composed: true});
      }
    },

    /** loads the library, and fires this.notifyEvent upon completion */
    _loadLibrary: function() {
      LoaderMap.require(
        this.libraryUrl,
        this._libraryLoadCallback.bind(this),
        this.callbackName
      );
    },

    ready: function() {
      this._isReady = true;
      if (this.libraryUrl)
        this._loadLibrary();
    }
  };

  /**
   * LoaderMap keeps track of all Loaders
   */
  var LoaderMap = {
    apiMap: {}, // { hash -> Loader }

    /**
     * @param {Function} notifyCallback loaded callback fn(result)
     * @param {string} jsonpCallbackName name of jsonpcallback. If API does not provide it, leave empty. Optional.
     */
    require: function(url, notifyCallback, jsonpCallbackName) {

      // make hashable string form url
      var name = this.nameFromUrl(url);

      // create a loader as needed
      if (!this.apiMap[name])
        this.apiMap[name] = new Loader(name, url, jsonpCallbackName);

      // ask for notification
      this.apiMap[name].requestNotify(notifyCallback);
    },

    nameFromUrl: function(url) {
      return url.replace(/[\:\/\%\?\&\.\=\-\,]/g, '_') + '_api';
    }
  };

  /** @constructor */
  var Loader = function(name, url, callbackName) {
    this.notifiers = [];  // array of notifyFn [ notifyFn* ]

    // callback is specified either as callback name
    // or computed dynamically if url has callbackMacro in it
    if (!callbackName) {
      if (url.indexOf(this.callbackMacro) >= 0) {
        callbackName = name + '_loaded';
        url = url.replace(this.callbackMacro, callbackName);
      } else {
        this.error = new Error('IronJsonpLibraryBehavior a %%callback%% parameter is required in libraryUrl');
        // TODO(sjmiles): we should probably fallback to listening to script.load
        return;
      }
    }
    this.callbackName = callbackName;
    window[this.callbackName] = this.success.bind(this);
    this.addScript(url);
  };

  Loader.prototype = {

    callbackMacro: '%%callback%%',
    loaded: false,

    addScript: function(src) {
      var script = document.createElement('script');
      script.src = src;
      script.onerror = this.handleError.bind(this);
      var s = document.querySelector('script') || document.body;
      s.parentNode.insertBefore(script, s);
      this.script = script;
    },

    removeScript: function() {
      if (this.script.parentNode) {
        this.script.parentNode.removeChild(this.script);
      }
      this.script = null;
    },

    handleError: function(ev) {
      this.error = new Error("Library failed to load");
      this.notifyAll();
      this.cleanup();
    },

    success: function() {
      this.loaded = true;
      this.result = Array.prototype.slice.call(arguments);
      this.notifyAll();
      this.cleanup();
    },

    cleanup: function() {
      delete window[this.callbackName];
    },

    notifyAll: function() {
      this.notifiers.forEach( function(notifyCallback) {
        notifyCallback(this.error, this.result);
      }.bind(this));
      this.notifiers = [];
    },

    requestNotify: function(notifyCallback) {
      if (this.loaded || this.error) {
        notifyCallback( this.error, this.result);
      } else {
        this.notifiers.push(notifyCallback);
      }
    }
  };
})();
</script>



<script>
  Polymer({

    is: 'google-youtube-api',

    behaviors: [
      Polymer.IronJsonpLibraryBehavior
    ],

    properties: {

      /** @private */
      libraryUrl:  {
        type: String,
        value: 'https://www.youtube.com/iframe_api'
      },

      /**
       * Fired when the API library is loaded and available.
       * @event api-load
       */
      /**
       * Name of event fired when library loads.
       */
      notifyEvent:  {
        type: String,
        value: 'api-load'
      },

      callbackName:  {
        type: String,
        value: 'onYouTubeIframeAPIReady'
      }

    },

    get api() {
      return YT;
    }

  });
</script><dom-module id="google-youtube" assetpath="libraries/youtube-api/">
  <style>
    :host {
      display: block;
    }

    :host([fluid]) {
      width: 100%;
      max-width: 100%;
      position: relative;
    }

    :host([fluid]) iframe,
    :host([fluid]) #thumbnail {
      vertical-align: bottom;
      position: absolute;
      top: 0px;
      left: 0px;
      width: 100%;
      height: 100%;
    }

    iframe {
      @apply(--google-youtube-iframe);
    }

    #container {
      max-width: 100%;
      max-height: 100%;
      @apply(--google-youtube-container);
    }

    #thumbnail {
      width: 100%;
      height: 100%;
      cursor: pointer;
      @apply(--google-youtube-thumbnail);
    }
  </style>

  <template>
    <div id="container" style$="{{_computeContainerStyle(width, height)}}">
      <template is="dom-if" if="{{thumbnail}}">
        <img id="thumbnail" src$="{{thumbnail}}" title="YouTube video thumbnail." alt="YouTube video thumbnail." on-tap="_handleThumbnailTap">
      </template>

      <template is="dom-if" if="{{!thumbnail}}">
        <template is="dom-if" if="[[shouldLoadApi]]">
          <google-youtube-api on-api-load="_apiLoad"></google-youtube-api>
        </template>
      </template>

      
      <iron-localstorage name="google-youtube-playsupported" value="{{_playsupportedLocalStorage}}" on-iron-localstorage-load="_useExistingPlaySupportedValue" on-iron-localstorage-load-empty="_determinePlaySupported">
      </iron-localstorage>

      <div id="player"></div>
    </div>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'google-youtube',
    /**
     * Fired when the YouTube player is fully initialized and ready for use.
     *
     * @event google-youtube-ready
     */

    /**
     * Fired when the state of the player changes. `e.detail.data` is set to one of
     * [the documented](https://developers.google.com/youtube/iframe_api_reference#onStateChange)
     * states.
     *
     * @event google-youtube-state-change
     */

    /**
     * Fired when playback fails due to an error. `e.detail.data` is set to one of
     * [the documented](https://developers.google.com/youtube/iframe_api_reference#onError)
     * error codes.
     *
     * @event google-youtube-error
     */

    properties: {
        
        /******* MODIFIED *******/
        loop: {
            type: Boolean,
            value: false
        },
        
        controls: {
            type: Boolean,
            value: false
        },
        
        autoplay: {
            type: Boolean,
            value: false
        },
        /******* MODIFIED *******/
        
        
      /**
       * Sets the id of the video to play. Changing this attribute will trigger a call
       * to load a new video into the player (if `this.autoplay` is set to `1` and `playsupported` is true)
       * or cue a new video otherwise.
       *
       * The underlying YouTube embed will not be added to the page unless
       * `videoId` or `list` property is set.
       *
       * You can [search for videos programmatically](https://developers.google.com/youtube/v3/docs/search/list)
       * using the YouTube Data API, or just hardcode known video ids to display on your page.
       */
      videoId: {
        type: String,
        value: '',
        observer: '_videoIdChanged'
      },

      /**
       * The list parameter, in conjunction with the listType parameter, identifies the content that will load in the player.
       * If the listType parameter value is search, then the list parameter value specifies the search query.
       * If the listType parameter value is user_uploads, then the list parameter value identifies the YouTube channel whose uploaded videos will be loaded.
       * If the listType parameter value is playlist, then the list parameter value specifies a YouTube playlist ID. In the parameter value, you need to prepend the playlist ID with the letters PL as shown in the example below.
       *
       * See https://developers.google.com/youtube/player_parameters#list
       */
      list: {
        type: String,
        value: ''
      },

      /**
       * See https://developers.google.com/youtube/player_parameters#listtype
       */
      listType: String,

      /**
       * Decides whether YouTube API should be loaded.
       */
      shouldLoadApi: {
        type: Boolean,
        computed: '_computeShouldLoadApi(list, videoId)'
      },

      /**
       * Whether programmatic `<video>.play()` for initial playback is supported in the current browser.
       *
       * Most mobile browsers [do not support](https://developer.apple.com/library/safari/documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html#//apple_ref/doc/uid/TP40009523-CH5-SW1) autoplaying or scripted playback of videos.
       * If you attempt to automatically initiate playback of a `<google-youtube>`, e.g. by calling the `play()` method before
       * playback has initially begun, the YouTube Player will enter an unrecoverable "stuck" state.
       * To protect against this, check the value of `playsupported` and don't call `play()` if it is set to `false`.
       * (You can hide/disable your custom play button, etc.)
       *
       * The `playsupported` value is determined at runtime, by dynamically creating a `<video>` element with an
       * inlined data source and calling `play()` on it. (Inspired by [Modernizr](https://github.com/Modernizr/Modernizr/blob/master/feature-detects/video/autoplay.js).)
       *
       * If you would rather not incur the minimal overhead involved in going through this process, you can explicitly set
       * `playsupported` to `true` or `false` when initializing `<google-youtube>`. This is only recommended if you know that
       * your web app will never (or only) be used on mobile browsers.
       */
      playsupported: {
        type: Boolean,
        value: null,
        notify: true
      },  
      /**
       * Whether playback has started.
       *
       * This defaults to `false` and is set to `true` once the first 'playing' event is fired by
       * the underlying YouTube Player API.
       *
       * Once set to `true`, it will remain that way indefinitely.
       * Paused/buffering/ended events won't cause `playbackstarted` to reset to `false`.
       * Nor will loading a new video into the player.
       */
      playbackstarted: {
        type: Boolean,
        value: false,
        notify: true
      },

      /**
       * Sets the height of the player on the page.
       * Accepts anything valid for a CSS measurement, e.g. '200px' or '50%'.
       * If the unit of measurement is left off, 'px' is assumed.
       */
      height: {
        type: String,
        value: '270px'
      },

      /**
       * Sets the width of the player on the page.
       * Accepts anything valid for a CSS measurement, e.g. '200px' or '50%'.
       * If the unit of measurement is left off, 'px' is assumed.
       */
      width: {
        type: String,
        value:'480px'
      },

      /**
       * Exposes the current player state.
       * Using this attribute is an alternative to listening to `google-youtube-state-change` events,
       * and can simplify the logic in templates with conditional binding.
       *
       * The [possible values](https://developers.google.com/youtube/iframe_api_reference#onStateChange):
       *   - -1 (unstarted)
       *   - 0 (ended)
       *   - 1 (playing)
       *   - 2 (paused)
       *   - 3 (buffering)
       *   - 5 (video cued)
       */
      state: {
        type: Number,
        value: -1,
        notify: true
      },

      /**
       * Exposes the current playback time, in seconds.
       *
       * You can divide this value by the `duration` to determine the playback percentage.
       */
      currenttime: {
        type: Number,
        value: 0,
        notify: true
      },

      /**
       * Exposes the video duration, in seconds.
       *
       * You can divide the `currenttime` to determine the playback percentage.
       *
       * @attribute duration
       * @type number
       */
      duration: {
        type: Number,
        value: 1, // To avoid divide-by-zero errors if used before video is cued.
        notify: true
      },

      /**
       * Exposes the current playback time, formatted as a (HH:)MM:SS string.
       */
      currenttimeformatted: {
        type: String,
        value: '0:00',
        notify: true
      },

      /**
       * Exposes the video duration, formatted as a (HH:)MM:SS string.
       */
      durationformatted: {
        type: String,
        value: '0:00', // To avoid divide-by-zero errors if used before video is cued.
        notify: true
      },

      /**
       * The fraction of the bytes that have been loaded for the current video, in the range [0-1].
       */
      fractionloaded: {
        type: Number,
        value: 0,
        notify: true
      },

      /**
       * A shorthand to enable a set of player attributes that, used together, simulate a "chromeless" YouTube player.
       *
       * Equivalent to setting the following attributes:
       * - `controls="0"`
       * - `modestbranding="1"`
       * - `showinfo="0"`
       * - `iv_load_policy="3"`
       * - `rel="0"`
       *
       * The "chromeless" player has minimal YouTube branding in cued state, and the native controls
       * will be disabled during playback. Creating your own custom play/pause/etc. controls is recommended.
       */
      chromeless: {
        type: Boolean,
        value: false
      },
      /**
       * The URL of an image to use as a custom thumbnail.
       *
       * This is optional; if not provided, the standard YouTube embed (which uses the thumbnail associated
       * with the video on YouTube) will be used.
       *
       * If `thumbnail` is set, than an `<img>` containing the thumbnail will be used in lieu of the actual
       * YouTube embed. When the thumbnail is clicked, the `<img>` is swapped out for the actual YouTube embed,
       * which will have [`autoplay=1`](https://developers.google.com/youtube/player_parameters#autoplay) set by default (in additional to any other player parameters specified on this element).
       *
       * Please note that `autoplay=1` won't actually autoplay videos on mobile browsers, so two taps will be required
       * to play the video there. Also, on desktop browsers, setting `autoplay=1` will prevent the playback
       * from [incrementing the view count](https://support.google.com/youtube/answer/1714329) for the video.
       */
      thumbnail: {
        type: String,
        value: ''
      },

      /**
       * If `fluid` is set, then the player will set its width to 100% to fill
       * the parent container, while adding `padding-top` to preserve the
       * aspect ratio provided by `width` and `height`. If `width` and `height`
       * have not been set, the player will fall back to a 16:9 aspect ratio.
       * This is useful for responsive designs where you don't want to
       * introduce letterboxing on your video.
       */
      fluid: {
        type: Boolean,
        value: false
      },

      /**
       * Returns the player's current volume, an integer between 0 and 100.
       * Note that `getVolume()` will return the volume even if the player is muted.
       */
      volume: {
        type: Number,
        value: 100,
        notify: true
      },

      /**
       * This function retrieves the playback rate of the currently playing video.
       * The default playback rate is 1, which indicates that the video is playing at normal speed.
       * Playback rates may include values like `0.25`, `0.5`, `1`, `1.5`, and `2`.
       */
      playbackrate: {
        type: Number,
        value: 1,
        notify: true
      },

      /**
       * This function retrieves the actual video quality of the current video.
       * Possible return values are `highres`, `hd1080`, `hd720`, `large`, `medium` and `small`.
       * It will also return `undefined` if there is no current video.
       */
      playbackquality: {
        type: String,
        value: '',
        notify: true
      }

    },

    _computeContainerStyle: function(width, height) {
      return 'width:' + width + '; height:' + height;
    },

    _computeShouldLoadApi: function(videoId, list) {
      return Boolean(videoId || list);
    },

    _useExistingPlaySupportedValue: function() {
      this.playsupported = this._playsupportedLocalStorage;
    },

    /**
     * Detects whether programmatic <video>.play() is supported in the current browser.
     *
     * This is triggered via on-ironlocalstorage-load-empty. The logic is:
     * - If playsupported is explicitly set to true or false on the element, use that.
     * - Otherwise, if there's a cached value in localStorage, use that.
     * - Otherwise, create a hidden <video> element and call play() on it:
     *   - If playback starts, playsupported is true.
     *   - If playback doesn't start (within 500ms), playsupported is false.
     *   - Whatever happens, cache the result in localStorage.
     */
    _determinePlaySupported: function() {
      // If playsupported isn't already being overridden by the page using this component,
      // then attempt to determine if it's supported.
      // This is deliberately checking with ==, to match either undefined or null.
      if (this.playsupported == null) {
        // Run a new playback test.
        var timeout;
        var videoElement = document.createElement('video');

        if ('play' in videoElement) {
          videoElement.id = 'playtest';
          // Some browsers will refuse to play videos with 'display: none' set,
          // so position the video well offscreen instead.
          // Modify the .style property directly instead of using CSS to work around polyfill
          // issues; see https://github.com/GoogleWebComponents/google-youtube/issues/49
          videoElement.style.position = 'absolute';
          videoElement.style.top = '-9999px';
          videoElement.style.left = '-9999px';

          var mp4Source = document.createElement('source');
          mp4Source.src = "data:video/mp4;base64,AAAAFGZ0eXBNU05WAAACAE1TTlYAAAOUbW9vdgAAAGxtdmhkAAAAAM9ghv7PYIb+AAACWAAACu8AAQAAAQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAnh0cmFrAAAAXHRraGQAAAAHz2CG/s9ghv4AAAABAAAAAAAACu8AAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAAFAAAAA4AAAAAAHgbWRpYQAAACBtZGhkAAAAAM9ghv7PYIb+AAALuAAANq8AAAAAAAAAIWhkbHIAAAAAbWhscnZpZGVBVlMgAAAAAAABAB4AAAABl21pbmYAAAAUdm1oZAAAAAAAAAAAAAAAAAAAACRkaW5mAAAAHGRyZWYAAAAAAAAAAQAAAAx1cmwgAAAAAQAAAVdzdGJsAAAAp3N0c2QAAAAAAAAAAQAAAJdhdmMxAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAFAAOABIAAAASAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGP//AAAAEmNvbHJuY2xjAAEAAQABAAAAL2F2Y0MBTUAz/+EAGGdNQDOadCk/LgIgAAADACAAAAMA0eMGVAEABGjuPIAAAAAYc3R0cwAAAAAAAAABAAAADgAAA+gAAAAUc3RzcwAAAAAAAAABAAAAAQAAABxzdHNjAAAAAAAAAAEAAAABAAAADgAAAAEAAABMc3RzegAAAAAAAAAAAAAADgAAAE8AAAAOAAAADQAAAA0AAAANAAAADQAAAA0AAAANAAAADQAAAA0AAAANAAAADQAAAA4AAAAOAAAAFHN0Y28AAAAAAAAAAQAAA7AAAAA0dXVpZFVTTVQh0k/Ou4hpXPrJx0AAAAAcTVREVAABABIAAAAKVcQAAAAAAAEAAAAAAAAAqHV1aWRVU01UIdJPzruIaVz6ycdAAAAAkE1URFQABAAMAAAAC1XEAAACHAAeAAAABBXHAAEAQQBWAFMAIABNAGUAZABpAGEAAAAqAAAAASoOAAEAZABlAHQAZQBjAHQAXwBhAHUAdABvAHAAbABhAHkAAAAyAAAAA1XEAAEAMgAwADAANQBtAGUALwAwADcALwAwADYAMAA2ACAAMwA6ADUAOgAwAAABA21kYXQAAAAYZ01AM5p0KT8uAiAAAAMAIAAAAwDR4wZUAAAABGjuPIAAAAAnZYiAIAAR//eBLT+oL1eA2Nlb/edvwWZflzEVLlhlXtJvSAEGRA3ZAAAACkGaAQCyJ/8AFBAAAAAJQZoCATP/AOmBAAAACUGaAwGz/wDpgAAAAAlBmgQCM/8A6YEAAAAJQZoFArP/AOmBAAAACUGaBgMz/wDpgQAAAAlBmgcDs/8A6YEAAAAJQZoIBDP/AOmAAAAACUGaCQSz/wDpgAAAAAlBmgoFM/8A6YEAAAAJQZoLBbP/AOmAAAAACkGaDAYyJ/8AFBAAAAAKQZoNBrIv/4cMeQ==";
          videoElement.appendChild(mp4Source);

          var webmSource = document.createElement('source');
          webmSource.src = "data:video/webm;base64,GkXfo49CgoR3ZWJtQoeBAUKFgQEYU4BnAQAAAAAAF60RTZt0vE27jFOrhBVJqWZTrIIQA027jFOrhBZUrmtTrIIQbE27jFOrhBFNm3RTrIIXmU27jFOrhBxTu2tTrIIWs+xPvwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFUmpZuQq17GDD0JATYCjbGliZWJtbCB2MC43LjcgKyBsaWJtYXRyb3NrYSB2MC44LjFXQY9BVlNNYXRyb3NrYUZpbGVEiYRFnEAARGGIBc2Lz1QNtgBzpJCy3XZ0KNuKNZS4+fDpFxzUFlSua9iu1teBAXPFhL4G+bmDgQG5gQGIgQFVqoEAnIEAbeeBASMxT4Q/gAAAVe6BAIaFVl9WUDiqgQEj44OEE95DVSK1nIN1bmTgkbCBULqBPJqBAFSwgVBUuoE87EQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB9DtnVB4eeBAKC4obaBAAAAkAMAnQEqUAA8AABHCIWFiIWEiAICAAamYnoOC6cfJa8f5Zvda4D+/7YOf//nNefQYACgnKGWgQFNANEBAAEQEAAYABhYL/QACIhgAPuC/rOgnKGWgQKbANEBAAEQEAAYABhYL/QACIhgAPuC/rKgnKGWgQPoANEBAAEQEAAYABhYL/QACIhgAPuC/rOgnKGWgQU1ANEBAAEQEAAYABhYL/QACIhgAPuC/rOgnKGWgQaDANEBAAEQEAAYABhYL/QACIhgAPuC/rKgnKGWgQfQANEBAAEQEAAYABhYL/QACIhgAPuC/rOgnKGWgQkdANEBAAEQEBRgAGFgv9AAIiGAAPuC/rOgnKGWgQprANEBAAEQEAAYABhYL/QACIhgAPuC/rKgnKGWgQu4ANEBAAEQEAAYABhYL/QACIhgAPuC/rOgnKGWgQ0FANEBAAEQEAAYABhYL/QACIhgAPuC/rOgnKGWgQ5TANEBAAEQEAAYABhYL/QACIhgAPuC/rKgnKGWgQ+gANEBAAEQEAAYABhYL/QACIhgAPuC/rOgnKGWgRDtANEBAAEQEAAYABhYL/QACIhgAPuC/rOgnKGWgRI7ANEBAAEQEAAYABhYL/QACIhgAPuC/rIcU7trQOC7jLOBALeH94EB8YIUzLuNs4IBTbeH94EB8YIUzLuNs4ICm7eH94EB8YIUzLuNs4ID6LeH94EB8YIUzLuNs4IFNbeH94EB8YIUzLuNs4IGg7eH94EB8YIUzLuNs4IH0LeH94EB8YIUzLuNs4IJHbeH94EB8YIUzLuNs4IKa7eH94EB8YIUzLuNs4ILuLeH94EB8YIUzLuNs4INBbeH94EB8YIUzLuNs4IOU7eH94EB8YIUzLuNs4IPoLeH94EB8YIUzLuNs4IQ7beH94EB8YIUzLuNs4ISO7eH94EB8YIUzBFNm3SPTbuMU6uEH0O2dVOsghTM";
          videoElement.appendChild(webmSource);

          document.body.appendChild(videoElement);

          this.async(function() {
            // Ideally, we'll get a 'playing' event if we're on a browser that supports
            // programmatic play().
            videoElement.onplaying = function(e) {
              clearTimeout(timeout);

              this.playsupported = (e && e.type === 'playing') || videoElement.currentTime !== 0;
              this._playsupportedLocalStorage = this.playsupported;

              videoElement.onplaying = null;

              document.body.removeChild(videoElement);
            }.bind(this);

            // If we haven't received a 'playing' event within 500ms, then we're most likely on a browser that doesn't
            // support programmatic plays. Do a final check after 500ms and set this.playsupported at that point.
            timeout = setTimeout(videoElement.onplaying, 500);

            // Try to initiate playback...
            videoElement.play();
          });
        } else {
          // If there's no play() method then we know that it's not supported.
          this.playsupported = false;
          this._playsupportedLocalStorage = false;
        }
      }
    },

    /**
     * Sets fluid width/height.
     *
     * If the fluid attribute is set, the aspect ratio of the video will
     * be inferred (if set in pixels), or assumed to be 16:9. The element
     * will give itself enough top padding to force the player to use the
     * correct aspect ratio, even as the screen size changes.
     *
     */
    ready: function() {
      if (this.hasAttribute('fluid')) {
        var ratio = parseInt(this.height, 10) / parseInt(this.width, 10);
        if (isNaN(ratio)) {
          ratio = 9/16;
        }
        ratio *= 100;
        this.width = '100%';
        this.height = 'auto';
        this.$.container.style['padding-top'] = ratio + '%';
      }
    },
      
/******* MODIFIED *******/
      attached: function() {
          if (this._apiLoaded) {
            this._loadPlayer();
          }
      },    
/******* MODIFIED *******/
      
    /**
     * Clean up the underlying Player `<iframe>` when we're removed from the DOM.
     */
    detached: function() {
      if (this._player) {
        this._player.destroy();
          /******* MODIFIED *******/
          if (this.__updatePlaybackStatsInterval) {
            clearInterval(this.__updatePlaybackStatsInterval);
            this.__updatePlaybackStatsInterval = null;
          }
          /******* MODIFIED *******/
      }
    },

    /**
     * Plays the current video.
     *
     * Note that on certain mobile browsers, playback
     * [can't be initiated programmatically](https://developers.google.com/youtube/iframe_api_reference#Mobile_considerations).
     *
     * If `this.playsupported` is not `true`, calling `play()` will have no effect.
     *
     * @method play
     */
    play: function() {
      if (this._player && this._player.playVideo && this.playsupported) {
        this._player.playVideo();
      }
    },

    /**
     * Modifies the volume of the current video.
     *
     * Developers should take care not to break expected user experience by programmatically
     * modifying the volume on mobile browsers.
     * Note that the YouTube player, in addition, does not display volume controls in a
     * mobile environment.
     *
     * @method setVolume
     * @param {number} volume The new volume, an integer between 0 (muted) and 100 (loudest).
     */
    setVolume: function(volume) {
      if (this._player && this._player.setVolume) {
        this._player.setVolume(volume);
      }
    },

    /**
     * Mutes the current video.
     *
     * Developers should take care not to break expected user experience by programmatically
     * modifying the volume on mobile browsers.
     * Note that the YouTube player, in addition, does not display volume controls in a
     * mobile environment.
     *
     * @method mute
     */
    mute: function() {
      if (this._player && this._player.mute) {
        this._player.mute();
      }
    },

    /**
     * Unmutes the current video.
     *
     * Developers should take care not to break expected user experience by programmatically
     * modifying the volume on mobile browsers.
     * Note that the YouTube player, in addition, does not display volume controls in a
     * mobile environment.
     *
     * @method unMute
     */
    unMute: function() {
      if (this._player && this._player.unMute) {
        this._player.unMute();
      }
    },

    /**
     * Pauses the current video.
     *
     * @method pause
     */
    pause: function() {
      if (this._player && this._player.pauseVideo) {
        this._player.pauseVideo();
      }
    },

    /**
     * Skips ahead (or back) to the specified number of seconds.
     *
     * @method seekTo
     * @param {number} seconds Number of seconds to seek to.
     */
    seekTo: function(seconds) {
      if (this._player && this._player.seekTo) {
        this._player.seekTo(seconds, true);

        // Explicitly call _updatePlaybackStats() to ensure that the new playback info is
        // reflected in the bound attributes.
        // The 100ms delay is somewhat arbitrary, but the YouTube player does need time to
        // update its internal state following the call to player.seekTo().
        this.async(function() {
          this._updatePlaybackStats();
        }, 100);
      }
    },

    /**
     * This function sets the suggested playback rate for the current video.
     * If the playback rate changes, it will only change for the video that is already cued or being played.
     * If you set the playback rate for a cued video, that rate will still be in effect when the `playVideo` function is called or the user initiates playback directly through the player controls.
     * In addition, calling functions to cue or load videos or playlists (`cueVideoById`, `loadVideoById`, etc.) will reset the playback rate to 1.
     *
     * Calling this function does not guarantee that the playback rate will actually change.
     * However, if the playback rate does change, the `onPlaybackRateChange` event will fire, and your code should respond to the event rather than the fact that it called the `setPlaybackRate` function.
     *
     * The `getAvailablePlaybackRates` method will return the possible playback rates for the currently playing video.
     * However, if you set the `suggestedRate` parameter to a non-supported integer or float value, the player will round that value down to the nearest supported value in the direction of 1.
     *
     * @method setPlaybackRate
     * @param {number} suggestedRate Playback rate for the current video.
     */
    setPlaybackRate: function(suggestedRate) {
      if(this._player && this._player.setPlaybackRate) {
        this._player.setPlaybackRate(suggestedRate);
      }
    },

    /**
     * This function sets the suggested video quality for the current video.
     * The function causes the video to reload at its current position in the new quality.
     * If the playback quality does change, it will only change for the video being played.
     * Calling this function does not guarantee that the playback quality will actually change.
     * However, if the playback quality does change, the `onPlaybackQualityChange` event will fire, and your code should respond to the event rather than the fact that it called the `setPlaybackQuality` function.
     *
     * The `suggestedQuality` parameter value can be `small`, `medium`, `large`, `hd720`, `hd1080`, `highres` or `default`.
     * We recommend that you set the parameter value to default, which instructs YouTube to select the most appropriate playback quality, which will vary for different users, videos, systems and other playback conditions.
     *
     * When you suggest a playback quality for a video, the suggested quality will only be in effect for that video.
     * You should select a playback quality that corresponds to the size of your video player.
     * For example, if your page displays a `1280px` by `720px` video player, a `hd720` quality video will actually look better than an `hd1080` quality video.
     * We recommend calling the `getAvailableQualityLevels()` function to determine which quality levels are available for a video.
     *
     * The list below shows the playback quality levels that correspond to different standard player sizes.
     * We recommend that you set the height of your video player to one of the values listed below and that you size your player to use 16:9 aspect ratio.
     * As stated above, even if you choose a standard player size, we also recommend that you set the `suggestedQuality` parameter value to default to enable YouTube to select the most appropriate playback quality.
     *
     * - `small`: Player height is 240px, and player dimensions are at least 320px by 240px for 4:3 aspect ratio.
     * - `medium`: Player height is 360px, and player dimensions are 640px by 360px (for 16:9 aspect ratio) or 480px by 360px (for 4:3 aspect ratio).
     * - `large`: Player height is 480px, and player dimensions are 853px by 480px (for 16:9 aspect ratio) or 640px by 480px (for 4:3 aspect ratio).
     * - `hd720`: Player height is 720px, and player dimensions are 1280px by 720px (for 16:9 aspect ratio) or 960px by 720px (for 4:3 aspect ratio).
     * - `hd1080`: Player height is 1080px, and player dimensions are 1920px by 1080px (for 16:9 aspect ratio) or 1440px by 1080px (for 4:3 aspect ratio).
     * - `highres`: Player height is greater than 1080px, which means that the player's aspect ratio is greater than 1920px by 1080px.
     * - `default`: YouTube selects the appropriate playback quality. This setting effectively reverts the quality level to the default state and nullifies any previous efforts to set playback quality using the `cueVideoById`, `loadVideoById` or `setPlaybackQuality` functions.
     *
     * If you call the `setPlaybackQuality` function with a `suggestedQuality` level that is not available for the video, then the quality will be set to the next lowest level that is available.
     * For example, if you request a quality level of large, and that is unavailable, then the playback quality will be set to medium (as long as that quality level is available).
     *
     * In addition, setting `suggestedQuality` to a value that is not a recognized quality level is equivalent to setting `suggestedQuality` to default.
     *
     * @method setPlaybackQuality
     * @param {string} suggestedQuality Playback quality for the current video.
     */
    setPlaybackQuality: function(suggestedQuality) {
      if(this._player && this._player.setPlaybackQuality) {
        this._player.setPlaybackQuality(suggestedQuality);
      }
    },

    _videoIdChanged: function() {
      this.currenttime = 0;
      this.currenttimeformatted = this._toHHMMSS(0);
      this.fractionloaded = 0;
      this.duration = 1;
      this.durationformatted = this._toHHMMSS(0);

      if (!this._player || !this._player.cueVideoById) {
        this._pendingVideoId = this.videoId;
      } else {
        // Figure out whether we should cue or load (which will autoplay) the next video.
          /******* MODIFIED *******/
        if (this.playsupported && this.autoplay) {
          /******* MODIFIED *******/
          this._player.loadVideoById(this.videoId);
        } else {
          this._player.cueVideoById(this.videoId);
        }
      }
    },

    _player: null,
    __updatePlaybackStatsInterval: null,
    _pendingVideoId: '',

      /******* MODIFIED *******/
    _apiLoad: function() {
        this._loadPlayer();
        this._apiLoaded = true;
    },
      /******* MODIFIED *******/
      
      /******* MODIFIED *******/
      _loadPlayer: function() {
          /******* MODIFIED *******/
      // Establish some defaults. Attributes set on the google-youtube element
      // can override defaults, or specify additional player parameters. See
      // https://developers.google.com/youtube/player_parameters
      var playerVars = {
        playsinline: 1,
        controls: 2,
        autohide: 1,
        // This will (intentionally) be overwritten if this.attributes['autoplay'] is set.
          /******* MODIFIED *******/
          autoplay: this.autoplay ? 1 : 0
          /******* MODIFIED *******/
      };

      if (this.chromeless) {
        playerVars.controls = 0;
        playerVars.modestbranding = 1;
        playerVars.showinfo = 0;
        // Disable annotations.
        playerVars.iv_load_policy = 3;
        // Disable related videos on the end screen.
        playerVars.rel = 0
      }
        
        /******* MODIFIED *******/
        if (this.loop) {
            playerVars.playlist = this.videoId;
            playerVars.loop = 1;
        }
        playerVars.controls = this.controls ? 1 : 0;
        /******* MODIFIED *******/

      for (var i = 0; i < this.attributes.length; i++) {
        var attribute = this.attributes[i];
        playerVars[attribute.nodeName] = attribute.value;
      }

      this._player = new YT.Player(this.$.player, {
        videoId: this.videoId,
        width: '100%',
        height: '100%',
        playerVars: playerVars,
        events: {
          onReady: function(e) {
            if (this._pendingVideoId && this._pendingVideoId != this.videoId) {
              this._player.cueVideoById(this._pendingVideoId);
              this._pendingVideoId = '';
            }

            this.fire('google-youtube-ready', e);
          }.bind(this),
          onStateChange: function(e) {
            this.state = e.data;

            // The YouTube Player API only exposes playback data about a video once
            // playback has begun.
            if (this.state == 1) {
              this.playbackstarted = true;

              // After playback has begun, play() can always be used to resume playback if the video is paused.
              this.playsupported = true;

              this.duration = this._player.getDuration();
              this.durationformatted = this._toHHMMSS(this.duration);

              if (!this.__updatePlaybackStatsInterval) {
                this.__updatePlaybackStatsInterval = setInterval(this._updatePlaybackStats.bind(this), 1000);
              }
            } else {
              // We only need to update the stats if the video is playing.
              if (this.__updatePlaybackStatsInterval) {
                clearInterval(this.__updatePlaybackStatsInterval);
                this.__updatePlaybackStatsInterval = null;
              }
            }

            this.fire('google-youtube-state-change', e);
          }.bind(this),
          onPlaybackQualityChange: function(e) {
            this.playbackquality = e.data;
          }.bind(this),
          onPlaybackRateChange: function(e) {
            this.playbackrate = e.data;
          }.bind(this),
          onError: function(e) {
            // Set the player state to 0 ('ended'), since playback will have stopped.
            this.state = 0;

            this.fire('google-youtube-error', e);
          }.bind(this),
            
    /******* MODIFIED *******/
            onVolumeChange: function(e) {
                this.volume = e.data.muted ? 0 : e.data.volume;
                this.fire('google-youtube-volume-change', e)
            }.bind(this)
    /******* MODIFIED *******/
        }
      });
    },

    _updatePlaybackStats: function() {
      this.currenttime = Math.round(this._player.getCurrentTime());
      this.currenttimeformatted = this._toHHMMSS(this.currenttime);
      this.fractionloaded = this._player.getVideoLoadedFraction();
      this.volume = this._player.getVolume();
    },

    _toHHMMSS: function(totalSeconds) {
      var hours = Math.floor(totalSeconds / 3600);
      totalSeconds -= hours * 3600;
      var minutes = Math.floor(totalSeconds / 60);
      var seconds = Math.round(totalSeconds - (minutes * 60));

      var hourPortion = '';
      if (hours > 0) {
        hourPortion += hours + ':';

        if (minutes < 10) {
          minutes = '0' + minutes;
        }
      }

      if (seconds < 10) {
        seconds = '0' + seconds;
      }

      return hourPortion + minutes + ':' + seconds;
    },

    _handleThumbnailTap: function() {
        /******* MODIFIED *******/
      this.autoplay = true;
        /******* MODIFIED *******/
      this.thumbnail = '';
    }
  });
</script>
</div><script>/*! @vimeo/player v2.0.2 | (c) 2017 Vimeo | MIT License | https://github.com/vimeo/player.js */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.Vimeo = global.Vimeo || {}, global.Vimeo.Player = factory());
}(this, (function () { 'use strict';

var arrayIndexOfSupport = typeof Array.prototype.indexOf !== 'undefined';
var postMessageSupport = typeof window.postMessage !== 'undefined';

if (!arrayIndexOfSupport || !postMessageSupport) {
    throw new Error('Sorry, the Vimeo Player API is not available in this browser.');
}

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};





function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var index = createCommonjsModule(function (module, exports) {
(function (exports) {
  'use strict';
  //shared pointer

  var i;
  //shortcuts
  var defineProperty = Object.defineProperty,
      is = function is(a, b) {
    return a === b || a !== a && b !== b;
  };

  //Polyfill global objects
  if (typeof WeakMap == 'undefined') {
    exports.WeakMap = createCollection({
      // WeakMap#delete(key:void*):boolean
      'delete': sharedDelete,
      // WeakMap#clear():
      clear: sharedClear,
      // WeakMap#get(key:void*):void*
      get: sharedGet,
      // WeakMap#has(key:void*):boolean
      has: mapHas,
      // WeakMap#set(key:void*, value:void*):void
      set: sharedSet
    }, true);
  }

  if (typeof Map == 'undefined' || typeof new Map().values !== 'function' || !new Map().values().next) {
    exports.Map = createCollection({
      // WeakMap#delete(key:void*):boolean
      'delete': sharedDelete,
      //:was Map#get(key:void*[, d3fault:void*]):void*
      // Map#has(key:void*):boolean
      has: mapHas,
      // Map#get(key:void*):boolean
      get: sharedGet,
      // Map#set(key:void*, value:void*):void
      set: sharedSet,
      // Map#keys(void):Iterator
      keys: sharedKeys,
      // Map#values(void):Iterator
      values: sharedValues,
      // Map#entries(void):Iterator
      entries: mapEntries,
      // Map#forEach(callback:Function, context:void*):void ==> callback.call(context, key, value, mapObject) === not in specs`
      forEach: sharedForEach,
      // Map#clear():
      clear: sharedClear
    });
  }

  if (typeof Set == 'undefined' || typeof new Set().values !== 'function' || !new Set().values().next) {
    exports.Set = createCollection({
      // Set#has(value:void*):boolean
      has: setHas,
      // Set#add(value:void*):boolean
      add: sharedAdd,
      // Set#delete(key:void*):boolean
      'delete': sharedDelete,
      // Set#clear():
      clear: sharedClear,
      // Set#keys(void):Iterator
      keys: sharedValues, // specs actually say "the same function object as the initial value of the values property"
      // Set#values(void):Iterator
      values: sharedValues,
      // Set#entries(void):Iterator
      entries: setEntries,
      // Set#forEach(callback:Function, context:void*):void ==> callback.call(context, value, index) === not in specs
      forEach: sharedForEach
    });
  }

  if (typeof WeakSet == 'undefined') {
    exports.WeakSet = createCollection({
      // WeakSet#delete(key:void*):boolean
      'delete': sharedDelete,
      // WeakSet#add(value:void*):boolean
      add: sharedAdd,
      // WeakSet#clear():
      clear: sharedClear,
      // WeakSet#has(value:void*):boolean
      has: setHas
    }, true);
  }

  /**
   * ES6 collection constructor
   * @return {Function} a collection class
   */
  function createCollection(proto, objectOnly) {
    function Collection(a) {
      if (!this || this.constructor !== Collection) return new Collection(a);
      this._keys = [];
      this._values = [];
      this._itp = []; // iteration pointers
      this.objectOnly = objectOnly;

      //parse initial iterable argument passed
      if (a) init.call(this, a);
    }

    //define size for non object-only collections
    if (!objectOnly) {
      defineProperty(proto, 'size', {
        get: sharedSize
      });
    }

    //set prototype
    proto.constructor = Collection;
    Collection.prototype = proto;

    return Collection;
  }

  /** parse initial iterable argument passed */
  function init(a) {
    var i;
    //init Set argument, like `[1,2,3,{}]`
    if (this.add) a.forEach(this.add, this);
    //init Map argument like `[[1,2], [{}, 4]]`
    else a.forEach(function (a) {
        this.set(a[0], a[1]);
      }, this);
  }

  /** delete */
  function sharedDelete(key) {
    if (this.has(key)) {
      this._keys.splice(i, 1);
      this._values.splice(i, 1);
      // update iteration pointers
      this._itp.forEach(function (p) {
        if (i < p[0]) p[0]--;
      });
    }
    // Aurora here does it while Canary doesn't
    return -1 < i;
  }

  function sharedGet(key) {
    return this.has(key) ? this._values[i] : undefined;
  }

  function has(list, key) {
    if (this.objectOnly && key !== Object(key)) throw new TypeError("Invalid value used as weak collection key");
    //NaN or 0 passed
    if (key != key || key === 0) for (i = list.length; i-- && !is(list[i], key);) {} else i = list.indexOf(key);
    return -1 < i;
  }

  function setHas(value) {
    return has.call(this, this._values, value);
  }

  function mapHas(value) {
    return has.call(this, this._keys, value);
  }

  /** @chainable */
  function sharedSet(key, value) {
    this.has(key) ? this._values[i] = value : this._values[this._keys.push(key) - 1] = value;
    return this;
  }

  /** @chainable */
  function sharedAdd(value) {
    if (!this.has(value)) this._values.push(value);
    return this;
  }

  function sharedClear() {
    (this._keys || 0).length = this._values.length = 0;
  }

  /** keys, values, and iterate related methods */
  function sharedKeys() {
    return sharedIterator(this._itp, this._keys);
  }

  function sharedValues() {
    return sharedIterator(this._itp, this._values);
  }

  function mapEntries() {
    return sharedIterator(this._itp, this._keys, this._values);
  }

  function setEntries() {
    return sharedIterator(this._itp, this._values, this._values);
  }

  function sharedIterator(itp, array, array2) {
    var p = [0],
        done = false;
    itp.push(p);
    return {
      next: function next() {
        var v,
            k = p[0];
        if (!done && k < array.length) {
          v = array2 ? [array[k], array2[k]] : array[k];
          p[0]++;
        } else {
          done = true;
          itp.splice(itp.indexOf(p), 1);
        }
        return { done: done, value: v };
      }
    };
  }

  function sharedSize() {
    return this._values.length;
  }

  function sharedForEach(callback, context) {
    var it = this.entries();
    for (;;) {
      var r = it.next();
      if (r.done) break;
      callback.call(context, r.value[1], r.value[0], this);
    }
  }
})('object' != 'undefined' && typeof commonjsGlobal != 'undefined' ? commonjsGlobal : window);
});

var npo_src = createCommonjsModule(function (module) {
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*! Native Promise Only
    v0.8.1 (c) Kyle Simpson
    MIT License: http://getify.mit-license.org
*/

(function UMD(name, context, definition) {
	// special form of UMD for polyfilling across evironments
	context[name] = context[name] || definition();
	if ('object' != "undefined" && module.exports) {
		module.exports = context[name];
	} else if (typeof undefined == "function" && undefined.amd) {
		undefined(function $AMD$() {
			return context[name];
		});
	}
})("Promise", typeof commonjsGlobal != "undefined" ? commonjsGlobal : commonjsGlobal, function DEF() {
	/*jshint validthis:true */
	"use strict";

	var builtInProp,
	    cycle,
	    scheduling_queue,
	    ToString = Object.prototype.toString,
	    timer = typeof setImmediate != "undefined" ? function timer(fn) {
		return setImmediate(fn);
	} : setTimeout;

	// dammit, IE8.
	try {
		Object.defineProperty({}, "x", {});
		builtInProp = function builtInProp(obj, name, val, config) {
			return Object.defineProperty(obj, name, {
				value: val,
				writable: true,
				configurable: config !== false
			});
		};
	} catch (err) {
		builtInProp = function builtInProp(obj, name, val) {
			obj[name] = val;
			return obj;
		};
	}

	// Note: using a queue instead of array for efficiency
	scheduling_queue = function Queue() {
		var first, last, item;

		function Item(fn, self) {
			this.fn = fn;
			this.self = self;
			this.next = void 0;
		}

		return {
			add: function add(fn, self) {
				item = new Item(fn, self);
				if (last) {
					last.next = item;
				} else {
					first = item;
				}
				last = item;
				item = void 0;
			},
			drain: function drain() {
				var f = first;
				first = last = cycle = void 0;

				while (f) {
					f.fn.call(f.self);
					f = f.next;
				}
			}
		};
	}();

	function schedule(fn, self) {
		scheduling_queue.add(fn, self);
		if (!cycle) {
			cycle = timer(scheduling_queue.drain);
		}
	}

	// promise duck typing
	function isThenable(o) {
		var _then,
		    o_type = typeof o === "undefined" ? "undefined" : _typeof(o);

		if (o != null && (o_type == "object" || o_type == "function")) {
			_then = o.then;
		}
		return typeof _then == "function" ? _then : false;
	}

	function notify() {
		for (var i = 0; i < this.chain.length; i++) {
			notifyIsolated(this, this.state === 1 ? this.chain[i].success : this.chain[i].failure, this.chain[i]);
		}
		this.chain.length = 0;
	}

	// NOTE: This is a separate function to isolate
	// the `try..catch` so that other code can be
	// optimized better
	function notifyIsolated(self, cb, chain) {
		var ret, _then;
		try {
			if (cb === false) {
				chain.reject(self.msg);
			} else {
				if (cb === true) {
					ret = self.msg;
				} else {
					ret = cb.call(void 0, self.msg);
				}

				if (ret === chain.promise) {
					chain.reject(TypeError("Promise-chain cycle"));
				} else if (_then = isThenable(ret)) {
					_then.call(ret, chain.resolve, chain.reject);
				} else {
					chain.resolve(ret);
				}
			}
		} catch (err) {
			chain.reject(err);
		}
	}

	function resolve(msg) {
		var _then,
		    self = this;

		// already triggered?
		if (self.triggered) {
			return;
		}

		self.triggered = true;

		// unwrap
		if (self.def) {
			self = self.def;
		}

		try {
			if (_then = isThenable(msg)) {
				schedule(function () {
					var def_wrapper = new MakeDefWrapper(self);
					try {
						_then.call(msg, function $resolve$() {
							resolve.apply(def_wrapper, arguments);
						}, function $reject$() {
							reject.apply(def_wrapper, arguments);
						});
					} catch (err) {
						reject.call(def_wrapper, err);
					}
				});
			} else {
				self.msg = msg;
				self.state = 1;
				if (self.chain.length > 0) {
					schedule(notify, self);
				}
			}
		} catch (err) {
			reject.call(new MakeDefWrapper(self), err);
		}
	}

	function reject(msg) {
		var self = this;

		// already triggered?
		if (self.triggered) {
			return;
		}

		self.triggered = true;

		// unwrap
		if (self.def) {
			self = self.def;
		}

		self.msg = msg;
		self.state = 2;
		if (self.chain.length > 0) {
			schedule(notify, self);
		}
	}

	function iteratePromises(Constructor, arr, resolver, rejecter) {
		for (var idx = 0; idx < arr.length; idx++) {
			(function IIFE(idx) {
				Constructor.resolve(arr[idx]).then(function $resolver$(msg) {
					resolver(idx, msg);
				}, rejecter);
			})(idx);
		}
	}

	function MakeDefWrapper(self) {
		this.def = self;
		this.triggered = false;
	}

	function MakeDef(self) {
		this.promise = self;
		this.state = 0;
		this.triggered = false;
		this.chain = [];
		this.msg = void 0;
	}

	function Promise(executor) {
		if (typeof executor != "function") {
			throw TypeError("Not a function");
		}

		if (this.__NPO__ !== 0) {
			throw TypeError("Not a promise");
		}

		// instance shadowing the inherited "brand"
		// to signal an already "initialized" promise
		this.__NPO__ = 1;

		var def = new MakeDef(this);

		this["then"] = function then(success, failure) {
			var o = {
				success: typeof success == "function" ? success : true,
				failure: typeof failure == "function" ? failure : false
			};
			// Note: `then(..)` itself can be borrowed to be used against
			// a different promise constructor for making the chained promise,
			// by substituting a different `this` binding.
			o.promise = new this.constructor(function extractChain(resolve, reject) {
				if (typeof resolve != "function" || typeof reject != "function") {
					throw TypeError("Not a function");
				}

				o.resolve = resolve;
				o.reject = reject;
			});
			def.chain.push(o);

			if (def.state !== 0) {
				schedule(notify, def);
			}

			return o.promise;
		};
		this["catch"] = function $catch$(failure) {
			return this.then(void 0, failure);
		};

		try {
			executor.call(void 0, function publicResolve(msg) {
				resolve.call(def, msg);
			}, function publicReject(msg) {
				reject.call(def, msg);
			});
		} catch (err) {
			reject.call(def, err);
		}
	}

	var PromisePrototype = builtInProp({}, "constructor", Promise,
	/*configurable=*/false);

	// Note: Android 4 cannot use `Object.defineProperty(..)` here
	Promise.prototype = PromisePrototype;

	// built-in "brand" to signal an "uninitialized" promise
	builtInProp(PromisePrototype, "__NPO__", 0,
	/*configurable=*/false);

	builtInProp(Promise, "resolve", function Promise$resolve(msg) {
		var Constructor = this;

		// spec mandated checks
		// note: best "isPromise" check that's practical for now
		if (msg && (typeof msg === "undefined" ? "undefined" : _typeof(msg)) == "object" && msg.__NPO__ === 1) {
			return msg;
		}

		return new Constructor(function executor(resolve, reject) {
			if (typeof resolve != "function" || typeof reject != "function") {
				throw TypeError("Not a function");
			}

			resolve(msg);
		});
	});

	builtInProp(Promise, "reject", function Promise$reject(msg) {
		return new this(function executor(resolve, reject) {
			if (typeof resolve != "function" || typeof reject != "function") {
				throw TypeError("Not a function");
			}

			reject(msg);
		});
	});

	builtInProp(Promise, "all", function Promise$all(arr) {
		var Constructor = this;

		// spec mandated checks
		if (ToString.call(arr) != "[object Array]") {
			return Constructor.reject(TypeError("Not an array"));
		}
		if (arr.length === 0) {
			return Constructor.resolve([]);
		}

		return new Constructor(function executor(resolve, reject) {
			if (typeof resolve != "function" || typeof reject != "function") {
				throw TypeError("Not a function");
			}

			var len = arr.length,
			    msgs = Array(len),
			    count = 0;

			iteratePromises(Constructor, arr, function resolver(idx, msg) {
				msgs[idx] = msg;
				if (++count === len) {
					resolve(msgs);
				}
			}, reject);
		});
	});

	builtInProp(Promise, "race", function Promise$race(arr) {
		var Constructor = this;

		// spec mandated checks
		if (ToString.call(arr) != "[object Array]") {
			return Constructor.reject(TypeError("Not an array"));
		}

		return new Constructor(function executor(resolve, reject) {
			if (typeof resolve != "function" || typeof reject != "function") {
				throw TypeError("Not a function");
			}

			iteratePromises(Constructor, arr, function resolver(idx, msg) {
				resolve(msg);
			}, reject);
		});
	});

	return Promise;
});
});

/**
 * @module lib/callbacks
 */

var callbackMap = new WeakMap();

/**
 * Store a callback for a method or event for a player.
 *
 * @author Brad Dougherty <brad@vimeo.com>
 * @param {Player} player The player object.
 * @param {string} name The method or event name.
 * @param {(function(this:Player, *): void|{resolve: function, reject: function})} callback
 *        The callback to call or an object with resolve and reject functions for a promise.
 * @return {void}
 */
function storeCallback(player, name, callback) {
    var playerCallbacks = callbackMap.get(player.element) || {};

    if (!(name in playerCallbacks)) {
        playerCallbacks[name] = [];
    }

    playerCallbacks[name].push(callback);
    callbackMap.set(player.element, playerCallbacks);
}

/**
 * Get the callbacks for a player and event or method.
 *
 * @author Brad Dougherty <brad@vimeo.com>
 * @param {Player} player The player object.
 * @param {string} name The method or event name
 * @return {function[]}
 */
function getCallbacks(player, name) {
    var playerCallbacks = callbackMap.get(player.element) || {};
    return playerCallbacks[name] || [];
}

/**
 * Remove a stored callback for a method or event for a player.
 *
 * @author Brad Dougherty <brad@vimeo.com>
 * @param {Player} player The player object.
 * @param {string} name The method or event name
 * @param {function} [callback] The specific callback to remove.
 * @return {boolean} Was this the last callback?
 */
function removeCallback(player, name, callback) {
    var playerCallbacks = callbackMap.get(player.element) || {};

    if (!playerCallbacks[name]) {
        return true;
    }

    // If no callback is passed, remove all callbacks for the event
    if (!callback) {
        playerCallbacks[name] = [];
        callbackMap.set(player.element, playerCallbacks);

        return true;
    }

    var index = playerCallbacks[name].indexOf(callback);

    if (index !== -1) {
        playerCallbacks[name].splice(index, 1);
    }

    callbackMap.set(player.element, playerCallbacks);
    return playerCallbacks[name] && playerCallbacks[name].length === 0;
}

/**
 * Return the first stored callback for a player and event or method.
 *
 * @param {Player} player The player object.
 * @param {string} name The method or event name.
 * @return {function} The callback, or false if there were none
 */
function shiftCallbacks(player, name) {
    var playerCallbacks = getCallbacks(player, name);

    if (playerCallbacks.length < 1) {
        return false;
    }

    var callback = playerCallbacks.shift();
    removeCallback(player, name, callback);
    return callback;
}

/**
 * Move callbacks associated with an element to another element.
 *
 * @author Brad Dougherty <brad@vimeo.com>
 * @param {HTMLElement} oldElement The old element.
 * @param {HTMLElement} newElement The new element.
 * @return {void}
 */
function swapCallbacks(oldElement, newElement) {
    var playerCallbacks = callbackMap.get(oldElement);

    callbackMap.set(newElement, playerCallbacks);
    callbackMap.delete(oldElement);
}

/**
 * @module lib/functions
 */

/**
 * Get the name of the method for a given getter or setter.
 *
 * @author Brad Dougherty <brad@vimeo.com>
 * @param {string} prop The name of the property.
 * @param {string} type Either “get” or “set”.
 * @return {string}
 */
function getMethodName(prop, type) {
    if (prop.indexOf(type.toLowerCase()) === 0) {
        return prop;
    }

    return '' + type.toLowerCase() + prop.substr(0, 1).toUpperCase() + prop.substr(1);
}

/**
 * Check to see if the object is a DOM Element.
 *
 * @author Brad Dougherty <brad@vimeo.com>
 * @param {*} element The object to check.
 * @return {boolean}
 */
function isDomElement(element) {
    return element instanceof window.HTMLElement;
}

/**
 * Check to see whether the value is a number.
 *
 * @author Brad Dougherty <brad@vimeo.com>
 * @see http://dl.dropboxusercontent.com/u/35146/js/tests/isNumber.html
 * @param {*} value The value to check.
 * @param {boolean} integer Check if the value is an integer.
 * @return {boolean}
 */
function isInteger(value) {
    // eslint-disable-next-line eqeqeq
    return !isNaN(parseFloat(value)) && isFinite(value) && Math.floor(value) == value;
}

/**
 * Check to see if the URL is a Vimeo url.
 *
 * @author Brad Dougherty <brad@vimeo.com>
 * @param {string} url The url string.
 * @return {boolean}
 */
function isVimeoUrl(url) {
    return (/^(https?:)?\/\/((player|www).)?vimeo.com(?=$|\/)/.test(url)
    );
}

/**
 * Get the Vimeo URL from an element.
 * The element must have either a data-vimeo-id or data-vimeo-url attribute.
 *
 * @author Brad Dougherty <brad@vimeo.com>
 * @param {object} oEmbedParameters The oEmbed parameters.
 * @return {string}
 */
function getVimeoUrl() {
    var oEmbedParameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var id = oEmbedParameters.id;
    var url = oEmbedParameters.url;
    var idOrUrl = id || url;

    if (!idOrUrl) {
        throw new Error('An id or url must be passed, either in an options object or as a data-vimeo-id or data-vimeo-url attribute.');
    }

    if (isInteger(idOrUrl)) {
        return 'https://vimeo.com/' + idOrUrl;
    }

    if (isVimeoUrl(idOrUrl)) {
        return idOrUrl.replace('http:', 'https:');
    }

    if (id) {
        throw new TypeError('\u201C' + id + '\u201D is not a valid video id.');
    }

    throw new TypeError('\u201C' + idOrUrl + '\u201D is not a vimeo.com url.');
}

/**
 * @module lib/embed
 */

var oEmbedParameters = ['id', 'url', 'width', 'maxwidth', 'height', 'maxheight', 'portrait', 'title', 'byline', 'color', 'autoplay', 'autopause', 'loop', 'responsive'];

/**
 * Get the 'data-vimeo'-prefixed attributes from an element as an object.
 *
 * @author Brad Dougherty <brad@vimeo.com>
 * @param {HTMLElement} element The element.
 * @param {Object} [defaults={}] The default values to use.
 * @return {Object<string, string>}
 */
function getOEmbedParameters(element) {
    var defaults = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    return oEmbedParameters.reduce(function (params, param) {
        var value = element.getAttribute('data-vimeo-' + param);

        if (value || value === '') {
            params[param] = value === '' ? 1 : value;
        }

        return params;
    }, defaults);
}

/**
 * Make an oEmbed call for the specified URL.
 *
 * @author Brad Dougherty <brad@vimeo.com>
 * @param {string} videoUrl The vimeo.com url for the video.
 * @param {Object} [params] Parameters to pass to oEmbed.
 * @return {Promise}
 */
function getOEmbedData(videoUrl) {
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    return new Promise(function (resolve, reject) {
        if (!isVimeoUrl(videoUrl)) {
            throw new TypeError('\u201C' + videoUrl + '\u201D is not a vimeo.com url.');
        }

        var url = 'https://vimeo.com/api/oembed.json?url=' + encodeURIComponent(videoUrl);

        for (var param in params) {
            if (params.hasOwnProperty(param)) {
                url += '&' + param + '=' + encodeURIComponent(params[param]);
            }
        }

        var xhr = 'XDomainRequest' in window ? new XDomainRequest() : new XMLHttpRequest();
        xhr.open('GET', url, true);

        xhr.onload = function () {
            if (xhr.status === 404) {
                reject(new Error('\u201C' + videoUrl + '\u201D was not found.'));
                return;
            }

            if (xhr.status === 403) {
                reject(new Error('\u201C' + videoUrl + '\u201D is not embeddable.'));
                return;
            }

            try {
                var json = JSON.parse(xhr.responseText);
                resolve(json);
            } catch (error) {
                reject(error);
            }
        };

        xhr.onerror = function () {
            var status = xhr.status ? ' (' + xhr.status + ')' : '';
            reject(new Error('There was an error fetching the embed code from Vimeo' + status + '.'));
        };

        xhr.send();
    });
}

/**
 * Create an embed from oEmbed data inside an element.
 *
 * @author Brad Dougherty <brad@vimeo.com>
 * @param {object} data The oEmbed data.
 * @param {HTMLElement} element The element to put the iframe in.
 * @return {HTMLIFrameElement} The iframe embed.
 */
function createEmbed(_ref, element) {
    var html = _ref.html;

    if (!element) {
        throw new TypeError('An element must be provided');
    }

    if (element.getAttribute('data-vimeo-initialized') !== null) {
        return element.querySelector('iframe');
    }

    var div = document.createElement('div');
    div.innerHTML = html;

    element.appendChild(div.firstChild);
    element.setAttribute('data-vimeo-initialized', 'true');

    return element.querySelector('iframe');
}

/**
 * Initialize all embeds within a specific element
 *
 * @author Brad Dougherty <brad@vimeo.com>
 * @param {HTMLElement} [parent=document] The parent element.
 * @return {void}
 */
function initializeEmbeds() {
    var parent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;

    var elements = [].slice.call(parent.querySelectorAll('[data-vimeo-id], [data-vimeo-url]'));

    var handleError = function handleError(error) {
        if ('console' in window && console.error) {
            console.error('There was an error creating an embed: ' + error);
        }
    };

    elements.forEach(function (element) {
        try {
            // Skip any that have data-vimeo-defer
            if (element.getAttribute('data-vimeo-defer') !== null) {
                return;
            }

            var params = getOEmbedParameters(element);
            var url = getVimeoUrl(params);

            getOEmbedData(url, params).then(function (data) {
                return createEmbed(data, element);
            }).catch(handleError);
        } catch (error) {
            handleError(error);
        }
    });
}

/**
 * @module lib/postmessage
 */

/**
 * Parse a message received from postMessage.
 *
 * @param {*} data The data received from postMessage.
 * @return {object}
 */
function parseMessageData(data) {
    if (typeof data === 'string') {
        data = JSON.parse(data);
    }

    return data;
}

/**
 * Post a message to the specified target.
 *
 * @author Brad Dougherty <brad@vimeo.com>
 * @param {Player} player The player object to use.
 * @param {string} method The API method to call.
 * @param {object} params The parameters to send to the player.
 * @return {void}
 */
function postMessage(player, method, params) {
    if (!player.element.contentWindow || !player.element.contentWindow.postMessage) {
        return;
    }

    var message = {
        method: method
    };

    if (params !== undefined) {
        message.value = params;
    }

    // IE 8 and 9 do not support passing messages, so stringify them
    var ieVersion = parseFloat(navigator.userAgent.toLowerCase().replace(/^.*msie (\d+).*$/, '$1'));
    if (ieVersion >= 8 && ieVersion < 10) {
        message = JSON.stringify(message);
    }

    player.element.contentWindow.postMessage(message, player.origin);
}

/**
 * Parse the data received from a message event.
 *
 * @author Brad Dougherty <brad@vimeo.com>
 * @param {Player} player The player that received the message.
 * @param {(Object|string)} data The message data. Strings will be parsed into JSON.
 * @return {void}
 */
function processData(player, data) {
    data = parseMessageData(data);
    var callbacks = [];
    var param = void 0;

    if (data.event) {
        if (data.event === 'error') {
            var promises = getCallbacks(player, data.data.method);

            promises.forEach(function (promise) {
                var error = new Error(data.data.message);
                error.name = data.data.name;

                promise.reject(error);
                removeCallback(player, data.data.method, promise);
            });
        }

        callbacks = getCallbacks(player, 'event:' + data.event);
        param = data.data;
    } else if (data.method) {
        var callback = shiftCallbacks(player, data.method);

        if (callback) {
            callbacks.push(callback);
            param = data.value;
        }
    }

    callbacks.forEach(function (callback) {
        try {
            if (typeof callback === 'function') {
                callback.call(player, param);
                return;
            }

            callback.resolve(param);
        } catch (e) {
            // empty
        }
    });
}

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var playerMap = new WeakMap();
var readyMap = new WeakMap();

var Player = function () {
    /**
    * Create a Player.
    *
    * @author Brad Dougherty <brad@vimeo.com>
    * @param {(HTMLIFrameElement|HTMLElement|string|jQuery)} element A reference to the Vimeo
    *        player iframe, and id, or a jQuery object.
    * @param {object} [options] oEmbed parameters to use when creating an embed in the element.
    * @return {Player}
    */
    function Player(element) {
        var _this = this;

        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        _classCallCheck(this, Player);

        /* global jQuery */
        if (window.jQuery && element instanceof jQuery) {
            if (element.length > 1 && window.console && console.warn) {
                console.warn('A jQuery object with multiple elements was passed, using the first element.');
            }

            element = element[0];
        }

        // Find an element by ID
        if (typeof element === 'string') {
            element = document.getElementById(element);
        }

        // Not an element!
        if (!isDomElement(element)) {
            throw new TypeError('You must pass either a valid element or a valid id.');
        }

        // Already initialized an embed in this div, so grab the iframe
        if (element.nodeName !== 'IFRAME') {
            var iframe = element.querySelector('iframe');

            if (iframe) {
                element = iframe;
            }
        }

        // iframe url is not a Vimeo url
        if (element.nodeName === 'IFRAME' && !isVimeoUrl(element.getAttribute('src') || '')) {
            throw new Error('The player element passed isn’t a Vimeo embed.');
        }

        // If there is already a player object in the map, return that
        if (playerMap.has(element)) {
            return playerMap.get(element);
        }

        this.element = element;
        this.origin = '*';

        var readyPromise = new npo_src(function (resolve, reject) {
            var onMessage = function onMessage(event) {
                if (!isVimeoUrl(event.origin) || _this.element.contentWindow !== event.source) {
                    return;
                }

                if (_this.origin === '*') {
                    _this.origin = event.origin;
                }

                var data = parseMessageData(event.data);
                var isReadyEvent = 'event' in data && data.event === 'ready';
                var isPingResponse = 'method' in data && data.method === 'ping';

                if (isReadyEvent || isPingResponse) {
                    _this.element.setAttribute('data-ready', 'true');
                    resolve();
                    return;
                }

                processData(_this, data);
            };

            if (window.addEventListener) {
                window.addEventListener('message', onMessage, false);
            } else if (window.attachEvent) {
                window.attachEvent('onmessage', onMessage);
            }

            if (_this.element.nodeName !== 'IFRAME') {
                var params = getOEmbedParameters(element, options);
                var url = getVimeoUrl(params);

                getOEmbedData(url, params).then(function (data) {
                    var iframe = createEmbed(data, element);
                    _this.element = iframe;

                    swapCallbacks(element, iframe);
                    playerMap.set(_this.element, _this);

                    return data;
                }).catch(function (error) {
                    return reject(error);
                });
            }
        });

        // Store a copy of this Player in the map
        readyMap.set(this, readyPromise);
        playerMap.set(this.element, this);

        // Send a ping to the iframe so the ready promise will be resolved if
        // the player is already ready.
        if (this.element.nodeName === 'IFRAME') {
            postMessage(this, 'ping');
        }

        return this;
    }

    /**
     * Get a promise for a method.
     *
     * @author Brad Dougherty <brad@vimeo.com>
     * @param {string} name The API method to call.
     * @param {Object} [args={}] Arguments to send via postMessage.
     * @return {Promise}
     */


    _createClass(Player, [{
        key: 'callMethod',
        value: function callMethod(name) {
            var _this2 = this;

            var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            return new npo_src(function (resolve, reject) {
                // We are storing the resolve/reject handlers to call later, so we
                // can’t return here.
                // eslint-disable-next-line promise/always-return
                return _this2.ready().then(function () {
                    storeCallback(_this2, name, {
                        resolve: resolve,
                        reject: reject
                    });

                    postMessage(_this2, name, args);
                });
            });
        }

        /**
         * Get a promise for the value of a player property.
         *
         * @author Brad Dougherty <brad@vimeo.com>
         * @param {string} name The property name
         * @return {Promise}
         */

    }, {
        key: 'get',
        value: function get(name) {
            var _this3 = this;

            return new npo_src(function (resolve, reject) {
                name = getMethodName(name, 'get');

                // We are storing the resolve/reject handlers to call later, so we
                // can’t return here.
                // eslint-disable-next-line promise/always-return
                return _this3.ready().then(function () {
                    storeCallback(_this3, name, {
                        resolve: resolve,
                        reject: reject
                    });

                    postMessage(_this3, name);
                });
            });
        }

        /**
         * Get a promise for setting the value of a player property.
         *
         * @author Brad Dougherty <brad@vimeo.com>
         * @param {string} name The API method to call.
         * @param {mixed} value The value to set.
         * @return {Promise}
         */

    }, {
        key: 'set',
        value: function set(name, value) {
            var _this4 = this;

            return npo_src.resolve(value).then(function (val) {
                name = getMethodName(name, 'set');

                if (val === undefined || val === null) {
                    throw new TypeError('There must be a value to set.');
                }

                return _this4.ready().then(function () {
                    return new npo_src(function (resolve, reject) {
                        storeCallback(_this4, name, {
                            resolve: resolve,
                            reject: reject
                        });

                        postMessage(_this4, name, val);
                    });
                });
            });
        }

        /**
         * Add an event listener for the specified event. Will call the
         * callback with a single parameter, `data`, that contains the data for
         * that event.
         *
         * @author Brad Dougherty <brad@vimeo.com>
         * @param {string} eventName The name of the event.
         * @param {function(*)} callback The function to call when the event fires.
         * @return {void}
         */

    }, {
        key: 'on',
        value: function on(eventName, callback) {
            if (!eventName) {
                throw new TypeError('You must pass an event name.');
            }

            if (!callback) {
                throw new TypeError('You must pass a callback function.');
            }

            if (typeof callback !== 'function') {
                throw new TypeError('The callback must be a function.');
            }

            var callbacks = getCallbacks(this, 'event:' + eventName);
            if (callbacks.length === 0) {
                this.callMethod('addEventListener', eventName).catch(function () {
                    // Ignore the error. There will be an error event fired that
                    // will trigger the error callback if they are listening.
                });
            }

            storeCallback(this, 'event:' + eventName, callback);
        }

        /**
         * Remove an event listener for the specified event. Will remove all
         * listeners for that event if a `callback` isn’t passed, or only that
         * specific callback if it is passed.
         *
         * @author Brad Dougherty <brad@vimeo.com>
         * @param {string} eventName The name of the event.
         * @param {function} [callback] The specific callback to remove.
         * @return {void}
         */

    }, {
        key: 'off',
        value: function off(eventName, callback) {
            if (!eventName) {
                throw new TypeError('You must pass an event name.');
            }

            if (callback && typeof callback !== 'function') {
                throw new TypeError('The callback must be a function.');
            }

            var lastCallback = removeCallback(this, 'event:' + eventName, callback);

            // If there are no callbacks left, remove the listener
            if (lastCallback) {
                this.callMethod('removeEventListener', eventName).catch(function (e) {
                    // Ignore the error. There will be an error event fired that
                    // will trigger the error callback if they are listening.
                });
            }
        }

        /**
         * A promise to load a new video.
         *
         * @promise LoadVideoPromise
         * @fulfill {number} The video with this id successfully loaded.
         * @reject {TypeError} The id was not a number.
         */
        /**
         * Load a new video into this embed. The promise will be resolved if
         * the video is successfully loaded, or it will be rejected if it could
         * not be loaded.
         *
         * @author Brad Dougherty <brad@vimeo.com>
         * @param {number} id The id of the video.
         * @return {LoadVideoPromise}
         */

    }, {
        key: 'loadVideo',
        value: function loadVideo(id) {
            return this.callMethod('loadVideo', id);
        }

        /**
         * A promise to perform an action when the Player is ready.
         *
         * @todo document errors
         * @promise LoadVideoPromise
         * @fulfill {void}
         */
        /**
         * Trigger a function when the player iframe has initialized. You do not
         * need to wait for `ready` to trigger to begin adding event listeners
         * or calling other methods.
         *
         * @author Brad Dougherty <brad@vimeo.com>
         * @return {ReadyPromise}
         */

    }, {
        key: 'ready',
        value: function ready() {
            var readyPromise = readyMap.get(this);
            return npo_src.resolve(readyPromise);
        }

        /**
         * A promise to add a cue point to the player.
         *
         * @promise AddCuePointPromise
         * @fulfill {string} The id of the cue point to use for removeCuePoint.
         * @reject {RangeError} the time was less than 0 or greater than the
         *         video’s duration.
         * @reject {UnsupportedError} Cue points are not supported with the current
         *         player or browser.
         */
        /**
         * Add a cue point to the player.
         *
         * @author Brad Dougherty <brad@vimeo.com>
         * @param {number} time The time for the cue point.
         * @param {object} [data] Arbitrary data to be returned with the cue point.
         * @return {AddCuePointPromise}
         */

    }, {
        key: 'addCuePoint',
        value: function addCuePoint(time) {
            var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            return this.callMethod('addCuePoint', { time: time, data: data });
        }

        /**
         * A promise to remove a cue point from the player.
         *
         * @promise AddCuePointPromise
         * @fulfill {string} The id of the cue point that was removed.
         * @reject {InvalidCuePoint} The cue point with the specified id was not
         *         found.
         * @reject {UnsupportedError} Cue points are not supported with the current
         *         player or browser.
         */
        /**
         * Remove a cue point from the video.
         *
         * @author Brad Dougherty <brad@vimeo.com>
         * @param {string} id The id of the cue point to remove.
         * @return {RemoveCuePointPromise}
         */

    }, {
        key: 'removeCuePoint',
        value: function removeCuePoint(id) {
            return this.callMethod('removeCuePoint', id);
        }

        /**
         * A representation of a text track on a video.
         *
         * @typedef {Object} VimeoTextTrack
         * @property {string} language The ISO language code.
         * @property {string} kind The kind of track it is (captions or subtitles).
         * @property {string} label The human‐readable label for the track.
         */
        /**
         * A promise to enable a text track.
         *
         * @promise EnableTextTrackPromise
         * @fulfill {VimeoTextTrack} The text track that was enabled.
         * @reject {InvalidTrackLanguageError} No track was available with the
         *         specified language.
         * @reject {InvalidTrackError} No track was available with the specified
         *         language and kind.
         */
        /**
         * Enable the text track with the specified language, and optionally the
         * specified kind (captions or subtitles).
         *
         * When set via the API, the track language will not change the viewer’s
         * stored preference.
         *
         * @author Brad Dougherty <brad@vimeo.com>
         * @param {string} language The two‐letter language code.
         * @param {string} [kind] The kind of track to enable (captions or subtitles).
         * @return {EnableTextTrackPromise}
         */

    }, {
        key: 'enableTextTrack',
        value: function enableTextTrack(language, kind) {
            if (!language) {
                throw new TypeError('You must pass a language.');
            }

            return this.callMethod('enableTextTrack', {
                language: language,
                kind: kind
            });
        }

        /**
         * A promise to disable the active text track.
         *
         * @promise DisableTextTrackPromise
         * @fulfill {void} The track was disabled.
         */
        /**
         * Disable the currently-active text track.
         *
         * @author Brad Dougherty <brad@vimeo.com>
         * @return {DisableTextTrackPromise}
         */

    }, {
        key: 'disableTextTrack',
        value: function disableTextTrack() {
            return this.callMethod('disableTextTrack');
        }

        /**
         * A promise to pause the video.
         *
         * @promise PausePromise
         * @fulfill {void} The video was paused.
         */
        /**
         * Pause the video if it’s playing.
         *
         * @author Brad Dougherty <brad@vimeo.com>
         * @return {PausePromise}
         */

    }, {
        key: 'pause',
        value: function pause() {
            return this.callMethod('pause');
        }

        /**
         * A promise to play the video.
         *
         * @promise PlayPromise
         * @fulfill {void} The video was played.
         */
        /**
         * Play the video if it’s paused. **Note:** on iOS and some other
         * mobile devices, you cannot programmatically trigger play. Once the
         * viewer has tapped on the play button in the player, however, you
         * will be able to use this function.
         *
         * @author Brad Dougherty <brad@vimeo.com>
         * @return {PlayPromise}
         */

    }, {
        key: 'play',
        value: function play() {
            return this.callMethod('play');
        }

        /**
         * A promise to unload the video.
         *
         * @promise UnloadPromise
         * @fulfill {void} The video was unloaded.
         */
        /**
         * Return the player to its initial state.
         *
         * @author Brad Dougherty <brad@vimeo.com>
         * @return {UnloadPromise}
         */

    }, {
        key: 'unload',
        value: function unload() {
            return this.callMethod('unload');
        }

        /**
         * A promise to get the autopause behavior of the video.
         *
         * @promise GetAutopausePromise
         * @fulfill {boolean} Whether autopause is turned on or off.
         * @reject {UnsupportedError} Autopause is not supported with the current
         *         player or browser.
         */
        /**
         * Get the autopause behavior for this player.
         *
         * @author Brad Dougherty <brad@vimeo.com>
         * @return {GetAutopausePromise}
         */

    }, {
        key: 'getAutopause',
        value: function getAutopause() {
            return this.get('autopause');
        }

        /**
         * A promise to set the autopause behavior of the video.
         *
         * @promise SetAutopausePromise
         * @fulfill {boolean} Whether autopause is turned on or off.
         * @reject {UnsupportedError} Autopause is not supported with the current
         *         player or browser.
         */
        /**
         * Enable or disable the autopause behavior of this player.
         *
         * By default, when another video is played in the same browser, this
         * player will automatically pause. Unless you have a specific reason
         * for doing so, we recommend that you leave autopause set to the
         * default (`true`).
         *
         * @author Brad Dougherty <brad@vimeo.com>
         * @param {boolean} autopause
         * @return {SetAutopausePromise}
         */

    }, {
        key: 'setAutopause',
        value: function setAutopause(autopause) {
            return this.set('autopause', autopause);
        }

        /**
         * A promise to get the color of the player.
         *
         * @promise GetColorPromise
         * @fulfill {string} The hex color of the player.
         */
        /**
         * Get the color for this player.
         *
         * @author Brad Dougherty <brad@vimeo.com>
         * @return {GetColorPromise}
         */

    }, {
        key: 'getColor',
        value: function getColor() {
            return this.get('color');
        }

        /**
         * A promise to set the color of the player.
         *
         * @promise SetColorPromise
         * @fulfill {string} The color was successfully set.
         * @reject {TypeError} The string was not a valid hex or rgb color.
         * @reject {ContrastError} The color was set, but the contrast is
         *         outside of the acceptable range.
         * @reject {EmbedSettingsError} The owner of the player has chosen to
         *         use a specific color.
         */
        /**
         * Set the color of this player to a hex or rgb string. Setting the
         * color may fail if the owner of the video has set their embed
         * preferences to force a specific color.
         *
         * @author Brad Dougherty <brad@vimeo.com>
         * @param {string} color The hex or rgb color string to set.
         * @return {SetColorPromise}
         */

    }, {
        key: 'setColor',
        value: function setColor(color) {
            return this.set('color', color);
        }

        /**
         * A representation of a cue point.
         *
         * @typedef {Object} VimeoCuePoint
         * @property {number} time The time of the cue point.
         * @property {object} data The data passed when adding the cue point.
         * @property {string} id The unique id for use with removeCuePoint.
         */
        /**
         * A promise to get the cue points of a video.
         *
         * @promise GetCuePointsPromise
         * @fulfill {VimeoCuePoint[]} The cue points added to the video.
         * @reject {UnsupportedError} Cue points are not supported with the current
         *         player or browser.
         */
        /**
         * Get an array of the cue points added to the video.
         *
         * @author Brad Dougherty <brad@vimeo.com>
         * @return {GetCuePointsPromise}
         */

    }, {
        key: 'getCuePoints',
        value: function getCuePoints() {
            return this.get('cuePoints');
        }

        /**
         * A promise to get the current time of the video.
         *
         * @promise GetCurrentTimePromise
         * @fulfill {number} The current time in seconds.
         */
        /**
         * Get the current playback position in seconds.
         *
         * @author Brad Dougherty <brad@vimeo.com>
         * @return {GetCurrentTimePromise}
         */

    }, {
        key: 'getCurrentTime',
        value: function getCurrentTime() {
            return this.get('currentTime');
        }

        /**
         * A promise to set the current time of the video.
         *
         * @promise SetCurrentTimePromise
         * @fulfill {number} The actual current time that was set.
         * @reject {RangeError} the time was less than 0 or greater than the
         *         video’s duration.
         */
        /**
         * Set the current playback position in seconds. If the player was
         * paused, it will remain paused. Likewise, if the player was playing,
         * it will resume playing once the video has buffered.
         *
         * You can provide an accurate time and the player will attempt to seek
         * to as close to that time as possible. The exact time will be the
         * fulfilled value of the promise.
         *
         * @author Brad Dougherty <brad@vimeo.com>
         * @param {number} currentTime
         * @return {SetCurrentTimePromise}
         */

    }, {
        key: 'setCurrentTime',
        value: function setCurrentTime(currentTime) {
            return this.set('currentTime', currentTime);
        }

        /**
         * A promise to get the duration of the video.
         *
         * @promise GetDurationPromise
         * @fulfill {number} The duration in seconds.
         */
        /**
         * Get the duration of the video in seconds. It will be rounded to the
         * nearest second before playback begins, and to the nearest thousandth
         * of a second after playback begins.
         *
         * @author Brad Dougherty <brad@vimeo.com>
         * @return {GetDurationPromise}
         */

    }, {
        key: 'getDuration',
        value: function getDuration() {
            return this.get('duration');
        }

        /**
         * A promise to get the ended state of the video.
         *
         * @promise GetEndedPromise
         * @fulfill {boolean} Whether or not the video has ended.
         */
        /**
         * Get the ended state of the video. The video has ended if
         * `currentTime === duration`.
         *
         * @author Brad Dougherty <brad@vimeo.com>
         * @return {GetEndedPromise}
         */

    }, {
        key: 'getEnded',
        value: function getEnded() {
            return this.get('ended');
        }

        /**
         * A promise to get the loop state of the player.
         *
         * @promise GetLoopPromise
         * @fulfill {boolean} Whether or not the player is set to loop.
         */
        /**
         * Get the loop state of the player.
         *
         * @author Brad Dougherty <brad@vimeo.com>
         * @return {GetLoopPromise}
         */

    }, {
        key: 'getLoop',
        value: function getLoop() {
            return this.get('loop');
        }

        /**
         * A promise to set the loop state of the player.
         *
         * @promise SetLoopPromise
         * @fulfill {boolean} The loop state that was set.
         */
        /**
         * Set the loop state of the player. When set to `true`, the player
         * will start over immediately once playback ends.
         *
         * @author Brad Dougherty <brad@vimeo.com>
         * @param {boolean} loop
         * @return {SetLoopPromise}
         */

    }, {
        key: 'setLoop',
        value: function setLoop(loop) {
            return this.set('loop', loop);
        }

        /**
         * A promise to get the paused state of the player.
         *
         * @promise GetLoopPromise
         * @fulfill {boolean} Whether or not the video is paused.
         */
        /**
         * Get the paused state of the player.
         *
         * @author Brad Dougherty <brad@vimeo.com>
         * @return {GetLoopPromise}
         */

    }, {
        key: 'getPaused',
        value: function getPaused() {
            return this.get('paused');
        }

        /**
         * A promise to get the text tracks of a video.
         *
         * @promise GetTextTracksPromise
         * @fulfill {VimeoTextTrack[]} The text tracks associated with the video.
         */
        /**
         * Get an array of the text tracks that exist for the video.
         *
         * @author Brad Dougherty <brad@vimeo.com>
         * @return {GetTextTracksPromise}
         */

    }, {
        key: 'getTextTracks',
        value: function getTextTracks() {
            return this.get('textTracks');
        }

        /**
         * A promise to get the embed code for the video.
         *
         * @promise GetVideoEmbedCodePromise
         * @fulfill {string} The `<iframe>` embed code for the video.
         */
        /**
         * Get the `<iframe>` embed code for the video.
         *
         * @author Brad Dougherty <brad@vimeo.com>
         * @return {GetVideoEmbedCodePromise}
         */

    }, {
        key: 'getVideoEmbedCode',
        value: function getVideoEmbedCode() {
            return this.get('videoEmbedCode');
        }

        /**
         * A promise to get the id of the video.
         *
         * @promise GetVideoIdPromise
         * @fulfill {number} The id of the video.
         */
        /**
         * Get the id of the video.
         *
         * @author Brad Dougherty <brad@vimeo.com>
         * @return {GetVideoIdPromise}
         */

    }, {
        key: 'getVideoId',
        value: function getVideoId() {
            return this.get('videoId');
        }

        /**
         * A promise to get the title of the video.
         *
         * @promise GetVideoTitlePromise
         * @fulfill {number} The title of the video.
         */
        /**
         * Get the title of the video.
         *
         * @author Brad Dougherty <brad@vimeo.com>
         * @return {GetVideoTitlePromise}
         */

    }, {
        key: 'getVideoTitle',
        value: function getVideoTitle() {
            return this.get('videoTitle');
        }

        /**
         * A promise to get the native width of the video.
         *
         * @promise GetVideoWidthPromise
         * @fulfill {number} The native width of the video.
         */
        /**
         * Get the native width of the currently‐playing video. The width of
         * the highest‐resolution available will be used before playback begins.
         *
         * @author Brad Dougherty <brad@vimeo.com>
         * @return {GetVideoWidthPromise}
         */

    }, {
        key: 'getVideoWidth',
        value: function getVideoWidth() {
            return this.get('videoWidth');
        }

        /**
         * A promise to get the native height of the video.
         *
         * @promise GetVideoHeightPromise
         * @fulfill {number} The native height of the video.
         */
        /**
         * Get the native height of the currently‐playing video. The height of
         * the highest‐resolution available will be used before playback begins.
         *
         * @author Brad Dougherty <brad@vimeo.com>
         * @return {GetVideoHeightPromise}
         */

    }, {
        key: 'getVideoHeight',
        value: function getVideoHeight() {
            return this.get('videoHeight');
        }

        /**
         * A promise to get the vimeo.com url for the video.
         *
         * @promise GetVideoUrlPromise
         * @fulfill {number} The vimeo.com url for the video.
         * @reject {PrivacyError} The url isn’t available because of the video’s privacy setting.
         */
        /**
         * Get the vimeo.com url for the video.
         *
         * @author Brad Dougherty <brad@vimeo.com>
         * @return {GetVideoUrlPromise}
         */

    }, {
        key: 'getVideoUrl',
        value: function getVideoUrl() {
            return this.get('videoUrl');
        }

        /**
         * A promise to get the volume level of the player.
         *
         * @promise GetVolumePromise
         * @fulfill {number} The volume level of the player on a scale from 0 to 1.
         */
        /**
         * Get the current volume level of the player on a scale from `0` to `1`.
         *
         * Most mobile devices do not support an independent volume from the
         * system volume. In those cases, this method will always return `1`.
         *
         * @author Brad Dougherty <brad@vimeo.com>
         * @return {GetVolumePromise}
         */

    }, {
        key: 'getVolume',
        value: function getVolume() {
            return this.get('volume');
        }

        /**
         * A promise to set the volume level of the player.
         *
         * @promise SetVolumePromise
         * @fulfill {number} The volume was set.
         * @reject {RangeError} The volume was less than 0 or greater than 1.
         */
        /**
         * Set the volume of the player on a scale from `0` to `1`. When set
         * via the API, the volume level will not be synchronized to other
         * players or stored as the viewer’s preference.
         *
         * Most mobile devices do not support setting the volume. An error will
         * *not* be triggered in that situation.
         *
         * @author Brad Dougherty <brad@vimeo.com>
         * @param {number} volume
         * @return {SetVolumePromise}
         */

    }, {
        key: 'setVolume',
        value: function setVolume(volume) {
            return this.set('volume', volume);
        }
    }]);

    return Player;
}();

initializeEmbeds();

return Player;

})));

//# sourceMappingURL=player.js.map</script><dom-module id="inkd-video" assetpath="inkd-elements/">
    
    <template>
        <style>
            :host {
                display: block;
                position: relative;
                width: var(--width);
                height: var(--height);
            }
            
            #html5Element, #youtubeElement, #vimeoElement {
                background-color: black;
                width: 100%;
                height: 100%;
            }
            
            .vimeo-wrapper {
                width: 100%;
                height: auto;
                padding-top: var(--vimeo-padding-top);
                max-height: 100%;
                max-width: 100%;
            }
            
            #vimeoElement {
                vertical-align: bottom;
                position: absolute;
                top: 0px;
                left: 0px;
                width: 100%;
                height: 100%;
            }
        </style>
        
        <template is="dom-if" if="[[_typeIsHtml5]]">
            <video id="html5Element" controls="[[controls]]" loop="[[loop]]" preload="[[preload]]" on-loadeddata="_handleHtml5Load" on-play="_handlePlay" on-pause="_handlePause" on-volumechange="_handleVolumeChange">
                <source src="[[src]]" type="[[_html5MediaType]]" on-error="_handleError">
            </video>
        </template>
        
        <template is="dom-if" if="[[_typeIsYoutube]]">
            <google-youtube id="youtubeElement" video-id="[[_youtubeVideoId]]" controls="[[controls]]" loop="[[loop]]" autoplay="[[autoplay]]" chromeless="" fluid=""></google-youtube>
        </template>
        
        <template is="dom-if" if="[[_vimeoAttach]]" restamp="">
            <div class="vimeo-wrapper">
                <iframe id="vimeoElement" src="[[src]]" frameborder="0" allowfullscreen=""></iframe>
            </div>
        </template>
    </template>
    
    </dom-module><dom-module id="inkd-animation-styles" assetpath="inkd-styles/">
    <template>
        <style>
            
            .animationSpan {
                display: inline-block;
                -webkit-animation-fill-mode: both;
                animation-fill-mode: both;
            }
            
            @charset 'UTF-8';
            /*!
             * animate.css -http://daneden.me/animate
             * Version - 3.5.1
             * Licensed under the MIT license - http://opensource.org/licenses/MIT
             *
             * Copyright (c) 2016 Daniel Eden
             */

            @-webkit-keyframes bounce {
              from, 20%, 53%, 80%, to {
                -webkit-animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
                animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
                -webkit-transform: translate3d(0,0,0);
                transform: translate3d(0,0,0);
                -webkit-transform-origin: center bottom;
                transform-origin: center bottom;
              }

              40%, 43% {
                -webkit-animation-timing-function: cubic-bezier(0.755, 0.050, 0.855, 0.060);
                animation-timing-function: cubic-bezier(0.755, 0.050, 0.855, 0.060);
                -webkit-transform: translate3d(0, -30px, 0);
                transform: translate3d(0, -30px, 0);
                -webkit-transform-origin: center bottom;
                transform-origin: center bottom;
              }

              70% {
                -webkit-animation-timing-function: cubic-bezier(0.755, 0.050, 0.855, 0.060);
                animation-timing-function: cubic-bezier(0.755, 0.050, 0.855, 0.060);
                -webkit-transform: translate3d(0, -15px, 0);
                transform: translate3d(0, -15px, 0);
                -webkit-transform-origin: center bottom;
                transform-origin: center bottom;
              }

              90% {
                -webkit-transform: translate3d(0,-4px,0);
                transform: translate3d(0,-4px,0);
                -webkit-transform-origin: center bottom;
                transform-origin: center bottom;
              }
            }

            @keyframes bounce {
              from, 20%, 53%, 80%, to {
                -webkit-animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
                animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
                -webkit-transform: translate3d(0,0,0);
                transform: translate3d(0,0,0);
                -webkit-transform-origin: center bottom;
                transform-origin: center bottom;
              }

              40%, 43% {
                -webkit-animation-timing-function: cubic-bezier(0.755, 0.050, 0.855, 0.060);
                animation-timing-function: cubic-bezier(0.755, 0.050, 0.855, 0.060);
                -webkit-transform: translate3d(0, -30px, 0);
                transform: translate3d(0, -30px, 0);
                -webkit-transform-origin: center bottom;
                transform-origin: center bottom;
              }

              70% {
                -webkit-animation-timing-function: cubic-bezier(0.755, 0.050, 0.855, 0.060);
                animation-timing-function: cubic-bezier(0.755, 0.050, 0.855, 0.060);
                -webkit-transform: translate3d(0, -15px, 0);
                transform: translate3d(0, -15px, 0);
                -webkit-transform-origin: center bottom;
                transform-origin: center bottom;
              }

              90% {
                -webkit-transform: translate3d(0,-4px,0);
                transform: translate3d(0,-4px,0);
                -webkit-transform-origin: center bottom;
                transform-origin: center bottom;
              }
            }

            @-webkit-keyframes flash {
              from, 50%, to {
                opacity: 1;
              }

              25%, 75% {
                opacity: 0;
              }
            }

            @keyframes flash {
              from, 50%, to {
                opacity: 1;
              }

              25%, 75% {
                opacity: 0;
              }
            }

            /* originally authored by Nick Pettit - https://github.com/nickpettit/glide */

            @-webkit-keyframes pulse {
              from {
                -webkit-transform: scale3d(1, 1, 1);
                transform: scale3d(1, 1, 1);
              }

              50% {
                -webkit-transform: scale3d(1.05, 1.05, 1.05);
                transform: scale3d(1.05, 1.05, 1.05);
              }

              to {
                -webkit-transform: scale3d(1, 1, 1);
                transform: scale3d(1, 1, 1);
              }
            }

            @keyframes pulse {
              from {
                -webkit-transform: scale3d(1, 1, 1);
                transform: scale3d(1, 1, 1);
              }

              50% {
                -webkit-transform: scale3d(1.05, 1.05, 1.05);
                transform: scale3d(1.05, 1.05, 1.05);
              }

              to {
                -webkit-transform: scale3d(1, 1, 1);
                transform: scale3d(1, 1, 1);
              }
            }

            @-webkit-keyframes rubberBand {
              from {
                -webkit-transform: scale3d(1, 1, 1);
                transform: scale3d(1, 1, 1);
              }

              30% {
                -webkit-transform: scale3d(1.25, 0.75, 1);
                transform: scale3d(1.25, 0.75, 1);
              }

              40% {
                -webkit-transform: scale3d(0.75, 1.25, 1);
                transform: scale3d(0.75, 1.25, 1);
              }

              50% {
                -webkit-transform: scale3d(1.15, 0.85, 1);
                transform: scale3d(1.15, 0.85, 1);
              }

              65% {
                -webkit-transform: scale3d(.95, 1.05, 1);
                transform: scale3d(.95, 1.05, 1);
              }

              75% {
                -webkit-transform: scale3d(1.05, .95, 1);
                transform: scale3d(1.05, .95, 1);
              }

              to {
                -webkit-transform: scale3d(1, 1, 1);
                transform: scale3d(1, 1, 1);
              }
            }

            @keyframes rubberBand {
              from {
                -webkit-transform: scale3d(1, 1, 1);
                transform: scale3d(1, 1, 1);
              }

              30% {
                -webkit-transform: scale3d(1.25, 0.75, 1);
                transform: scale3d(1.25, 0.75, 1);
              }

              40% {
                -webkit-transform: scale3d(0.75, 1.25, 1);
                transform: scale3d(0.75, 1.25, 1);
              }

              50% {
                -webkit-transform: scale3d(1.15, 0.85, 1);
                transform: scale3d(1.15, 0.85, 1);
              }

              65% {
                -webkit-transform: scale3d(.95, 1.05, 1);
                transform: scale3d(.95, 1.05, 1);
              }

              75% {
                -webkit-transform: scale3d(1.05, .95, 1);
                transform: scale3d(1.05, .95, 1);
              }

              to {
                -webkit-transform: scale3d(1, 1, 1);
                transform: scale3d(1, 1, 1);
              }
            }

            @-webkit-keyframes shake {
              from, to {
                -webkit-transform: translate3d(0, 0, 0);
                transform: translate3d(0, 0, 0);
              }

              10%, 30%, 50%, 70%, 90% {
                -webkit-transform: translate3d(-10px, 0, 0);
                transform: translate3d(-10px, 0, 0);
              }

              20%, 40%, 60%, 80% {
                -webkit-transform: translate3d(10px, 0, 0);
                transform: translate3d(10px, 0, 0);
              }
            }

            @keyframes shake {
              from, to {
                -webkit-transform: translate3d(0, 0, 0);
                transform: translate3d(0, 0, 0);
              }

              10%, 30%, 50%, 70%, 90% {
                -webkit-transform: translate3d(-10px, 0, 0);
                transform: translate3d(-10px, 0, 0);
              }

              20%, 40%, 60%, 80% {
                -webkit-transform: translate3d(10px, 0, 0);
                transform: translate3d(10px, 0, 0);
              }
            }

            @-webkit-keyframes headShake {
              0% {
                -webkit-transform: translateX(0);
                transform: translateX(0);
                -webkit-animation-timing-function: ease-in-out;
                animation-timing-function: ease-in-out;
              }

              6.5% {
                -webkit-transform: translateX(-6px) rotateY(-9deg);
                transform: translateX(-6px) rotateY(-9deg);
                -webkit-animation-timing-function: ease-in-out;
                animation-timing-function: ease-in-out;
              }

              18.5% {
                -webkit-transform: translateX(5px) rotateY(7deg);
                transform: translateX(5px) rotateY(7deg);
                -webkit-animation-timing-function: ease-in-out;
                animation-timing-function: ease-in-out;
              }

              31.5% {
                -webkit-transform: translateX(-3px) rotateY(-5deg);
                transform: translateX(-3px) rotateY(-5deg);
                -webkit-animation-timing-function: ease-in-out;
                animation-timing-function: ease-in-out;
              }

              43.5% {
                -webkit-transform: translateX(2px) rotateY(3deg);
                transform: translateX(2px) rotateY(3deg);
                -webkit-animation-timing-function: ease-in-out;
                animation-timing-function: ease-in-out;
              }

              50% {
                -webkit-transform: translateX(0);
                transform: translateX(0);
                -webkit-animation-timing-function: ease-in-out;
                animation-timing-function: ease-in-out;
              }
            }

            @keyframes headShake {
              0% {
                -webkit-transform: translateX(0);
                transform: translateX(0);
                -webkit-animation-timing-function: ease-in-out;
                animation-timing-function: ease-in-out;
              }

              6.5% {
                -webkit-transform: translateX(-6px) rotateY(-9deg);
                transform: translateX(-6px) rotateY(-9deg);
                -webkit-animation-timing-function: ease-in-out;
                animation-timing-function: ease-in-out;
              }

              18.5% {
                -webkit-transform: translateX(5px) rotateY(7deg);
                transform: translateX(5px) rotateY(7deg);
                -webkit-animation-timing-function: ease-in-out;
                animation-timing-function: ease-in-out;
              }

              31.5% {
                -webkit-transform: translateX(-3px) rotateY(-5deg);
                transform: translateX(-3px) rotateY(-5deg);
                -webkit-animation-timing-function: ease-in-out;
                animation-timing-function: ease-in-out;
              }

              43.5% {
                -webkit-transform: translateX(2px) rotateY(3deg);
                transform: translateX(2px) rotateY(3deg);
                -webkit-animation-timing-function: ease-in-out;
                animation-timing-function: ease-in-out;
              }

              50% {
                -webkit-transform: translateX(0);
                transform: translateX(0);
                -webkit-animation-timing-function: ease-in-out;
                animation-timing-function: ease-in-out;
              }
            }

            @-webkit-keyframes swing {
              20% {
                -webkit-transform: rotate3d(0, 0, 1, 15deg);
                transform: rotate3d(0, 0, 1, 15deg);
                -webkit-transform-origin: top center;
                transform-origin: top center;
              }

              40% {
                -webkit-transform: rotate3d(0, 0, 1, -10deg);
                transform: rotate3d(0, 0, 1, -10deg);
                -webkit-transform-origin: top center;
                transform-origin: top center;
              }

              60% {
                -webkit-transform: rotate3d(0, 0, 1, 5deg);
                transform: rotate3d(0, 0, 1, 5deg);
                -webkit-transform-origin: top center;
                transform-origin: top center;
              }

              80% {
                -webkit-transform: rotate3d(0, 0, 1, -5deg);
                transform: rotate3d(0, 0, 1, -5deg);
                -webkit-transform-origin: top center;
                transform-origin: top center;
              }

              to {
                -webkit-transform: rotate3d(0, 0, 1, 0deg);
                transform: rotate3d(0, 0, 1, 0deg);
                -webkit-transform-origin: top center;
                transform-origin: top center;
              }
            }

            @keyframes swing {
              20% {
                -webkit-transform: rotate3d(0, 0, 1, 15deg);
                transform: rotate3d(0, 0, 1, 15deg);
                -webkit-transform-origin: top center;
                transform-origin: top center;
              }

              40% {
                -webkit-transform: rotate3d(0, 0, 1, -10deg);
                transform: rotate3d(0, 0, 1, -10deg);
                -webkit-transform-origin: top center;
                transform-origin: top center;
              }

              60% {
                -webkit-transform: rotate3d(0, 0, 1, 5deg);
                transform: rotate3d(0, 0, 1, 5deg);
                -webkit-transform-origin: top center;
                transform-origin: top center;
              }

              80% {
                -webkit-transform: rotate3d(0, 0, 1, -5deg);
                transform: rotate3d(0, 0, 1, -5deg);
                -webkit-transform-origin: top center;
                transform-origin: top center;
              }

              to {
                -webkit-transform: rotate3d(0, 0, 1, 0deg);
                transform: rotate3d(0, 0, 1, 0deg);
                -webkit-transform-origin: top center;
                transform-origin: top center;
              }
            }

            @-webkit-keyframes tada {
              from {
                -webkit-transform: scale3d(1, 1, 1);
                transform: scale3d(1, 1, 1);
              }

              10%, 20% {
                -webkit-transform: scale3d(.9, .9, .9) rotate3d(0, 0, 1, -3deg);
                transform: scale3d(.9, .9, .9) rotate3d(0, 0, 1, -3deg);
              }

              30%, 50%, 70%, 90% {
                -webkit-transform: scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg);
                transform: scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg);
              }

              40%, 60%, 80% {
                -webkit-transform: scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, -3deg);
                transform: scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, -3deg);
              }

              to {
                -webkit-transform: scale3d(1, 1, 1);
                transform: scale3d(1, 1, 1);
              }
            }

            @keyframes tada {
              from {
                -webkit-transform: scale3d(1, 1, 1);
                transform: scale3d(1, 1, 1);
              }

              10%, 20% {
                -webkit-transform: scale3d(.9, .9, .9) rotate3d(0, 0, 1, -3deg);
                transform: scale3d(.9, .9, .9) rotate3d(0, 0, 1, -3deg);
              }

              30%, 50%, 70%, 90% {
                -webkit-transform: scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg);
                transform: scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg);
              }

              40%, 60%, 80% {
                -webkit-transform: scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, -3deg);
                transform: scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, -3deg);
              }

              to {
                -webkit-transform: scale3d(1, 1, 1);
                transform: scale3d(1, 1, 1);
              }
            }

            /* originally authored by Nick Pettit - https://github.com/nickpettit/glide */

            @-webkit-keyframes wobble {
              from {
                -webkit-transform: none;
                transform: none;
              }

              15% {
                -webkit-transform: translate3d(-25%, 0, 0) rotate3d(0, 0, 1, -5deg);
                transform: translate3d(-25%, 0, 0) rotate3d(0, 0, 1, -5deg);
              }

              30% {
                -webkit-transform: translate3d(20%, 0, 0) rotate3d(0, 0, 1, 3deg);
                transform: translate3d(20%, 0, 0) rotate3d(0, 0, 1, 3deg);
              }

              45% {
                -webkit-transform: translate3d(-15%, 0, 0) rotate3d(0, 0, 1, -3deg);
                transform: translate3d(-15%, 0, 0) rotate3d(0, 0, 1, -3deg);
              }

              60% {
                -webkit-transform: translate3d(10%, 0, 0) rotate3d(0, 0, 1, 2deg);
                transform: translate3d(10%, 0, 0) rotate3d(0, 0, 1, 2deg);
              }

              75% {
                -webkit-transform: translate3d(-5%, 0, 0) rotate3d(0, 0, 1, -1deg);
                transform: translate3d(-5%, 0, 0) rotate3d(0, 0, 1, -1deg);
              }

              to {
                -webkit-transform: none;
                transform: none;
              }
            }

            @keyframes wobble {
              from {
                -webkit-transform: none;
                transform: none;
              }

              15% {
                -webkit-transform: translate3d(-25%, 0, 0) rotate3d(0, 0, 1, -5deg);
                transform: translate3d(-25%, 0, 0) rotate3d(0, 0, 1, -5deg);
              }

              30% {
                -webkit-transform: translate3d(20%, 0, 0) rotate3d(0, 0, 1, 3deg);
                transform: translate3d(20%, 0, 0) rotate3d(0, 0, 1, 3deg);
              }

              45% {
                -webkit-transform: translate3d(-15%, 0, 0) rotate3d(0, 0, 1, -3deg);
                transform: translate3d(-15%, 0, 0) rotate3d(0, 0, 1, -3deg);
              }

              60% {
                -webkit-transform: translate3d(10%, 0, 0) rotate3d(0, 0, 1, 2deg);
                transform: translate3d(10%, 0, 0) rotate3d(0, 0, 1, 2deg);
              }

              75% {
                -webkit-transform: translate3d(-5%, 0, 0) rotate3d(0, 0, 1, -1deg);
                transform: translate3d(-5%, 0, 0) rotate3d(0, 0, 1, -1deg);
              }

              to {
                -webkit-transform: none;
                transform: none;
              }
            }

            @-webkit-keyframes jello {
              from, 11.1%, to {
                -webkit-transform: none;
                transform: none;
                -webkit-transform-origin: center;
                transform-origin: center;
              }

              22.2% {
                -webkit-transform: skewX(-12.5deg) skewY(-12.5deg);
                transform: skewX(-12.5deg) skewY(-12.5deg);
                -webkit-transform-origin: center;
                transform-origin: center;
              }

              33.3% {
                -webkit-transform: skewX(6.25deg) skewY(6.25deg);
                transform: skewX(6.25deg) skewY(6.25deg);
                -webkit-transform-origin: center;
                transform-origin: center;
              }

              44.4% {
                -webkit-transform: skewX(-3.125deg) skewY(-3.125deg);
                transform: skewX(-3.125deg) skewY(-3.125deg);
                -webkit-transform-origin: center;
                transform-origin: center;
              }

              55.5% {
                -webkit-transform: skewX(1.5625deg) skewY(1.5625deg);
                transform: skewX(1.5625deg) skewY(1.5625deg);
                -webkit-transform-origin: center;
                transform-origin: center;
              }

              66.6% {
                -webkit-transform: skewX(-0.78125deg) skewY(-0.78125deg);
                transform: skewX(-0.78125deg) skewY(-0.78125deg);
                -webkit-transform-origin: center;
                transform-origin: center;
              }

              77.7% {
                -webkit-transform: skewX(0.390625deg) skewY(0.390625deg);
                transform: skewX(0.390625deg) skewY(0.390625deg);
                -webkit-transform-origin: center;
                transform-origin: center;
              }

              88.8% {
                -webkit-transform: skewX(-0.1953125deg) skewY(-0.1953125deg);
                transform: skewX(-0.1953125deg) skewY(-0.1953125deg);
                -webkit-transform-origin: center;
                transform-origin: center;
              }
            }

            @keyframes jello {
              from, 11.1%, to {
                -webkit-transform: none;
                transform: none;
                -webkit-transform-origin: center;
                transform-origin: center;
              }

              22.2% {
                -webkit-transform: skewX(-12.5deg) skewY(-12.5deg);
                transform: skewX(-12.5deg) skewY(-12.5deg);
                -webkit-transform-origin: center;
                transform-origin: center;
              }

              33.3% {
                -webkit-transform: skewX(6.25deg) skewY(6.25deg);
                transform: skewX(6.25deg) skewY(6.25deg);
                -webkit-transform-origin: center;
                transform-origin: center;
              }

              44.4% {
                -webkit-transform: skewX(-3.125deg) skewY(-3.125deg);
                transform: skewX(-3.125deg) skewY(-3.125deg);
                -webkit-transform-origin: center;
                transform-origin: center;
              }

              55.5% {
                -webkit-transform: skewX(1.5625deg) skewY(1.5625deg);
                transform: skewX(1.5625deg) skewY(1.5625deg);
                -webkit-transform-origin: center;
                transform-origin: center;
              }

              66.6% {
                -webkit-transform: skewX(-0.78125deg) skewY(-0.78125deg);
                transform: skewX(-0.78125deg) skewY(-0.78125deg);
                -webkit-transform-origin: center;
                transform-origin: center;
              }

              77.7% {
                -webkit-transform: skewX(0.390625deg) skewY(0.390625deg);
                transform: skewX(0.390625deg) skewY(0.390625deg);
                -webkit-transform-origin: center;
                transform-origin: center;
              }

              88.8% {
                -webkit-transform: skewX(-0.1953125deg) skewY(-0.1953125deg);
                transform: skewX(-0.1953125deg) skewY(-0.1953125deg);
                -webkit-transform-origin: center;
                transform-origin: center;
              }
            }

            @-webkit-keyframes bounceIn {
              from, 20%, 40%, 60%, 80%, to {
                -webkit-animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
                animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
              }

              0% {
                opacity: 0;
                -webkit-transform: scale3d(.3, .3, .3);
                transform: scale3d(.3, .3, .3);
              }

              20% {
                -webkit-transform: scale3d(1.1, 1.1, 1.1);
                transform: scale3d(1.1, 1.1, 1.1);
              }

              40% {
                -webkit-transform: scale3d(.9, .9, .9);
                transform: scale3d(.9, .9, .9);
              }

              60% {
                opacity: 1;
                -webkit-transform: scale3d(1.03, 1.03, 1.03);
                transform: scale3d(1.03, 1.03, 1.03);
              }

              80% {
                -webkit-transform: scale3d(.97, .97, .97);
                transform: scale3d(.97, .97, .97);
              }

              to {
                opacity: 1;
                -webkit-transform: scale3d(1, 1, 1);
                transform: scale3d(1, 1, 1);
              }
            }

            @keyframes bounceIn {
              from, 20%, 40%, 60%, 80%, to {
                -webkit-animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
                animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
              }

              0% {
                opacity: 0;
                -webkit-transform: scale3d(.3, .3, .3);
                transform: scale3d(.3, .3, .3);
              }

              20% {
                -webkit-transform: scale3d(1.1, 1.1, 1.1);
                transform: scale3d(1.1, 1.1, 1.1);
              }

              40% {
                -webkit-transform: scale3d(.9, .9, .9);
                transform: scale3d(.9, .9, .9);
              }

              60% {
                opacity: 1;
                -webkit-transform: scale3d(1.03, 1.03, 1.03);
                transform: scale3d(1.03, 1.03, 1.03);
              }

              80% {
                -webkit-transform: scale3d(.97, .97, .97);
                transform: scale3d(.97, .97, .97);
              }

              to {
                opacity: 1;
                -webkit-transform: scale3d(1, 1, 1);
                transform: scale3d(1, 1, 1);
              }
            }

            @-webkit-keyframes bounceInDown {
              from, 60%, 75%, 90%, to {
                -webkit-animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
                animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
              }

              0% {
                opacity: 0;
                -webkit-transform: translate3d(0, -3000px, 0);
                transform: translate3d(0, -3000px, 0);
              }

              60% {
                opacity: 1;
                -webkit-transform: translate3d(0, 25px, 0);
                transform: translate3d(0, 25px, 0);
              }

              75% {
                -webkit-transform: translate3d(0, -10px, 0);
                transform: translate3d(0, -10px, 0);
              }

              90% {
                -webkit-transform: translate3d(0, 5px, 0);
                transform: translate3d(0, 5px, 0);
              }

              to {
                -webkit-transform: none;
                transform: none;
              }
            }

            @keyframes bounceInDown {
              from, 60%, 75%, 90%, to {
                -webkit-animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
                animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
              }

              0% {
                opacity: 0;
                -webkit-transform: translate3d(0, -3000px, 0);
                transform: translate3d(0, -3000px, 0);
              }

              60% {
                opacity: 1;
                -webkit-transform: translate3d(0, 25px, 0);
                transform: translate3d(0, 25px, 0);
              }

              75% {
                -webkit-transform: translate3d(0, -10px, 0);
                transform: translate3d(0, -10px, 0);
              }

              90% {
                -webkit-transform: translate3d(0, 5px, 0);
                transform: translate3d(0, 5px, 0);
              }

              to {
                -webkit-transform: none;
                transform: none;
              }
            }

            @-webkit-keyframes bounceInLeft {
              from, 60%, 75%, 90%, to {
                -webkit-animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
                animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
              }

              0% {
                opacity: 0;
                -webkit-transform: translate3d(-3000px, 0, 0);
                transform: translate3d(-3000px, 0, 0);
              }

              60% {
                opacity: 1;
                -webkit-transform: translate3d(25px, 0, 0);
                transform: translate3d(25px, 0, 0);
              }

              75% {
                -webkit-transform: translate3d(-10px, 0, 0);
                transform: translate3d(-10px, 0, 0);
              }

              90% {
                -webkit-transform: translate3d(5px, 0, 0);
                transform: translate3d(5px, 0, 0);
              }

              to {
                -webkit-transform: none;
                transform: none;
              }
            }

            @keyframes bounceInLeft {
              from, 60%, 75%, 90%, to {
                -webkit-animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
                animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
              }

              0% {
                opacity: 0;
                -webkit-transform: translate3d(-3000px, 0, 0);
                transform: translate3d(-3000px, 0, 0);
              }

              60% {
                opacity: 1;
                -webkit-transform: translate3d(25px, 0, 0);
                transform: translate3d(25px, 0, 0);
              }

              75% {
                -webkit-transform: translate3d(-10px, 0, 0);
                transform: translate3d(-10px, 0, 0);
              }

              90% {
                -webkit-transform: translate3d(5px, 0, 0);
                transform: translate3d(5px, 0, 0);
              }

              to {
                -webkit-transform: none;
                transform: none;
              }
            }

            @-webkit-keyframes bounceInRight {
              from, 60%, 75%, 90%, to {
                -webkit-animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
                animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
              }

              from {
                opacity: 0;
                -webkit-transform: translate3d(3000px, 0, 0);
                transform: translate3d(3000px, 0, 0);
              }

              60% {
                opacity: 1;
                -webkit-transform: translate3d(-25px, 0, 0);
                transform: translate3d(-25px, 0, 0);
              }

              75% {
                -webkit-transform: translate3d(10px, 0, 0);
                transform: translate3d(10px, 0, 0);
              }

              90% {
                -webkit-transform: translate3d(-5px, 0, 0);
                transform: translate3d(-5px, 0, 0);
              }

              to {
                -webkit-transform: none;
                transform: none;
              }
            }

            @keyframes bounceInRight {
              from, 60%, 75%, 90%, to {
                -webkit-animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
                animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
              }

              from {
                opacity: 0;
                -webkit-transform: translate3d(3000px, 0, 0);
                transform: translate3d(3000px, 0, 0);
              }

              60% {
                opacity: 1;
                -webkit-transform: translate3d(-25px, 0, 0);
                transform: translate3d(-25px, 0, 0);
              }

              75% {
                -webkit-transform: translate3d(10px, 0, 0);
                transform: translate3d(10px, 0, 0);
              }

              90% {
                -webkit-transform: translate3d(-5px, 0, 0);
                transform: translate3d(-5px, 0, 0);
              }

              to {
                -webkit-transform: none;
                transform: none;
              }
            }

            @-webkit-keyframes bounceInUp {
              from, 60%, 75%, 90%, to {
                -webkit-animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
                animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
              }

              from {
                opacity: 0;
                -webkit-transform: translate3d(0, 3000px, 0);
                transform: translate3d(0, 3000px, 0);
              }

              60% {
                opacity: 1;
                -webkit-transform: translate3d(0, -20px, 0);
                transform: translate3d(0, -20px, 0);
              }

              75% {
                -webkit-transform: translate3d(0, 10px, 0);
                transform: translate3d(0, 10px, 0);
              }

              90% {
                -webkit-transform: translate3d(0, -5px, 0);
                transform: translate3d(0, -5px, 0);
              }

              to {
                -webkit-transform: translate3d(0, 0, 0);
                transform: translate3d(0, 0, 0);
              }
            }

            @keyframes bounceInUp {
              from, 60%, 75%, 90%, to {
                -webkit-animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
                animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
              }

              from {
                opacity: 0;
                -webkit-transform: translate3d(0, 3000px, 0);
                transform: translate3d(0, 3000px, 0);
              }

              60% {
                opacity: 1;
                -webkit-transform: translate3d(0, -20px, 0);
                transform: translate3d(0, -20px, 0);
              }

              75% {
                -webkit-transform: translate3d(0, 10px, 0);
                transform: translate3d(0, 10px, 0);
              }

              90% {
                -webkit-transform: translate3d(0, -5px, 0);
                transform: translate3d(0, -5px, 0);
              }

              to {
                -webkit-transform: translate3d(0, 0, 0);
                transform: translate3d(0, 0, 0);
              }
            }

            @-webkit-keyframes bounceOut {
              20% {
                -webkit-transform: scale3d(.9, .9, .9);
                transform: scale3d(.9, .9, .9);
              }

              50%, 55% {
                opacity: 1;
                -webkit-transform: scale3d(1.1, 1.1, 1.1);
                transform: scale3d(1.1, 1.1, 1.1);
              }

              to {
                opacity: 0;
                -webkit-transform: scale3d(.3, .3, .3);
                transform: scale3d(.3, .3, .3);
              }
            }

            @keyframes bounceOut {
              20% {
                -webkit-transform: scale3d(.9, .9, .9);
                transform: scale3d(.9, .9, .9);
              }

              50%, 55% {
                opacity: 1;
                -webkit-transform: scale3d(1.1, 1.1, 1.1);
                transform: scale3d(1.1, 1.1, 1.1);
              }

              to {
                opacity: 0;
                -webkit-transform: scale3d(.3, .3, .3);
                transform: scale3d(.3, .3, .3);
              }
            }

            @-webkit-keyframes bounceOutDown {
              20% {
                -webkit-transform: translate3d(0, 10px, 0);
                transform: translate3d(0, 10px, 0);
              }

              40%, 45% {
                opacity: 1;
                -webkit-transform: translate3d(0, -20px, 0);
                transform: translate3d(0, -20px, 0);
              }

              to {
                opacity: 0;
                -webkit-transform: translate3d(0, 2000px, 0);
                transform: translate3d(0, 2000px, 0);
              }
            }

            @keyframes bounceOutDown {
              20% {
                -webkit-transform: translate3d(0, 10px, 0);
                transform: translate3d(0, 10px, 0);
              }

              40%, 45% {
                opacity: 1;
                -webkit-transform: translate3d(0, -20px, 0);
                transform: translate3d(0, -20px, 0);
              }

              to {
                opacity: 0;
                -webkit-transform: translate3d(0, 2000px, 0);
                transform: translate3d(0, 2000px, 0);
              }
            }

            @-webkit-keyframes bounceOutLeft {
              20% {
                opacity: 1;
                -webkit-transform: translate3d(20px, 0, 0);
                transform: translate3d(20px, 0, 0);
              }

              to {
                opacity: 0;
                -webkit-transform: translate3d(-2000px, 0, 0);
                transform: translate3d(-2000px, 0, 0);
              }
            }

            @keyframes bounceOutLeft {
              20% {
                opacity: 1;
                -webkit-transform: translate3d(20px, 0, 0);
                transform: translate3d(20px, 0, 0);
              }

              to {
                opacity: 0;
                -webkit-transform: translate3d(-2000px, 0, 0);
                transform: translate3d(-2000px, 0, 0);
              }
            }

            @-webkit-keyframes bounceOutRight {
              20% {
                opacity: 1;
                -webkit-transform: translate3d(-20px, 0, 0);
                transform: translate3d(-20px, 0, 0);
              }

              to {
                opacity: 0;
                -webkit-transform: translate3d(2000px, 0, 0);
                transform: translate3d(2000px, 0, 0);
              }
            }

            @keyframes bounceOutRight {
              20% {
                opacity: 1;
                -webkit-transform: translate3d(-20px, 0, 0);
                transform: translate3d(-20px, 0, 0);
              }

              to {
                opacity: 0;
                -webkit-transform: translate3d(2000px, 0, 0);
                transform: translate3d(2000px, 0, 0);
              }
            }

            @-webkit-keyframes bounceOutUp {
              20% {
                -webkit-transform: translate3d(0, -10px, 0);
                transform: translate3d(0, -10px, 0);
              }

              40%, 45% {
                opacity: 1;
                -webkit-transform: translate3d(0, 20px, 0);
                transform: translate3d(0, 20px, 0);
              }

              to {
                opacity: 0;
                -webkit-transform: translate3d(0, -2000px, 0);
                transform: translate3d(0, -2000px, 0);
              }
            }

            @keyframes bounceOutUp {
              20% {
                -webkit-transform: translate3d(0, -10px, 0);
                transform: translate3d(0, -10px, 0);
              }

              40%, 45% {
                opacity: 1;
                -webkit-transform: translate3d(0, 20px, 0);
                transform: translate3d(0, 20px, 0);
              }

              to {
                opacity: 0;
                -webkit-transform: translate3d(0, -2000px, 0);
                transform: translate3d(0, -2000px, 0);
              }
            }

            @-webkit-keyframes fadeIn {
              from {
                opacity: 0;
              }

              to {
                opacity: 1;
              }
            }

            @keyframes fadeIn {
              from {
                opacity: 0;
              }

              to {
                opacity: 1;
              }
            }

            @-webkit-keyframes fadeInDown {
              from {
                opacity: 0;
                -webkit-transform: translate3d(0, -100%, 0);
                transform: translate3d(0, -100%, 0);
              }

              to {
                opacity: 1;
                -webkit-transform: none;
                transform: none;
              }
            }

            @keyframes fadeInDown {
              from {
                opacity: 0;
                -webkit-transform: translate3d(0, -100%, 0);
                transform: translate3d(0, -100%, 0);
              }

              to {
                opacity: 1;
                -webkit-transform: none;
                transform: none;
              }
            }

            @-webkit-keyframes fadeInDownBig {
              from {
                opacity: 0;
                -webkit-transform: translate3d(0, -2000px, 0);
                transform: translate3d(0, -2000px, 0);
              }

              to {
                opacity: 1;
                -webkit-transform: none;
                transform: none;
              }
            }

            @keyframes fadeInDownBig {
              from {
                opacity: 0;
                -webkit-transform: translate3d(0, -2000px, 0);
                transform: translate3d(0, -2000px, 0);
              }

              to {
                opacity: 1;
                -webkit-transform: none;
                transform: none;
              }
            }

            @-webkit-keyframes fadeInLeft {
              from {
                opacity: 0;
                -webkit-transform: translate3d(-100%, 0, 0);
                transform: translate3d(-100%, 0, 0);
              }

              to {
                opacity: 1;
                -webkit-transform: none;
                transform: none;
              }
            }

            @keyframes fadeInLeft {
              from {
                opacity: 0;
                -webkit-transform: translate3d(-100%, 0, 0);
                transform: translate3d(-100%, 0, 0);
              }

              to {
                opacity: 1;
                -webkit-transform: none;
                transform: none;
              }
            }

            @-webkit-keyframes fadeInLeftBig {
              from {
                opacity: 0;
                -webkit-transform: translate3d(-2000px, 0, 0);
                transform: translate3d(-2000px, 0, 0);
              }

              to {
                opacity: 1;
                -webkit-transform: none;
                transform: none;
              }
            }

            @keyframes fadeInLeftBig {
              from {
                opacity: 0;
                -webkit-transform: translate3d(-2000px, 0, 0);
                transform: translate3d(-2000px, 0, 0);
              }

              to {
                opacity: 1;
                -webkit-transform: none;
                transform: none;
              }
            }

            @-webkit-keyframes fadeInRight {
              from {
                opacity: 0;
                -webkit-transform: translate3d(100%, 0, 0);
                transform: translate3d(100%, 0, 0);
              }

              to {
                opacity: 1;
                -webkit-transform: none;
                transform: none;
              }
            }

            @keyframes fadeInRight {
              from {
                opacity: 0;
                -webkit-transform: translate3d(100%, 0, 0);
                transform: translate3d(100%, 0, 0);
              }

              to {
                opacity: 1;
                -webkit-transform: none;
                transform: none;
              }
            }

            @-webkit-keyframes fadeInRightBig {
              from {
                opacity: 0;
                -webkit-transform: translate3d(2000px, 0, 0);
                transform: translate3d(2000px, 0, 0);
              }

              to {
                opacity: 1;
                -webkit-transform: none;
                transform: none;
              }
            }

            @keyframes fadeInRightBig {
              from {
                opacity: 0;
                -webkit-transform: translate3d(2000px, 0, 0);
                transform: translate3d(2000px, 0, 0);
              }

              to {
                opacity: 1;
                -webkit-transform: none;
                transform: none;
              }
            }

            @-webkit-keyframes fadeInUp {
              from {
                opacity: 0;
                -webkit-transform: translate3d(0, 100%, 0);
                transform: translate3d(0, 100%, 0);
              }

              to {
                opacity: 1;
                -webkit-transform: none;
                transform: none;
              }
            }

            @keyframes fadeInUp {
              from {
                opacity: 0;
                -webkit-transform: translate3d(0, 100%, 0);
                transform: translate3d(0, 100%, 0);
              }

              to {
                opacity: 1;
                -webkit-transform: none;
                transform: none;
              }
            }

            @-webkit-keyframes fadeInUpBig {
              from {
                opacity: 0;
                -webkit-transform: translate3d(0, 2000px, 0);
                transform: translate3d(0, 2000px, 0);
              }

              to {
                opacity: 1;
                -webkit-transform: none;
                transform: none;
              }
            }

            @keyframes fadeInUpBig {
              from {
                opacity: 0;
                -webkit-transform: translate3d(0, 2000px, 0);
                transform: translate3d(0, 2000px, 0);
              }

              to {
                opacity: 1;
                -webkit-transform: none;
                transform: none;
              }
            }

            @-webkit-keyframes fadeOut {
              from {
                opacity: 1;
              }

              to {
                opacity: 0;
              }
            }

            @keyframes fadeOut {
              from {
                opacity: 1;
              }

              to {
                opacity: 0;
              }
            }

            @-webkit-keyframes fadeOutDown {
              from {
                opacity: 1;
              }

              to {
                opacity: 0;
                -webkit-transform: translate3d(0, 100%, 0);
                transform: translate3d(0, 100%, 0);
              }
            }

            @keyframes fadeOutDown {
              from {
                opacity: 1;
              }

              to {
                opacity: 0;
                -webkit-transform: translate3d(0, 100%, 0);
                transform: translate3d(0, 100%, 0);
              }
            }

            @-webkit-keyframes fadeOutDownBig {
              from {
                opacity: 1;
              }

              to {
                opacity: 0;
                -webkit-transform: translate3d(0, 2000px, 0);
                transform: translate3d(0, 2000px, 0);
              }
            }

            @keyframes fadeOutDownBig {
              from {
                opacity: 1;
              }

              to {
                opacity: 0;
                -webkit-transform: translate3d(0, 2000px, 0);
                transform: translate3d(0, 2000px, 0);
              }
            }

            @-webkit-keyframes fadeOutLeft {
              from {
                opacity: 1;
              }

              to {
                opacity: 0;
                -webkit-transform: translate3d(-100%, 0, 0);
                transform: translate3d(-100%, 0, 0);
              }
            }

            @keyframes fadeOutLeft {
              from {
                opacity: 1;
              }

              to {
                opacity: 0;
                -webkit-transform: translate3d(-100%, 0, 0);
                transform: translate3d(-100%, 0, 0);
              }
            }

            @-webkit-keyframes fadeOutLeftBig {
              from {
                opacity: 1;
              }

              to {
                opacity: 0;
                -webkit-transform: translate3d(-2000px, 0, 0);
                transform: translate3d(-2000px, 0, 0);
              }
            }

            @keyframes fadeOutLeftBig {
              from {
                opacity: 1;
              }

              to {
                opacity: 0;
                -webkit-transform: translate3d(-2000px, 0, 0);
                transform: translate3d(-2000px, 0, 0);
              }
            }

            @-webkit-keyframes fadeOutRight {
              from {
                opacity: 1;
              }

              to {
                opacity: 0;
                -webkit-transform: translate3d(100%, 0, 0);
                transform: translate3d(100%, 0, 0);
              }
            }

            @keyframes fadeOutRight {
              from {
                opacity: 1;
              }

              to {
                opacity: 0;
                -webkit-transform: translate3d(100%, 0, 0);
                transform: translate3d(100%, 0, 0);
              }
            }

            @-webkit-keyframes fadeOutRightBig {
              from {
                opacity: 1;
              }

              to {
                opacity: 0;
                -webkit-transform: translate3d(2000px, 0, 0);
                transform: translate3d(2000px, 0, 0);
              }
            }

            @keyframes fadeOutRightBig {
              from {
                opacity: 1;
              }

              to {
                opacity: 0;
                -webkit-transform: translate3d(2000px, 0, 0);
                transform: translate3d(2000px, 0, 0);
              }
            }

            @-webkit-keyframes fadeOutUp {
              from {
                opacity: 1;
              }

              to {
                opacity: 0;
                -webkit-transform: translate3d(0, -100%, 0);
                transform: translate3d(0, -100%, 0);
              }
            }

            @keyframes fadeOutUp {
              from {
                opacity: 1;
              }

              to {
                opacity: 0;
                -webkit-transform: translate3d(0, -100%, 0);
                transform: translate3d(0, -100%, 0);
              }
            }

            @-webkit-keyframes fadeOutUpBig {
              from {
                opacity: 1;
              }

              to {
                opacity: 0;
                -webkit-transform: translate3d(0, -2000px, 0);
                transform: translate3d(0, -2000px, 0);
              }
            }

            @keyframes fadeOutUpBig {
              from {
                opacity: 1;
              }

              to {
                opacity: 0;
                -webkit-transform: translate3d(0, -2000px, 0);
                transform: translate3d(0, -2000px, 0);
              }
            }

            @-webkit-keyframes flip {
              from {
                -webkit-transform: perspective(400px) rotate3d(0, 1, 0, -360deg);
                transform: perspective(400px) rotate3d(0, 1, 0, -360deg);
                -webkit-animation-timing-function: ease-out;
                animation-timing-function: ease-out;
                -webkit-backface-visibility: visible;
                backface-visibility: visible;
              }

              40% {
                -webkit-transform: perspective(400px) translate3d(0, 0, 150px) rotate3d(0, 1, 0, -190deg);
                transform: perspective(400px) translate3d(0, 0, 150px) rotate3d(0, 1, 0, -190deg);
                -webkit-animation-timing-function: ease-out;
                animation-timing-function: ease-out;
                -webkit-backface-visibility: visible;
                backface-visibility: visible;
              }

              50% {
                -webkit-transform: perspective(400px) translate3d(0, 0, 150px) rotate3d(0, 1, 0, -170deg);
                transform: perspective(400px) translate3d(0, 0, 150px) rotate3d(0, 1, 0, -170deg);
                -webkit-animation-timing-function: ease-in;
                animation-timing-function: ease-in;
                -webkit-backface-visibility: visible;
                backface-visibility: visible;
              }

              80% {
                -webkit-transform: perspective(400px) scale3d(.95, .95, .95);
                transform: perspective(400px) scale3d(.95, .95, .95);
                -webkit-animation-timing-function: ease-in;
                animation-timing-function: ease-in;
                -webkit-backface-visibility: visible;
                backface-visibility: visible;
              }

              to {
                -webkit-transform: perspective(400px);
                transform: perspective(400px);
                -webkit-animation-timing-function: ease-in;
                animation-timing-function: ease-in;
                -webkit-backface-visibility: visible;
                backface-visibility: visible;
              }
            }

            @keyframes flip {
              from {
                -webkit-transform: perspective(400px) rotate3d(0, 1, 0, -360deg);
                transform: perspective(400px) rotate3d(0, 1, 0, -360deg);
                -webkit-animation-timing-function: ease-out;
                animation-timing-function: ease-out;
                -webkit-backface-visibility: visible;
                backface-visibility: visible;
              }

              40% {
                -webkit-transform: perspective(400px) translate3d(0, 0, 150px) rotate3d(0, 1, 0, -190deg);
                transform: perspective(400px) translate3d(0, 0, 150px) rotate3d(0, 1, 0, -190deg);
                -webkit-animation-timing-function: ease-out;
                animation-timing-function: ease-out;
                -webkit-backface-visibility: visible;
                backface-visibility: visible;
              }

              50% {
                -webkit-transform: perspective(400px) translate3d(0, 0, 150px) rotate3d(0, 1, 0, -170deg);
                transform: perspective(400px) translate3d(0, 0, 150px) rotate3d(0, 1, 0, -170deg);
                -webkit-animation-timing-function: ease-in;
                animation-timing-function: ease-in;
                -webkit-backface-visibility: visible;
                backface-visibility: visible;
              }

              80% {
                -webkit-transform: perspective(400px) scale3d(.95, .95, .95);
                transform: perspective(400px) scale3d(.95, .95, .95);
                -webkit-animation-timing-function: ease-in;
                animation-timing-function: ease-in;
                -webkit-backface-visibility: visible;
                backface-visibility: visible;
              }

              to {
                -webkit-transform: perspective(400px);
                transform: perspective(400px);
                -webkit-animation-timing-function: ease-in;
                animation-timing-function: ease-in;
                -webkit-backface-visibility: visible;
                backface-visibility: visible;
              }
            }

            @-webkit-keyframes flipInX {
              from {
                -webkit-transform: perspective(400px) rotate3d(1, 0, 0, 90deg);
                transform: perspective(400px) rotate3d(1, 0, 0, 90deg);
                -webkit-animation-timing-function: ease-in;
                animation-timing-function: ease-in;
                opacity: 0;
                -webkit-backface-visibility: visible !important;
                backface-visibility: visible !important;
              }

              40% {
                -webkit-transform: perspective(400px) rotate3d(1, 0, 0, -20deg);
                transform: perspective(400px) rotate3d(1, 0, 0, -20deg);
                -webkit-animation-timing-function: ease-in;
                animation-timing-function: ease-in;
                -webkit-backface-visibility: visible !important;
                backface-visibility: visible !important;
              }

              60% {
                -webkit-transform: perspective(400px) rotate3d(1, 0, 0, 10deg);
                transform: perspective(400px) rotate3d(1, 0, 0, 10deg);
                opacity: 1;
                -webkit-backface-visibility: visible !important;
                backface-visibility: visible !important;
              }

              80% {
                -webkit-transform: perspective(400px) rotate3d(1, 0, 0, -5deg);
                transform: perspective(400px) rotate3d(1, 0, 0, -5deg);
                -webkit-backface-visibility: visible !important;
                backface-visibility: visible !important;
              }

              to {
                -webkit-transform: perspective(400px);
                transform: perspective(400px);
                -webkit-backface-visibility: visible !important;
                backface-visibility: visible !important;
              }
            }

            @keyframes flipInX {
              from {
                -webkit-transform: perspective(400px) rotate3d(1, 0, 0, 90deg);
                transform: perspective(400px) rotate3d(1, 0, 0, 90deg);
                -webkit-animation-timing-function: ease-in;
                animation-timing-function: ease-in;
                opacity: 0;
                -webkit-backface-visibility: visible !important;
                backface-visibility: visible !important;
              }

              40% {
                -webkit-transform: perspective(400px) rotate3d(1, 0, 0, -20deg);
                transform: perspective(400px) rotate3d(1, 0, 0, -20deg);
                -webkit-animation-timing-function: ease-in;
                animation-timing-function: ease-in;
                -webkit-backface-visibility: visible !important;
                backface-visibility: visible !important;
              }

              60% {
                -webkit-transform: perspective(400px) rotate3d(1, 0, 0, 10deg);
                transform: perspective(400px) rotate3d(1, 0, 0, 10deg);
                opacity: 1;
                -webkit-backface-visibility: visible !important;
                backface-visibility: visible !important;
              }

              80% {
                -webkit-transform: perspective(400px) rotate3d(1, 0, 0, -5deg);
                transform: perspective(400px) rotate3d(1, 0, 0, -5deg);
                -webkit-backface-visibility: visible !important;
                backface-visibility: visible !important;
              }

              to {
                -webkit-transform: perspective(400px);
                transform: perspective(400px);
                -webkit-backface-visibility: visible !important;
                backface-visibility: visible !important;
              }
            }

            @-webkit-keyframes flipInY {
              from {
                -webkit-transform: perspective(400px) rotate3d(0, 1, 0, 90deg);
                transform: perspective(400px) rotate3d(0, 1, 0, 90deg);
                -webkit-animation-timing-function: ease-in;
                animation-timing-function: ease-in;
                opacity: 0;
                -webkit-backface-visibility: visible !important;
                backface-visibility: visible !important;
              }

              40% {
                -webkit-transform: perspective(400px) rotate3d(0, 1, 0, -20deg);
                transform: perspective(400px) rotate3d(0, 1, 0, -20deg);
                -webkit-animation-timing-function: ease-in;
                animation-timing-function: ease-in;
                -webkit-backface-visibility: visible !important;
                backface-visibility: visible !important;
              }

              60% {
                -webkit-transform: perspective(400px) rotate3d(0, 1, 0, 10deg);
                transform: perspective(400px) rotate3d(0, 1, 0, 10deg);
                opacity: 1;
                -webkit-backface-visibility: visible !important;
                backface-visibility: visible !important;
              }

              80% {
                -webkit-transform: perspective(400px) rotate3d(0, 1, 0, -5deg);
                transform: perspective(400px) rotate3d(0, 1, 0, -5deg);
                -webkit-backface-visibility: visible !important;
                backface-visibility: visible !important;
              }

              to {
                -webkit-transform: perspective(400px);
                transform: perspective(400px);
                -webkit-backface-visibility: visible !important;
                backface-visibility: visible !important;
              }
            }

            @keyframes flipInY {
              from {
                -webkit-transform: perspective(400px) rotate3d(0, 1, 0, 90deg);
                transform: perspective(400px) rotate3d(0, 1, 0, 90deg);
                -webkit-animation-timing-function: ease-in;
                animation-timing-function: ease-in;
                opacity: 0;
                -webkit-backface-visibility: visible !important;
                backface-visibility: visible !important;
              }

              40% {
                -webkit-transform: perspective(400px) rotate3d(0, 1, 0, -20deg);
                transform: perspective(400px) rotate3d(0, 1, 0, -20deg);
                -webkit-animation-timing-function: ease-in;
                animation-timing-function: ease-in;
                -webkit-backface-visibility: visible !important;
                backface-visibility: visible !important;
              }

              60% {
                -webkit-transform: perspective(400px) rotate3d(0, 1, 0, 10deg);
                transform: perspective(400px) rotate3d(0, 1, 0, 10deg);
                opacity: 1;
                -webkit-backface-visibility: visible !important;
                backface-visibility: visible !important;
              }

              80% {
                -webkit-transform: perspective(400px) rotate3d(0, 1, 0, -5deg);
                transform: perspective(400px) rotate3d(0, 1, 0, -5deg);
                -webkit-backface-visibility: visible !important;
                backface-visibility: visible !important;
              }

              to {
                -webkit-transform: perspective(400px);
                transform: perspective(400px);
                -webkit-backface-visibility: visible !important;
                backface-visibility: visible !important;
              }
            }

            @-webkit-keyframes flipOutX {
              from {
                -webkit-transform: perspective(400px);
                transform: perspective(400px);
                -webkit-backface-visibility: visible !important;
                backface-visibility: visible !important;
              }

              30% {
                -webkit-transform: perspective(400px) rotate3d(1, 0, 0, -20deg);
                transform: perspective(400px) rotate3d(1, 0, 0, -20deg);
                opacity: 1;
                -webkit-backface-visibility: visible !important;
                backface-visibility: visible !important;
              }

              to {
                -webkit-transform: perspective(400px) rotate3d(1, 0, 0, 90deg);
                transform: perspective(400px) rotate3d(1, 0, 0, 90deg);
                opacity: 0;
                -webkit-backface-visibility: visible !important;
                backface-visibility: visible !important;
              }
            }

            @keyframes flipOutX {
              from {
                -webkit-transform: perspective(400px);
                transform: perspective(400px);
                -webkit-backface-visibility: visible !important;
                backface-visibility: visible !important;
              }

              30% {
                -webkit-transform: perspective(400px) rotate3d(1, 0, 0, -20deg);
                transform: perspective(400px) rotate3d(1, 0, 0, -20deg);
                opacity: 1;
                -webkit-backface-visibility: visible !important;
                backface-visibility: visible !important;
              }

              to {
                -webkit-transform: perspective(400px) rotate3d(1, 0, 0, 90deg);
                transform: perspective(400px) rotate3d(1, 0, 0, 90deg);
                opacity: 0;
                -webkit-backface-visibility: visible !important;
                backface-visibility: visible !important;
              }
            }

            @-webkit-keyframes flipOutY {
              from {
                -webkit-transform: perspective(400px);
                transform: perspective(400px);
                -webkit-backface-visibility: visible !important;
                backface-visibility: visible !important;
              }

              30% {
                -webkit-transform: perspective(400px) rotate3d(0, 1, 0, -15deg);
                transform: perspective(400px) rotate3d(0, 1, 0, -15deg);
                opacity: 1;
                -webkit-backface-visibility: visible !important;
                backface-visibility: visible !important;
              }

              to {
                -webkit-transform: perspective(400px) rotate3d(0, 1, 0, 90deg);
                transform: perspective(400px) rotate3d(0, 1, 0, 90deg);
                opacity: 0;
                -webkit-backface-visibility: visible !important;
                backface-visibility: visible !important;
              }
            }

            @keyframes flipOutY {
              from {
                -webkit-transform: perspective(400px);
                transform: perspective(400px);
                -webkit-backface-visibility: visible !important;
                backface-visibility: visible !important;
              }

              30% {
                -webkit-transform: perspective(400px) rotate3d(0, 1, 0, -15deg);
                transform: perspective(400px) rotate3d(0, 1, 0, -15deg);
                opacity: 1;
                -webkit-backface-visibility: visible !important;
                backface-visibility: visible !important;
              }

              to {
                -webkit-transform: perspective(400px) rotate3d(0, 1, 0, 90deg);
                transform: perspective(400px) rotate3d(0, 1, 0, 90deg);
                opacity: 0;
                -webkit-backface-visibility: visible !important;
                backface-visibility: visible !important;
              }
            }

            @-webkit-keyframes lightSpeedIn {
              from {
                -webkit-transform: translate3d(100%, 0, 0) skewX(-30deg);
                transform: translate3d(100%, 0, 0) skewX(-30deg);
                opacity: 0;
                -webkit-animation-timing-function: ease-out;
                animation-timing-function: ease-out;
              }

              60% {
                -webkit-transform: skewX(20deg);
                transform: skewX(20deg);
                opacity: 1;
                -webkit-animation-timing-function: ease-out;
                animation-timing-function: ease-out;
              }

              80% {
                -webkit-transform: skewX(-5deg);
                transform: skewX(-5deg);
                opacity: 1;
                -webkit-animation-timing-function: ease-out;
                animation-timing-function: ease-out;
              }

              to {
                -webkit-transform: none;
                transform: none;
                opacity: 1;
                -webkit-animation-timing-function: ease-out;
                animation-timing-function: ease-out;
              }
            }

            @keyframes lightSpeedIn {
              from {
                -webkit-transform: translate3d(100%, 0, 0) skewX(-30deg);
                transform: translate3d(100%, 0, 0) skewX(-30deg);
                opacity: 0;
                -webkit-animation-timing-function: ease-out;
                animation-timing-function: ease-out;
              }

              60% {
                -webkit-transform: skewX(20deg);
                transform: skewX(20deg);
                opacity: 1;
                -webkit-animation-timing-function: ease-out;
                animation-timing-function: ease-out;
              }

              80% {
                -webkit-transform: skewX(-5deg);
                transform: skewX(-5deg);
                opacity: 1;
                -webkit-animation-timing-function: ease-out;
                animation-timing-function: ease-out;
              }

              to {
                -webkit-transform: none;
                transform: none;
                opacity: 1;
                -webkit-animation-timing-function: ease-out;
                animation-timing-function: ease-out;
              }
            }

            @-webkit-keyframes lightSpeedOut {
              from {
                opacity: 1;
                -webkit-animation-timing-function: ease-in;
                animation-timing-function: ease-in;
              }

              to {
                -webkit-transform: translate3d(100%, 0, 0) skewX(30deg);
                transform: translate3d(100%, 0, 0) skewX(30deg);
                opacity: 0;
                -webkit-animation-timing-function: ease-in;
                animation-timing-function: ease-in;
              }
            }

            @keyframes lightSpeedOut {
              from {
                opacity: 1;
                -webkit-animation-timing-function: ease-in;
                animation-timing-function: ease-in;
              }

              to {
                -webkit-transform: translate3d(100%, 0, 0) skewX(30deg);
                transform: translate3d(100%, 0, 0) skewX(30deg);
                opacity: 0;
                -webkit-animation-timing-function: ease-in;
                animation-timing-function: ease-in;
              }
            }

            @-webkit-keyframes rotateIn {
              from {
                -webkit-transform-origin: center;
                transform-origin: center;
                -webkit-transform: rotate3d(0, 0, 1, -200deg);
                transform: rotate3d(0, 0, 1, -200deg);
                opacity: 0;
              }

              to {
                -webkit-transform-origin: center;
                transform-origin: center;
                -webkit-transform: none;
                transform: none;
                opacity: 1;
              }
            }

            @keyframes rotateIn {
              from {
                -webkit-transform-origin: center;
                transform-origin: center;
                -webkit-transform: rotate3d(0, 0, 1, -200deg);
                transform: rotate3d(0, 0, 1, -200deg);
                opacity: 0;
              }

              to {
                -webkit-transform-origin: center;
                transform-origin: center;
                -webkit-transform: none;
                transform: none;
                opacity: 1;
              }
            }

            @-webkit-keyframes rotateInDownLeft {
              from {
                -webkit-transform-origin: left bottom;
                transform-origin: left bottom;
                -webkit-transform: rotate3d(0, 0, 1, -45deg);
                transform: rotate3d(0, 0, 1, -45deg);
                opacity: 0;
              }

              to {
                -webkit-transform-origin: left bottom;
                transform-origin: left bottom;
                -webkit-transform: none;
                transform: none;
                opacity: 1;
              }
            }

            @keyframes rotateInDownLeft {
              from {
                -webkit-transform-origin: left bottom;
                transform-origin: left bottom;
                -webkit-transform: rotate3d(0, 0, 1, -45deg);
                transform: rotate3d(0, 0, 1, -45deg);
                opacity: 0;
              }

              to {
                -webkit-transform-origin: left bottom;
                transform-origin: left bottom;
                -webkit-transform: none;
                transform: none;
                opacity: 1;
              }
            }

            @-webkit-keyframes rotateInDownRight {
              from {
                -webkit-transform-origin: right bottom;
                transform-origin: right bottom;
                -webkit-transform: rotate3d(0, 0, 1, 45deg);
                transform: rotate3d(0, 0, 1, 45deg);
                opacity: 0;
              }

              to {
                -webkit-transform-origin: right bottom;
                transform-origin: right bottom;
                -webkit-transform: none;
                transform: none;
                opacity: 1;
              }
            }

            @keyframes rotateInDownRight {
              from {
                -webkit-transform-origin: right bottom;
                transform-origin: right bottom;
                -webkit-transform: rotate3d(0, 0, 1, 45deg);
                transform: rotate3d(0, 0, 1, 45deg);
                opacity: 0;
              }

              to {
                -webkit-transform-origin: right bottom;
                transform-origin: right bottom;
                -webkit-transform: none;
                transform: none;
                opacity: 1;
              }
            }

            @-webkit-keyframes rotateInUpLeft {
              from {
                -webkit-transform-origin: left bottom;
                transform-origin: left bottom;
                -webkit-transform: rotate3d(0, 0, 1, 45deg);
                transform: rotate3d(0, 0, 1, 45deg);
                opacity: 0;
              }

              to {
                -webkit-transform-origin: left bottom;
                transform-origin: left bottom;
                -webkit-transform: none;
                transform: none;
                opacity: 1;
              }
            }

            @keyframes rotateInUpLeft {
              from {
                -webkit-transform-origin: left bottom;
                transform-origin: left bottom;
                -webkit-transform: rotate3d(0, 0, 1, 45deg);
                transform: rotate3d(0, 0, 1, 45deg);
                opacity: 0;
              }

              to {
                -webkit-transform-origin: left bottom;
                transform-origin: left bottom;
                -webkit-transform: none;
                transform: none;
                opacity: 1;
              }
            }

            @-webkit-keyframes rotateInUpRight {
              from {
                -webkit-transform-origin: right bottom;
                transform-origin: right bottom;
                -webkit-transform: rotate3d(0, 0, 1, -90deg);
                transform: rotate3d(0, 0, 1, -90deg);
                opacity: 0;
              }

              to {
                -webkit-transform-origin: right bottom;
                transform-origin: right bottom;
                -webkit-transform: none;
                transform: none;
                opacity: 1;
              }
            }

            @keyframes rotateInUpRight {
              from {
                -webkit-transform-origin: right bottom;
                transform-origin: right bottom;
                -webkit-transform: rotate3d(0, 0, 1, -90deg);
                transform: rotate3d(0, 0, 1, -90deg);
                opacity: 0;
              }

              to {
                -webkit-transform-origin: right bottom;
                transform-origin: right bottom;
                -webkit-transform: none;
                transform: none;
                opacity: 1;
              }
            }

            @-webkit-keyframes rotateOut {
              from {
                -webkit-transform-origin: center;
                transform-origin: center;
                opacity: 1;
              }

              to {
                -webkit-transform-origin: center;
                transform-origin: center;
                -webkit-transform: rotate3d(0, 0, 1, 200deg);
                transform: rotate3d(0, 0, 1, 200deg);
                opacity: 0;
              }
            }

            @keyframes rotateOut {
              from {
                -webkit-transform-origin: center;
                transform-origin: center;
                opacity: 1;
              }

              to {
                -webkit-transform-origin: center;
                transform-origin: center;
                -webkit-transform: rotate3d(0, 0, 1, 200deg);
                transform: rotate3d(0, 0, 1, 200deg);
                opacity: 0;
              }
            }

            @-webkit-keyframes rotateOutDownLeft {
              from {
                -webkit-transform-origin: left bottom;
                transform-origin: left bottom;
                opacity: 1;
              }

              to {
                -webkit-transform-origin: left bottom;
                transform-origin: left bottom;
                -webkit-transform: rotate3d(0, 0, 1, 45deg);
                transform: rotate3d(0, 0, 1, 45deg);
                opacity: 0;
              }
            }

            @keyframes rotateOutDownLeft {
              from {
                -webkit-transform-origin: left bottom;
                transform-origin: left bottom;
                opacity: 1;
              }

              to {
                -webkit-transform-origin: left bottom;
                transform-origin: left bottom;
                -webkit-transform: rotate3d(0, 0, 1, 45deg);
                transform: rotate3d(0, 0, 1, 45deg);
                opacity: 0;
              }
            }

            @-webkit-keyframes rotateOutDownRight {
              from {
                -webkit-transform-origin: right bottom;
                transform-origin: right bottom;
                opacity: 1;
              }

              to {
                -webkit-transform-origin: right bottom;
                transform-origin: right bottom;
                -webkit-transform: rotate3d(0, 0, 1, -45deg);
                transform: rotate3d(0, 0, 1, -45deg);
                opacity: 0;
              }
            }

            @keyframes rotateOutDownRight {
              from {
                -webkit-transform-origin: right bottom;
                transform-origin: right bottom;
                opacity: 1;
              }

              to {
                -webkit-transform-origin: right bottom;
                transform-origin: right bottom;
                -webkit-transform: rotate3d(0, 0, 1, -45deg);
                transform: rotate3d(0, 0, 1, -45deg);
                opacity: 0;
              }
            }

            @-webkit-keyframes rotateOutUpLeft {
              from {
                -webkit-transform-origin: left bottom;
                transform-origin: left bottom;
                opacity: 1;
              }

              to {
                -webkit-transform-origin: left bottom;
                transform-origin: left bottom;
                -webkit-transform: rotate3d(0, 0, 1, -45deg);
                transform: rotate3d(0, 0, 1, -45deg);
                opacity: 0;
              }
            }

            @keyframes rotateOutUpLeft {
              from {
                -webkit-transform-origin: left bottom;
                transform-origin: left bottom;
                opacity: 1;
              }

              to {
                -webkit-transform-origin: left bottom;
                transform-origin: left bottom;
                -webkit-transform: rotate3d(0, 0, 1, -45deg);
                transform: rotate3d(0, 0, 1, -45deg);
                opacity: 0;
              }
            }

            @-webkit-keyframes rotateOutUpRight {
              from {
                -webkit-transform-origin: right bottom;
                transform-origin: right bottom;
                opacity: 1;
              }

              to {
                -webkit-transform-origin: right bottom;
                transform-origin: right bottom;
                -webkit-transform: rotate3d(0, 0, 1, 90deg);
                transform: rotate3d(0, 0, 1, 90deg);
                opacity: 0;
              }
            }

            @keyframes rotateOutUpRight {
              from {
                -webkit-transform-origin: right bottom;
                transform-origin: right bottom;
                opacity: 1;
              }

              to {
                -webkit-transform-origin: right bottom;
                transform-origin: right bottom;
                -webkit-transform: rotate3d(0, 0, 1, 90deg);
                transform: rotate3d(0, 0, 1, 90deg);
                opacity: 0;
              }
            }

            @-webkit-keyframes hinge {
              0% {
                -webkit-transform-origin: top left;
                transform-origin: top left;
                -webkit-animation-timing-function: ease-in-out;
                animation-timing-function: ease-in-out;
              }

              20%, 60% {
                -webkit-transform: rotate3d(0, 0, 1, 80deg);
                transform: rotate3d(0, 0, 1, 80deg);
                -webkit-transform-origin: top left;
                transform-origin: top left;
                -webkit-animation-timing-function: ease-in-out;
                animation-timing-function: ease-in-out;
              }

              40%, 80% {
                -webkit-transform: rotate3d(0, 0, 1, 60deg);
                transform: rotate3d(0, 0, 1, 60deg);
                -webkit-transform-origin: top left;
                transform-origin: top left;
                -webkit-animation-timing-function: ease-in-out;
                animation-timing-function: ease-in-out;
                opacity: 1;
              }

              to {
                -webkit-transform: translate3d(0, 700px, 0);
                transform: translate3d(0, 700px, 0);
                opacity: 0;
              }
            }

            @keyframes hinge {
              0% {
                -webkit-transform-origin: top left;
                transform-origin: top left;
                -webkit-animation-timing-function: ease-in-out;
                animation-timing-function: ease-in-out;
              }

              20%, 60% {
                -webkit-transform: rotate3d(0, 0, 1, 80deg);
                transform: rotate3d(0, 0, 1, 80deg);
                -webkit-transform-origin: top left;
                transform-origin: top left;
                -webkit-animation-timing-function: ease-in-out;
                animation-timing-function: ease-in-out;
              }

              40%, 80% {
                -webkit-transform: rotate3d(0, 0, 1, 60deg);
                transform: rotate3d(0, 0, 1, 60deg);
                -webkit-transform-origin: top left;
                transform-origin: top left;
                -webkit-animation-timing-function: ease-in-out;
                animation-timing-function: ease-in-out;
                opacity: 1;
              }

              to {
                -webkit-transform: translate3d(0, 700px, 0);
                transform: translate3d(0, 700px, 0);
                opacity: 0;
              }
            }

            /* originally authored by Nick Pettit - https://github.com/nickpettit/glide */

            @-webkit-keyframes rollIn {
              from {
                opacity: 0;
                -webkit-transform: translate3d(-100%, 0, 0) rotate3d(0, 0, 1, -120deg);
                transform: translate3d(-100%, 0, 0) rotate3d(0, 0, 1, -120deg);
              }

              to {
                opacity: 1;
                -webkit-transform: none;
                transform: none;
              }
            }

            @keyframes rollIn {
              from {
                opacity: 0;
                -webkit-transform: translate3d(-100%, 0, 0) rotate3d(0, 0, 1, -120deg);
                transform: translate3d(-100%, 0, 0) rotate3d(0, 0, 1, -120deg);
              }

              to {
                opacity: 1;
                -webkit-transform: none;
                transform: none;
              }
            }

            /* originally authored by Nick Pettit - https://github.com/nickpettit/glide */

            @-webkit-keyframes rollOut {
              from {
                opacity: 1;
              }

              to {
                opacity: 0;
                -webkit-transform: translate3d(100%, 0, 0) rotate3d(0, 0, 1, 120deg);
                transform: translate3d(100%, 0, 0) rotate3d(0, 0, 1, 120deg);
              }
            }

            @keyframes rollOut {
              from {
                opacity: 1;
              }

              to {
                opacity: 0;
                -webkit-transform: translate3d(100%, 0, 0) rotate3d(0, 0, 1, 120deg);
                transform: translate3d(100%, 0, 0) rotate3d(0, 0, 1, 120deg);
              }
            }

            @-webkit-keyframes zoomIn {
              from {
                opacity: 0;
                -webkit-transform: scale3d(.3, .3, .3);
                transform: scale3d(.3, .3, .3);
              }

              50% {
                opacity: 1;
              }
            }

            @keyframes zoomIn {
              from {
                opacity: 0;
                -webkit-transform: scale3d(.3, .3, .3);
                transform: scale3d(.3, .3, .3);
              }

              50% {
                opacity: 1;
              }
            }

            @-webkit-keyframes zoomInDown {
              from {
                opacity: 0;
                -webkit-transform: scale3d(.1, .1, .1) translate3d(0, -1000px, 0);
                transform: scale3d(.1, .1, .1) translate3d(0, -1000px, 0);
                -webkit-animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
                animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
              }

              60% {
                opacity: 1;
                -webkit-transform: scale3d(.475, .475, .475) translate3d(0, 60px, 0);
                transform: scale3d(.475, .475, .475) translate3d(0, 60px, 0);
                -webkit-animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
                animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
              }
            }

            @keyframes zoomInDown {
              from {
                opacity: 0;
                -webkit-transform: scale3d(.1, .1, .1) translate3d(0, -1000px, 0);
                transform: scale3d(.1, .1, .1) translate3d(0, -1000px, 0);
                -webkit-animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
                animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
              }

              60% {
                opacity: 1;
                -webkit-transform: scale3d(.475, .475, .475) translate3d(0, 60px, 0);
                transform: scale3d(.475, .475, .475) translate3d(0, 60px, 0);
                -webkit-animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
                animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
              }
            }

            @-webkit-keyframes zoomInLeft {
              from {
                opacity: 0;
                -webkit-transform: scale3d(.1, .1, .1) translate3d(-1000px, 0, 0);
                transform: scale3d(.1, .1, .1) translate3d(-1000px, 0, 0);
                -webkit-animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
                animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
              }

              60% {
                opacity: 1;
                -webkit-transform: scale3d(.475, .475, .475) translate3d(10px, 0, 0);
                transform: scale3d(.475, .475, .475) translate3d(10px, 0, 0);
                -webkit-animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
                animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
              }
            }

            @keyframes zoomInLeft {
              from {
                opacity: 0;
                -webkit-transform: scale3d(.1, .1, .1) translate3d(-1000px, 0, 0);
                transform: scale3d(.1, .1, .1) translate3d(-1000px, 0, 0);
                -webkit-animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
                animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
              }

              60% {
                opacity: 1;
                -webkit-transform: scale3d(.475, .475, .475) translate3d(10px, 0, 0);
                transform: scale3d(.475, .475, .475) translate3d(10px, 0, 0);
                -webkit-animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
                animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
              }
            }

            @-webkit-keyframes zoomInRight {
              from {
                opacity: 0;
                -webkit-transform: scale3d(.1, .1, .1) translate3d(1000px, 0, 0);
                transform: scale3d(.1, .1, .1) translate3d(1000px, 0, 0);
                -webkit-animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
                animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
              }

              60% {
                opacity: 1;
                -webkit-transform: scale3d(.475, .475, .475) translate3d(-10px, 0, 0);
                transform: scale3d(.475, .475, .475) translate3d(-10px, 0, 0);
                -webkit-animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
                animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
              }
            }

            @keyframes zoomInRight {
              from {
                opacity: 0;
                -webkit-transform: scale3d(.1, .1, .1) translate3d(1000px, 0, 0);
                transform: scale3d(.1, .1, .1) translate3d(1000px, 0, 0);
                -webkit-animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
                animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
              }

              60% {
                opacity: 1;
                -webkit-transform: scale3d(.475, .475, .475) translate3d(-10px, 0, 0);
                transform: scale3d(.475, .475, .475) translate3d(-10px, 0, 0);
                -webkit-animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
                animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
              }
            }

            @-webkit-keyframes zoomInUp {
              from {
                opacity: 0;
                -webkit-transform: scale3d(.1, .1, .1) translate3d(0, 1000px, 0);
                transform: scale3d(.1, .1, .1) translate3d(0, 1000px, 0);
                -webkit-animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
                animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
              }

              60% {
                opacity: 1;
                -webkit-transform: scale3d(.475, .475, .475) translate3d(0, -60px, 0);
                transform: scale3d(.475, .475, .475) translate3d(0, -60px, 0);
                -webkit-animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
                animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
              }
            }

            @keyframes zoomInUp {
              from {
                opacity: 0;
                -webkit-transform: scale3d(.1, .1, .1) translate3d(0, 1000px, 0);
                transform: scale3d(.1, .1, .1) translate3d(0, 1000px, 0);
                -webkit-animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
                animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
              }

              60% {
                opacity: 1;
                -webkit-transform: scale3d(.475, .475, .475) translate3d(0, -60px, 0);
                transform: scale3d(.475, .475, .475) translate3d(0, -60px, 0);
                -webkit-animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
                animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
              }
            }

            @-webkit-keyframes zoomOut {
              from {
                opacity: 1;
              }

              50% {
                opacity: 0;
                -webkit-transform: scale3d(.3, .3, .3);
                transform: scale3d(.3, .3, .3);
              }

              to {
                opacity: 0;
              }
            }

            @keyframes zoomOut {
              from {
                opacity: 1;
              }

              50% {
                opacity: 0;
                -webkit-transform: scale3d(.3, .3, .3);
                transform: scale3d(.3, .3, .3);
              }

              to {
                opacity: 0;
              }
            }

            @-webkit-keyframes zoomOutDown {
              40% {
                opacity: 1;
                -webkit-transform: scale3d(.475, .475, .475) translate3d(0, -60px, 0);
                transform: scale3d(.475, .475, .475) translate3d(0, -60px, 0);
                -webkit-animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
                animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
              }

              to {
                opacity: 0;
                -webkit-transform: scale3d(.1, .1, .1) translate3d(0, 2000px, 0);
                transform: scale3d(.1, .1, .1) translate3d(0, 2000px, 0);
                -webkit-transform-origin: center bottom;
                transform-origin: center bottom;
                -webkit-animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
                animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
              }
            }

            @keyframes zoomOutDown {
              40% {
                opacity: 1;
                -webkit-transform: scale3d(.475, .475, .475) translate3d(0, -60px, 0);
                transform: scale3d(.475, .475, .475) translate3d(0, -60px, 0);
                -webkit-animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
                animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
              }

              to {
                opacity: 0;
                -webkit-transform: scale3d(.1, .1, .1) translate3d(0, 2000px, 0);
                transform: scale3d(.1, .1, .1) translate3d(0, 2000px, 0);
                -webkit-transform-origin: center bottom;
                transform-origin: center bottom;
                -webkit-animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
                animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
              }
            }

            @-webkit-keyframes zoomOutLeft {
              40% {
                opacity: 1;
                -webkit-transform: scale3d(.475, .475, .475) translate3d(42px, 0, 0);
                transform: scale3d(.475, .475, .475) translate3d(42px, 0, 0);
              }

              to {
                opacity: 0;
                -webkit-transform: scale(.1) translate3d(-2000px, 0, 0);
                transform: scale(.1) translate3d(-2000px, 0, 0);
                -webkit-transform-origin: left center;
                transform-origin: left center;
              }
            }

            @keyframes zoomOutLeft {
              40% {
                opacity: 1;
                -webkit-transform: scale3d(.475, .475, .475) translate3d(42px, 0, 0);
                transform: scale3d(.475, .475, .475) translate3d(42px, 0, 0);
              }

              to {
                opacity: 0;
                -webkit-transform: scale(.1) translate3d(-2000px, 0, 0);
                transform: scale(.1) translate3d(-2000px, 0, 0);
                -webkit-transform-origin: left center;
                transform-origin: left center;
              }
            }

            @-webkit-keyframes zoomOutRight {
              40% {
                opacity: 1;
                -webkit-transform: scale3d(.475, .475, .475) translate3d(-42px, 0, 0);
                transform: scale3d(.475, .475, .475) translate3d(-42px, 0, 0);
              }

              to {
                opacity: 0;
                -webkit-transform: scale(.1) translate3d(2000px, 0, 0);
                transform: scale(.1) translate3d(2000px, 0, 0);
                -webkit-transform-origin: right center;
                transform-origin: right center;
              }
            }

            @keyframes zoomOutRight {
              40% {
                opacity: 1;
                -webkit-transform: scale3d(.475, .475, .475) translate3d(-42px, 0, 0);
                transform: scale3d(.475, .475, .475) translate3d(-42px, 0, 0);
              }

              to {
                opacity: 0;
                -webkit-transform: scale(.1) translate3d(2000px, 0, 0);
                transform: scale(.1) translate3d(2000px, 0, 0);
                -webkit-transform-origin: right center;
                transform-origin: right center;
              }
            }

            @-webkit-keyframes zoomOutUp {
              40% {
                opacity: 1;
                -webkit-transform: scale3d(.475, .475, .475) translate3d(0, 60px, 0);
                transform: scale3d(.475, .475, .475) translate3d(0, 60px, 0);
                -webkit-animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
                animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
              }

              to {
                opacity: 0;
                -webkit-transform: scale3d(.1, .1, .1) translate3d(0, -2000px, 0);
                transform: scale3d(.1, .1, .1) translate3d(0, -2000px, 0);
                -webkit-transform-origin: center bottom;
                transform-origin: center bottom;
                -webkit-animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
                animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
              }
            }

            @keyframes zoomOutUp {
              40% {
                opacity: 1;
                -webkit-transform: scale3d(.475, .475, .475) translate3d(0, 60px, 0);
                transform: scale3d(.475, .475, .475) translate3d(0, 60px, 0);
                -webkit-animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
                animation-timing-function: cubic-bezier(0.550, 0.055, 0.675, 0.190);
              }

              to {
                opacity: 0;
                -webkit-transform: scale3d(.1, .1, .1) translate3d(0, -2000px, 0);
                transform: scale3d(.1, .1, .1) translate3d(0, -2000px, 0);
                -webkit-transform-origin: center bottom;
                transform-origin: center bottom;
                -webkit-animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
                animation-timing-function: cubic-bezier(0.175, 0.885, 0.320, 1);
              }
            }

            @-webkit-keyframes slideInDown {
              from {
                -webkit-transform: translate3d(0, -100%, 0);
                transform: translate3d(0, -100%, 0);
                visibility: visible;
              }

              to {
                -webkit-transform: translate3d(0, 0, 0);
                transform: translate3d(0, 0, 0);
              }
            }

            @keyframes slideInDown {
              from {
                -webkit-transform: translate3d(0, -100%, 0);
                transform: translate3d(0, -100%, 0);
                visibility: visible;
              }

              to {
                -webkit-transform: translate3d(0, 0, 0);
                transform: translate3d(0, 0, 0);
              }
            }

            @-webkit-keyframes slideInLeft {
              from {
                -webkit-transform: translate3d(-100%, 0, 0);
                transform: translate3d(-100%, 0, 0);
                visibility: visible;
              }

              to {
                -webkit-transform: translate3d(0, 0, 0);
                transform: translate3d(0, 0, 0);
              }
            }

            @keyframes slideInLeft {
              from {
                -webkit-transform: translate3d(-100%, 0, 0);
                transform: translate3d(-100%, 0, 0);
                visibility: visible;
              }

              to {
                -webkit-transform: translate3d(0, 0, 0);
                transform: translate3d(0, 0, 0);
              }
            }

            @-webkit-keyframes slideInRight {
              from {
                -webkit-transform: translate3d(100%, 0, 0);
                transform: translate3d(100%, 0, 0);
                visibility: visible;
              }

              to {
                -webkit-transform: translate3d(0, 0, 0);
                transform: translate3d(0, 0, 0);
              }
            }

            @keyframes slideInRight {
              from {
                -webkit-transform: translate3d(100%, 0, 0);
                transform: translate3d(100%, 0, 0);
                visibility: visible;
              }

              to {
                -webkit-transform: translate3d(0, 0, 0);
                transform: translate3d(0, 0, 0);
              }
            }

            @-webkit-keyframes slideInUp {
              from {
                -webkit-transform: translate3d(0, 100%, 0);
                transform: translate3d(0, 100%, 0);
                visibility: visible;
              }

              to {
                -webkit-transform: translate3d(0, 0, 0);
                transform: translate3d(0, 0, 0);
              }
            }

            @keyframes slideInUp {
              from {
                -webkit-transform: translate3d(0, 100%, 0);
                transform: translate3d(0, 100%, 0);
                visibility: visible;
              }

              to {
                -webkit-transform: translate3d(0, 0, 0);
                transform: translate3d(0, 0, 0);
              }
            }

            @-webkit-keyframes slideOutDown {
              from {
                -webkit-transform: translate3d(0, 0, 0);
                transform: translate3d(0, 0, 0);
              }

              to {
                visibility: hidden;
                -webkit-transform: translate3d(0, 100%, 0);
                transform: translate3d(0, 100%, 0);
              }
            }

            @keyframes slideOutDown {
              from {
                -webkit-transform: translate3d(0, 0, 0);
                transform: translate3d(0, 0, 0);
              }

              to {
                visibility: hidden;
                -webkit-transform: translate3d(0, 100%, 0);
                transform: translate3d(0, 100%, 0);
              }
            }

            @-webkit-keyframes slideOutLeft {
              from {
                -webkit-transform: translate3d(0, 0, 0);
                transform: translate3d(0, 0, 0);
              }

              to {
                visibility: hidden;
                -webkit-transform: translate3d(-100%, 0, 0);
                transform: translate3d(-100%, 0, 0);
              }
            }

            @keyframes slideOutLeft {
              from {
                -webkit-transform: translate3d(0, 0, 0);
                transform: translate3d(0, 0, 0);
              }

              to {
                visibility: hidden;
                -webkit-transform: translate3d(-100%, 0, 0);
                transform: translate3d(-100%, 0, 0);
              }
            }

            @-webkit-keyframes slideOutRight {
              from {
                -webkit-transform: translate3d(0, 0, 0);
                transform: translate3d(0, 0, 0);
              }

              to {
                visibility: hidden;
                -webkit-transform: translate3d(100%, 0, 0);
                transform: translate3d(100%, 0, 0);
              }
            }

            @keyframes slideOutRight {
              from {
                -webkit-transform: translate3d(0, 0, 0);
                transform: translate3d(0, 0, 0);
              }

              to {
                visibility: hidden;
                -webkit-transform: translate3d(100%, 0, 0);
                transform: translate3d(100%, 0, 0);
              }
            }

            @-webkit-keyframes slideOutUp {
              from {
                -webkit-transform: translate3d(0, 0, 0);
                transform: translate3d(0, 0, 0);
              }

              to {
                visibility: hidden;
                -webkit-transform: translate3d(0, -100%, 0);
                transform: translate3d(0, -100%, 0);
              }
            }

            @keyframes slideOutUp {
              from {
                -webkit-transform: translate3d(0, 0, 0);
                transform: translate3d(0, 0, 0);
              }

              to {
                visibility: hidden;
                -webkit-transform: translate3d(0, -100%, 0);
                transform: translate3d(0, -100%, 0);
              }
            }
            
        </style>

    </template>
</dom-module><dom-module id="inkd-style" assetpath="inkd-elements/">

    </dom-module><dom-module id="inkd-box" assetpath="inkd-elements/">
    
    <template>    
        <style include="inkd-animation-styles"></style>
        
        <style>
            :host {
                position: relative;
                display: inline-block;
            }
            
            #defaultContent {
                display: block;
                z-index: 0;
            }
            
            #overlayContent, #slideContent {
                position: absolute;
                width: 100%;
                height: 100%;
                z-index: 1;
                pointer-events: none;
            }
            
            #slideContent {
                overflow: hidden;
            }
        </style>
        
        <span id="overlayContent"></span>
        <span id="slideContent"></span>
        
        <inkd-style id="defaultContent" effect="[[effect]]" animation="[[animation]]">
            <content></content>
        </inkd-style>
    </template>

    </dom-module>s<dom-module id="inkd-click" assetpath="inkd-elements/">
    
    <template></template>

    </dom-module>


<dom-module id="inkd-over" assetpath="inkd-elements/">
    
    <template></template>

    </dom-module>


<dom-module id="inkd-down" assetpath="inkd-elements/">

    <template></template>
    
    </dom-module><dom-module id="inkd-a" assetpath="inkd-elements/">

    <template>
        <style>
            :host {
                color: blue;
                text-decoration: underline;
                cursor: pointer;
            }
        </style>
        
        <content></content>
    </template>

    </dom-module><dom-module id="inkd-modal-styles" assetpath="inkd-styles/">
    <template>
        <style>
            .background-overlay {
                position: fixed;
                z-index: 300;
                left: 0;
                top: 0;
                width: 100%;
                height: 100%;
                overflow: auto;
                background-color: rgba(0,0,0,0.4);
                
                @apply --background-overlay;
            }
            
            :host[no-fullscreen] .background-overlay {
                position: absolute;
            }
            
            .content-wrapper {
                position: relative;
                background-color: #fefefe;
                z-index: 500;
                margin: 15% auto;
                padding: 20px;
                border: 1px solid #888;
                width: 80%;
                
                @apply --content-wrapper;
            }
            
            .content {
                overflow: scroll;
                
                @apply --content;
            }
            
            .close-button {
                position: absolute;
                top: 10px;
                right: 10px;
                display: inline-block;
                border: 1px solid black;
                border-radius: 5px;
                cursor: pointer;
                transition: all .2s linear;
                background-color: white;
                background-image: url("inkd-images/close.svg");
                background-repeat: no-repeat;
                background-position: center;
                background-size: 20px 20px;
                width: 20px;
                height: 20px;
                
                @apply --close-button;
            }
            
            .close-button:hover, .close-button:focus {
                background-color: #bbb;
                
                @apply --close-button-hover;
            }
            
            
            @import url("https://fonts.googleapis.com/css?family=Old+Standard+TT");@import url("https://fonts.googleapis.com/css?family=VT323");@import url("https://fonts.googleapis.com/css?family=Space+Mono");.layout-container{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center}.one-column-layout{display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;padding:1.2em;width:80%;height:auto}@media only screen and (max-width: 870px){.one-column-layout{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;height:auto;margin-top:5em;margin-bottom:2.5em}}@media only screen and (min-width: 1366px){.one-column-layout{height:80vh}}.one-column-layout > inkd-box:first-child{-ms-flex-preferred-size:100%;flex-basis:100%;padding:1em;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.one-column-layout > inkd-box:nth-child(2n){display:block;-ms-flex-preferred-size:100%;flex-basis:100%;margin:0 -1em;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}@media only screen and (max-width: 870px){.one-column-layout > inkd-box:nth-child(2n){-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-ms-flex-line-pack:justify;align-content:space-between}}.one-column-layout.fullscreen{width:100%;height:100vh}.one-column-layout p{margin-left:0.625em}@media only screen and (max-width: 870px){.one-column-layout p{padding:1em 0}}.one-column-layout inkd-button{width:30%;padding:1em 2em;margin:0 1em;cursor:pointer;font-size:1rem;text-align:center}@media only screen and (max-width: 870px){.one-column-layout inkd-button{width:60%;margin:1em 0}}.one-column-layout img{max-width:100%;height:auto}.two-column-layout{display:-webkit-box;display:-ms-flexbox;display:flex;width:80%;padding:1.2em;overflow:hidden}@media only screen and (max-width: 870px){.two-column-layout{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;margin-top:25em;margin-bottom:2.5em;height:auto}}@media only screen and (min-width: 1366px){.two-column-layout{height:80vh}}.two-column-layout.fullscreen{width:100%;height:100vh}.two-column-layout > inkd-box:first-child{-ms-flex-negative:0;flex-shrink:0;-webkit-box-flex:0;-ms-flex-positive:0;flex-grow:0;padding:1em;min-width:0;-ms-flex-preferred-size:50%;flex-basis:50%;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}@media only screen and (max-width: 870px){.two-column-layout > inkd-box:first-child{-ms-flex-preferred-size:100%;flex-basis:100%}}.two-column-layout > inkd-box:nth-child(2n){-ms-flex-negative:1;flex-shrink:1;-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}@media only screen and (max-width: 870px){.two-column-layout > inkd-box:nth-child(2n){-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-ms-flex-line-pack:justify;align-content:space-between}}.two-column-layout inkd-button{display:inline-block;width:60%;line-height:0;padding:1.2em 2em;margin:1em 0;cursor:pointer;font-size:1rem;text-align:center;zoom:1;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.two-column-layout p{font-size:1rem;padding-bottom:1em}@media only screen and (max-width: 870px){.two-column-layout p{padding:1em 0}}.two-column-layout img{max-width:100%;height:auto}.three-image-layout{width:100%;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-flow:row wrap;flex-flow:row wrap;-ms-flex-pack:distribute;justify-content:space-around;-webkit-box-align:center;-ms-flex-align:center;align-items:center}@media only screen and (max-width: 870px){.three-image-layout{width:100%;padding:0}}.three-image-layout figure{-webkit-box-flex:1;-ms-flex:auto;flex:auto;margin:.5vw;width:200px}@media only screen and (max-width: 870px){.three-image-layout figure{width:100%;margin:0}}.three-image-layout img{width:100%;height:auto}.old-theme{font-family:Old Standard TT,serif}.old-theme img{-webkit-filter:grayscale(100%);filter:grayscale(100%);border:0.625em solid #fff;border-bottom:2.8125em solid #fff;-webkit-box-shadow:0.1875em 0.1875em 0.1875em #777;box-shadow:0.1875em 0.1875em 0.1875em #777;-webkit-transform:rotate(-8deg) scale(0.98);transform:rotate(-8deg) scale(0.98);margin-left:1em;-webkit-transition:all .3s ease-in-out;transition:all .3s ease-in-out}@media only screen and (max-width: 870px){.old-theme img{margin-left:0}}.old-theme img:hover{-webkit-transform:rotate(-8deg) scale(1);transform:rotate(-8deg) scale(1)}.old-theme p{font-weight:800}.old-theme inkd-button{color:peru;background-color:#fff;-webkit-box-shadow:0.0625em 0.0625em 0.0625em #777;box-shadow:0.0625em 0.0625em 0.0625em #777;border-radius:0.31em;font-size:1em;font-weight:800;-webkit-transition:all .3s ease-in-out;transition:all .3s ease-in-out}.old-theme inkd-button:hover{background-color:peru;color:#fff}.old-theme .three-image-layout{margin-left:-2em}.terminal-theme{background-color:#000;border:0.625em solid #00ff40;font-family:VT323,serif;color:#00ff40;font-size:1em}.terminal-theme img{padding:1em;border:0.0625em solid #00ff40}.terminal-theme p{font-size:1.1rem}.terminal-theme inkd-button{background-color:#2C2C2C;color:#00ff40;border:0.0625em solid #00ff40;font-size:1em}.terminal-theme inkd-button:hover{background-color:#00ff40;color:#2C2C2C}.business-theme{background-color:#2C2C2C;color:#fff;border-top:1em solid #1abc9c;font-family:Space Mono,serif}.business-theme img{border:0.31em solid #1abc9c}.business-theme inkd-button{background-color:#bc9c1a;color:#2C2C2C}.business-theme inkd-button:hover{background-color:#836d12;color:#000}
        </style>
    </template>
</dom-module><dom-module id="inkd-modal" assetpath="inkd-elements/">
    
    <template>  
        <style include="inkd-modal-styles"></style>
        <style>
            *[hidden] {
                display: none;
            }
        </style>
        
        <template is="dom-if" if="[[_showModal]]" restamp="">
            <div id="overlay" class="background-overlay" on-tap="_handleOverlayTap" on-mousewheel="_cancelEvent">
                <div class="content-wrapper" style$="width: {{width}}; height: {{height}}; left: {{x}}; top: {{y}};" on-tap="_cancelEvent">
                    <div id="window" class="content">
                        <content></content>
                    </div>
                    <template is="dom-if" if="[[!noClose]]">
                        <button type="button" class="close-button" on-tap="hide" aria-label="Close modal"></button>
                    </template>
                </div>
            </div>
        </template>
    </template>

    </dom-module><dom-module id="inkd-textarea" assetpath="inkd-elements/">

    <template>
        <style>
            :host {
                resize: both;
                visibility: hidden;
            }
            textarea {
                all: inherit;
                visibility: visible;
            }
        </style>
        
        <textarea id="textareaElement" tabindex$="[[tabindex]]" on-input="_handleInput" on-change="_handleChange" on-focus="_handleFocus" on-blur="_handleBlur"></textarea>
    </template>

    </dom-module><style>

.dnd-poly-drag-image {
    opacity: .5 !important;
}

.dnd-poly-drag-image.dnd-poly-snapback {
    transition-property: transform, -webkit-transform !important;
    transition-duration: 250ms !important;
    transition-timing-function: ease-out !important;
}

</style>
<script type="text/javascript">/*! mobile-drag-drop 2.0.0 | Copyright (c) 2017 Tim Ruffles | MIT License */
!function(a,b){"object"==typeof exports&&"undefined"!=typeof module?b(exports):"function"==typeof define&&define.amd?define(["exports"],b):b(a.MobileDragDrop=a.MobileDragDrop||{})}(this,function(a){"use strict";function b(){var a={dragEvents:"ondragstart"in document.documentElement,draggable:"draggable"in document.documentElement,touchEvents:"ontouchstart"in document.documentElement,userAgentSupportingNativeDnD:void 0},b=!!window.chrome||/chrome/i.test(navigator.userAgent);return a.userAgentSupportingNativeDnD=!(/iPad|iPhone|iPod|Android/.test(navigator.userAgent)||b&&a.touchEvents),y&&Object.keys(a).forEach(function(a){}),a}function c(){var a=!1;try{var b=Object.defineProperty({},"passive",{get:function(){a=!0}});window.addEventListener("test",null,b)}catch(a){}return a}function d(a){if(a&&Object.keys(a).forEach(function(b){z[b]=a[b]}),!z.forceApply){var d=b();if(d.userAgentSupportingNativeDnD&&d.draggable&&d.dragEvents)return!1}return w=c(),h("touchstart",e,!1),!0}function e(a){if(!x){var b=f(a);if(b)try{x=new H(a,z,b,g)}catch(b){throw g(z,a,3),b}}}function f(a){var b=a.target;do if(b.draggable!==!1&&b.getAttribute&&"true"===b.getAttribute("draggable"))return b;while((b=b.parentNode)&&b!==document.body)}function g(a,b,c){if(0===c&&a.defaultActionOverride)try{a.defaultActionOverride(b),b.defaultPrevented}catch(a){}x=null}function h(a,b,c){void 0===c&&(c=!0),document.addEventListener(a,b,!!w&&{passive:c})}function i(a,b){document.removeEventListener(a,b)}function j(a){return 0===a.length?0:a.reduce(function(a,b){return b+a},0)/a.length}function k(a){return a&&a.tagName}function l(a,b){for(var c=0;c<a.changedTouches.length;c++){var d=a.changedTouches[c];if(d.identifier===b)return!0}return!1}function m(a,b,c,d,e,f,g){void 0===g&&(g=null);var h=b.changedTouches[0],i=new Event(c,{bubbles:!0,cancelable:d});i.dataTransfer=f,i.relatedTarget=g,i.screenX=h.screenX,i.screenY=h.screenY,i.clientX=h.clientX,i.clientY=h.clientY,i.pageX=h.pageX,i.pageY=h.pageY;var j=a.getBoundingClientRect();return i.offsetX=i.clientX-j.left,i.offsetY=i.clientY-j.top,i}function n(a,b,c){for(var d=[],e=[],f=0;f<b.touches.length;f++){var g=b.touches[f];d.push(g[a+"X"]),e.push(g[a+"Y"])}c.x=j(d),c.y=j(e)}function o(a,b){if(1===a.nodeType){for(var c=getComputedStyle(a),d=0;d<c.length;d++){var e=c[d];b.style.setProperty(e,c.getPropertyValue(e),c.getPropertyPriority(e))}b.style.pointerEvents="none",b.removeAttribute("id"),b.removeAttribute("class"),b.removeAttribute("draggable")}if(a.hasChildNodes())for(var d=0;d<a.childNodes.length;d++)o(a.childNodes[d],b.childNodes[d])}function p(a){var b=a.cloneNode(!0);return o(a,b),b.style.position="absolute",b.style.left="0px",b.style.top="0px",b.style.zIndex="999999",b.classList.add(E),b.classList.add(G),b}function q(a){return C.map(function(b){var c=a.style[b+"transform"];return c&&"none"!==c?c.replace(/translate\(\D*\d+[^,]*,\D*\d+[^,]*\)\s*/g,""):""})}function r(a,b,c,d,e){void 0===e&&(e=!0);var f=b.x,g=b.y;d&&(f+=d.x,g+=d.y),e&&(f-=parseInt(a.offsetWidth,10)/2,g-=parseInt(a.offsetHeight,10)/2);for(var h="translate3d("+f+"px,"+g+"px, 0)",i=0;i<C.length;i++){var j=C[i]+"transform";a.style[j]=h+" "+c[i]}}function s(a,b,c,d){var e=getComputedStyle(a);if("hidden"===e.visibility||"none"===e.display)return void d();b.classList.add(F);var f=getComputedStyle(b),g=parseFloat(f.transitionDuration);if(isNaN(g)||0===g)return void d();var h=a.getBoundingClientRect(),i={x:h.left,y:h.top};i.x+=document.body.scrollLeft||document.documentElement.scrollLeft,i.y+=document.body.scrollTop||document.documentElement.scrollTop,i.x-=parseInt(e.marginLeft,10),i.y-=parseInt(e.marginTop,10);var j=parseFloat(f.transitionDelay),k=Math.round(1e3*(g+j));r(b,i,c,void 0,!1),setTimeout(d,k)}function t(a,b){return a?a===A[0]?B[0]:0===a.indexOf(A[1])||a===A[7]?B[1]:0===a.indexOf(A[4])?B[3]:a===A[6]?B[2]:B[1]:3===b.nodeType&&"A"===b.tagName?B[3]:B[1]}function u(a,b,c,d,e,f,g){if(void 0===f&&(f=!0),void 0===g&&(g=null),y){var h=D+"debug",i=D+"event-target",j=D+"event-related-target";b.classList.add(h),b.classList.add(i),g&&(g.classList.add(h),g.classList.add(j))}var k=m(b,c,a,f,document.defaultView,e,g),l=!b.dispatchEvent(k);return d.g=0,y&&(b.classList.remove(i),g&&g.classList.remove(j)),l}function v(a,b){if(!a||a===A[7])return b;if(b===B[1]){if(0===a.indexOf(B[1]))return B[1]}else if(b===B[3]){if(0===a.indexOf(B[3])||a.indexOf("Link")>-1)return B[3]}else if(b===B[2]&&(0===a.indexOf(B[2])||a.indexOf("Move")>-1))return B[2];return B[0]}var w,x,y=!1,z={iterationInterval:150},A=["none","copy","copyLink","copyMove","link","linkMove","move","all"],B=["none","copy","move","link"],C=["","-webkit-"],D="dnd-poly-",E=D+"drag-image",F=D+"snapback",G=D+"icon",H=function(){function a(a,b,c,d){this.h=a,this.i=b,this.j=c,this.k=d,this.l=0,this.m=null,this.o=null,this.p=a,this.q=a.changedTouches[0],this.s=this.t.bind(this),this.u=this.v.bind(this),h("touchmove",this.s,!1),h("touchend",this.u,!1),h("touchcancel",this.u,!1)}return a.prototype.A=function(){var a=this;this.l=1,this.B=B[0],this.C={D:{},F:void 0,g:3,G:[]},this.H={x:null,y:null},this.I={x:null,y:null};var b=this.j;if(this.J=new I(this.C,function(c,d,e){b=c,"number"!=typeof d&&"number"!=typeof e||(a.K={x:d||0,y:e||0})}),this.C.g=2,this.J.dropEffect=B[0],u("dragstart",this.j,this.p,this.C,this.J))return this.l=3,this.L(),!1;if(n("page",this.p,this.I),this.M=p(b),this.N=q(this.M),!this.K)if(this.i.dragImageOffset)this.K={x:this.i.dragImageOffset.x,y:this.i.dragImageOffset.y};else if(this.i.dragImageCenterOnTouch){var c=getComputedStyle(b);this.K={x:0-parseInt(c.marginLeft,10),y:0-parseInt(c.marginTop,10)}}else{var d=b.getBoundingClientRect(),c=getComputedStyle(b);this.K={x:d.left-this.q.clientX-parseInt(c.marginLeft,10)+d.width/2,y:d.top-this.q.clientY-parseInt(c.marginTop,10)+d.height/2}}return r(this.M,this.I,this.N,this.K,this.i.dragImageCenterOnTouch),document.body.appendChild(this.M),this.O=setInterval(function(){a.P||(a.P=!0,a.R(),a.P=!1)},this.i.iterationInterval),!0},a.prototype.L=function(){this.O&&(clearInterval(this.O),this.O=null),i("touchmove",this.s),i("touchend",this.u),i("touchcancel",this.u),this.M&&(this.M.parentNode.removeChild(this.M),this.M=null),this.k(this.i,this.p,this.l)},a.prototype.t=function(a){var b=this;if(l(a,this.q.identifier)!==!1){if(this.p=a,0===this.l){var c=void 0;if(this.i.dragStartConditionOverride)try{c=this.i.dragStartConditionOverride(a)}catch(a){c=!1}else c=1===a.touches.length;return c?void(this.A()===!0&&(this.h.preventDefault(),a.preventDefault())):void this.L()}if(a.preventDefault(),n("client",a,this.H),n("page",a,this.I),this.i.dragImageTranslateOverride)try{var d=!1;if(this.i.dragImageTranslateOverride(a,{x:this.H.x,y:this.H.y},this.m,function(a,c){b.M&&(d=!0,b.H.x+=a,b.H.y+=c,b.I.x+=a,b.I.y+=c,r(b.M,b.I,b.N,b.K,b.i.dragImageCenterOnTouch))}),d)return}catch(a){}r(this.M,this.I,this.N,this.K,this.i.dragImageCenterOnTouch)}},a.prototype.v=function(a){if(l(a,this.q.identifier)!==!1){if(this.i.dragImageTranslateOverride)try{this.i.dragImageTranslateOverride(void 0,void 0,void 0,function(){})}catch(a){}if(0===this.l)return void this.L();a.preventDefault(),this.l="touchcancel"===a.type?3:2}},a.prototype.R=function(){var a=this;if(y)var b=D+"debug",c=D+"immediate-user-selection",d=D+"current-drop-target";var e=this.B;this.C.g=3,this.J.dropEffect=B[0];var f=u("drag",this.j,this.p,this.C,this.J);if(f&&(this.B=B[0]),f||2===this.l||3===this.l){var g=this.S(this.l);return g?void s(this.j,this.M,this.N,function(){a.T()}):void this.T()}var h=document.elementFromPoint(this.H.x,this.H.y),i=this.o;h!==this.m&&h!==this.o&&(y&&(this.m&&this.m.classList.remove(c),h&&(h.classList.add(b),h.classList.add(c))),this.m=h,null!==this.o&&(this.C.g=3,this.J.dropEffect=B[0],u("dragexit",this.o,this.p,this.C,this.J,!1)),null===this.m?this.o=this.m:(this.C.g=3,this.J.dropEffect=t(this.C.F,this.j),u("dragenter",this.m,this.p,this.C,this.J)?(this.o=this.m,this.B=v(this.J.effectAllowed,this.J.dropEffect)):this.m!==document.body&&(this.o=document.body))),i!==this.o&&k(i)&&(y&&i.classList.remove(d),this.C.g=3,this.J.dropEffect=B[0],u("dragleave",i,this.p,this.C,this.J,!1,this.o)),k(this.o)&&(y&&(this.o.classList.add(b),this.o.classList.add(d)),this.C.g=3,this.J.dropEffect=t(this.C.F,this.j),u("dragover",this.o,this.p,this.C,this.J)===!1?this.B=B[0]:this.B=v(this.J.effectAllowed,this.J.dropEffect)),e!==this.B&&this.M.classList.remove(D+e);var j=D+this.B;this.M.classList.contains(j)===!1&&this.M.classList.add(j)},a.prototype.S=function(a){if(y){var b=D+"immediate-user-selection",c=D+"current-drop-target";this.o&&this.o.classList.remove(c),this.m&&this.m.classList.remove(b)}var d=this.B===B[0]||null===this.o||3===a;return d?k(this.o)&&(this.C.g=3,this.J.dropEffect=B[0],u("dragleave",this.o,this.p,this.C,this.J,!1)):k(this.o)&&(this.C.g=1,this.J.dropEffect=this.B,u("drop",this.o,this.p,this.C,this.J)===!0?this.B=this.J.dropEffect:this.B=B[0]),d},a.prototype.T=function(){this.C.g=3,this.J.dropEffect=this.B,u("dragend",this.j,this.p,this.C,this.J,!1),this.l=2,this.L()},a}(),I=function(){function a(a,b){this.U=a,this.V=b,this.W=B[0]}return Object.defineProperty(a.prototype,"types",{get:function(){if(0!==this.U.g)return Object.freeze(this.U.G)},enumerable:!0,configurable:!0}),a.prototype.setData=function(a,b){if(2===this.U.g){if(a.indexOf(" ")>-1)throw new Error("illegal arg: type contains space");this.U.D[a]=b,this.U.G.indexOf(a)===-1&&this.U.G.push(a)}},a.prototype.getData=function(a){if(1===this.U.g||2===this.U.g)return this.U.D[a]||""},a.prototype.clearData=function(a){if(2===this.U.g){if(a&&this.U.D[a]){delete this.U.D[a];var b=this.U.G.indexOf(a);return void(b>-1&&this.U.G.splice(b,1))}this.U.D={},this.U.G=[]}},a.prototype.setDragImage=function(a,b,c){2===this.U.g&&this.V(a,b,c)},Object.defineProperty(a.prototype,"effectAllowed",{get:function(){return this.U.F},set:function(a){2===this.U.g&&A.indexOf(a)>-1&&(this.U.F=a)},enumerable:!0,configurable:!0}),Object.defineProperty(a.prototype,"dropEffect",{get:function(){return this.W},set:function(a){0!==this.U.g&&A.indexOf(a)>-1&&(this.W=a)},enumerable:!0,configurable:!0}),a}();a.polyfill=d,Object.defineProperty(a,"__esModule",{value:!0})});
//# sourceMappingURL=index.min.js.map</script>
<script type="text/javascript">!function(a,b){"object"==typeof exports&&"undefined"!=typeof module?b(exports):"function"==typeof define&&define.amd?define(["exports"],b):b(a.MobileDragDrop=a.MobileDragDrop||{})}(this,function(a){"use strict";function b(a){return a===document.body||a===document.documentElement}function c(a,c){var d;if(b(a))d=0===c?a.clientLeft:a.clientTop;else{var e=a.getBoundingClientRect();d=0===c?e.left:e.top}return d}function d(a,c){var d;return d=b(a)?0===c?window.innerWidth:window.innerHeight:0===c?a.clientWidth:a.clientHeight}function e(a,c,d){var e=0===c?"scrollLeft":"scrollTop",f=b(a);return 2===arguments.length?f?document.body[e]||document.documentElement[e]:a[e]:void(f?(document.documentElement[e]+=d,document.body[e]+=d):a[e]+=d)}function f(a){var b=getComputedStyle(a);return a.scrollHeight>a.clientHeight&&("scroll"===b.overflowY||"auto"===b.overflowY)||a.scrollWidth>a.clientWidth&&("scroll"===b.overflowX||"auto"===b.overflowX)}function g(a){do{if(!a)return;if(f(a))return a;if(a===document.documentElement)return null}while(a=a.parentNode);return null}function h(a,b,c){return a<c?-1:b-a<c?1:0}function i(a,b,c,d){return a===-1?Math.abs(b-d):1===a?Math.abs(c-b-d):0}function j(a,b,c){var d=0===a?c.scrollX:c.scrollY;if(1===b){var e=0===a?c.scrollWidth-c.width:c.scrollHeight-c.height;return d>=e}return b!==-1||d<=0}function k(a,b,c,d){p=b,s=d,q!==c&&(q=c,r=g(q));var e=n(p,r,t.threshold,u,v);e?l():o&&(window.cancelAnimationFrame(o),o=null)}function l(){o||(o=window.requestAnimationFrame(m))}function m(){var a=0,c=0,d=b(r);0!==u.horizontal&&(a=Math.round(t.velocityFn(v.x,t.threshold)*u.horizontal),e(r,0,a)),0!==u.vertical&&(c=Math.round(t.velocityFn(v.y,t.threshold)*u.vertical),e(r,1,c)),d?s(a,c):s(0,0),o=null,n(p,r,t.threshold,u,v)&&l()}function n(a,b,f,g,k){if(!a||!b)return!1;var l={x:c(b,0),y:c(b,1),width:d(b,0),height:d(b,1),scrollX:e(b,0),scrollY:e(b,1),scrollWidth:b.scrollWidth,scrollHeight:b.scrollHeight},m={x:a.x-l.x,y:a.y-l.y};return g.horizontal=h(m.x,l.width,f),g.vertical=h(m.y,l.height,f),g.horizontal&&j(0,g.horizontal,l)?g.horizontal=0:g.horizontal&&(k.x=i(g.horizontal,m.x,l.width,f)),g.vertical&&j(1,g.vertical,l)?g.vertical=0:g.vertical&&(k.y=i(g.vertical,m.y,l.height,f)),!(!g.horizontal&&!g.vertical)}var o,p,q,r,s,t={threshold:75,velocityFn:function(a,b){var c=a/b,d=c*c*c;return d*b}},u={horizontal:0,vertical:0},v={x:0,y:0},w=k;a.scrollBehaviourDragImageTranslateOverride=w,Object.defineProperty(a,"__esModule",{value:!0})});
//# sourceMappingURL=scroll-behaviour.min.js.map</script>

<dom-module id="inkd-dd-styles" assetpath="inkd-styles/">
    <template>
        <style>
            *[hidden] {
                display: none;
            }
            
            .wrapper {
                display: flex;
                align-items: stretch;
                
                @apply --wrapper;
            }
            
            .drag-section {
                flex: 1;
                
                @apply --drag-section;
            }
            
            .drop-section {
                flex: 1;
                
                @apply --drop-section;
            }
            
            .menu-wrapper {
                margin: 5px auto 10px;
                display: flex;
                flex-direction: row;
                flex-wrap: nowrap;
                list-style: none;
                justify-content: space-between;
                
                @apply --menu-wrapper;
            }
            
            .menu-button {
                flex: 1;
                display: inline-block;
                border: 1px solid #d5d5d5;
                border-radius: 3px;
                background-color: #bdc3c7;
                color: black;
                transition: all .2s linear;
                cursor: pointer;
                
                @apply --menu-button;
            }
            
            .menu-button:enabled:hover, .menu-button:enabled:focus {
                border: 1px solid black;
                background-color: white;
                
                @apply --menu-button-hover;
            }
            
            .menu-button:disabled {
                background-color: #959595;
                
                @apply --menu-button-disabled;
            }
        </style>
    </template>
</dom-module><dom-module id="inkd-drag-section" assetpath="inkd-elements/drag-drop/">

    <template> 
        <style>
            :host {
                display: flex;
                flex-flow: column;
            }
        </style>
        
        
        <content></content>
    </template>

    </dom-module><dom-module id="inkd-drop-section" assetpath="inkd-elements/drag-drop/">

    <template> 
        <style>
            :host {
                display: flex;
                flex-flow: column;
            }
        </style>
        
        
        <content></content>
    </template>

    </dom-module><dom-module id="inkd-draggable" assetpath="inkd-elements/drag-drop/">

    <template>   
        <style>
            :host {
                display: flex;
                border: 2px solid #000;
                align-self: center;
                cursor: move;
                width: 90%;
            }
        </style>
        
        
        <content></content>
    </template>

    </dom-module><dom-module id="inkd-droptarget-styles" assetpath="inkd-styles/">
    <template>
        <style>
            :host {
                display: flex;
                justify-content: center;
                align-items: center;
                border: 1px dotted #000;
                min-height: 40px;
                flex-direction: column;
                width: 90%;
            }
            
            .draggable-wrapper {
                display: flex;
                align-self: center;
                align-items: center;
                width: 100%;
                
                @apply --draggable-wrapper;
            }
            
            .remove-button {
                display: inline-block;
                border: 1px solid black;
                border-radius: 5px;
                cursor: pointer;
                transition: all .2s linear;
                background-color: white;
                background-image: url("inkd-images/close.svg");
                background-repeat: no-repeat;
                background-position: center;
                background-size: 25px 25px;
                width: 25px;
                height: 25px;
                margin-left: 2px;
                
                @apply --remove-button;
            }
            
            .remove-button:hover, .remove-button:focus {
 	            background-color: #bbb;
                
                @apply --remove-button-hover;
            }
            
            .placeholder {
                @apply --placeholder;
            }
        </style>
    </template>
</dom-module><dom-module id="inkd-droptarget" assetpath="inkd-elements/drag-drop/">

    <template>
        <style include="inkd-droptarget-styles"></style>
        
        
        <template is="dom-repeat" items="[[dragChildren]]">
            <div class="draggable-wrapper">
                <content select$="inkd-draggable[data-index='[[index]]']"></content>
                <template is="dom-if" if="[[_checkDragRemovable(item)]]">
                    <button type="button" class="remove-button" data-index$="[[index]]" on-tap="_handleRemove" aria-label="Remove draggable"></button>
                </template>
            </div>
        </template>
        
        
        <template is="dom-if" if="[[_showPlaceholder]]">
            <span class="placeholder"><content></content></span>
        </template>
    </template>

    </dom-module><dom-module id="inkd-dd" assetpath="inkd-elements/drag-drop/">

    <template>
        <style include="inkd-dd-styles"></style>
        
        
        <template is="dom-if" if="[[showLinkedMenu]]">
            <div class="menu-wrapper">
                <template is="dom-repeat" items="[[_dragData.sections]]">
                    <button type="button" on-tap="_handleMenuTap" data-type="drag" data-index$="[[index]]" disabled="[[_checkDisabledButton(index, _dragData.currentIndex)]]" class="menu-button">[[_getMenuLabel(item, index)]]</button>
                </template>
            </div>
        </template>
        
        <div class="wrapper">
            <template is="dom-if" if="[[showDragSection]]">
                <div class="drag-section">
                    <template is="dom-if" if="[[showDragMenu]]">
                        <div class="menu-wrapper">
                            <template is="dom-repeat" items="[[_dragData.sections]]">
                                <button type="button" on-tap="_handleMenuTap" data-type="drag" data-index$="[[index]]" disabled="[[_checkDisabledButton(index, _dragData.currentIndex)]]" class="menu-button">[[_getMenuLabel(item, index)]]</button>
                            </template>
                        </div>
                    </template>
                    <content select="inkd-drag-section[active-section='true']"></content>
                </div>
            </template>
            
            <div class="drop-section">
                <template is="dom-if" if="[[showDropMenu]]">
                    <div class="menu-wrapper">
                        <template is="dom-repeat" items="[[_dropData.sections]]">
                            <button type="button" on-tap="_handleMenuTap" data-type="drop" data-index$="[[index]]" disabled="[[_checkDisabledButton(index, _dropData.currentIndex)]]" class="menu-button">[[_getMenuLabel(item, index)]]</button>
                        </template>
                    </div>
                </template>
                <content select="inkd-drop-section[active-section='true']"></content>
            </div>
        </div>
        
        <span hidden="">
            <content select="inkd-drag-section[active-section='false'], inkd-drop-section[active-section='false']"></content>
        </span>
        
        <content></content>
        

    </template>

    </dom-module><dom-module id="inkd-mc-styles" assetpath="inkd-styles/">
    <template>
        <style>
            *[hidden] {
                display: none;
            }
            
            .previous-button, .next-button {
                flex: 1;
                display: inline-block;
                border: 1px solid #d5d5d5;
                border-radius: 3px;
                background-color: #bdc3c7;
                color: black;
                transition: all .2s linear;
                cursor: pointer;                
            }
            
            .previous-button:enabled:hover, .previous-button:enabled:focus, .next-button:enabled:hover, .next-button:enabled:focus {
                border: 1px solid black;
                background-color: white;                
            }
            
            .next-button:disabled {
                background-color: #959595;            
            }
            
            .previous-button {
                @apply --previous-button;
            }
            
            .previous-button:hover, .previous-button:focus {
                @apply --previous-button-hover;
            }
            
            .next-button {
                @apply --next-button;
            }
            
            .next-button:hover, .next-button:focus {
                @apply --next-button-hover;
            }
            
            .next-button:disabled {
                @apply --next-button-disabled;
            }  
        </style>
    </template>
</dom-module><dom-module id="inkd-mc-section" assetpath="inkd-elements/multiple-choice/">

    </dom-module><dom-module id="inkd-mc-question" assetpath="inkd-elements/multiple-choice/">

    </dom-module><dom-module id="inkd-mc-option-styles" assetpath="inkd-styles/">
    <template>
        <style>
            :host {
                display: block;
            }
            
            input {
                cursor: pointer;
                
                @apply --input;
            }
            
            input:hover, input:focus {   
                @apply --input-hover;
            }
            
            :host[checked] input {                
                @apply --input-checked;
            }
            
            label {
                cursor: pointer;
                
                @apply --label;
            }
            
            input:hover ~ label, input:focus ~ label {                
                @apply --label-hover;
            }
            
            :host[checked] label {                
                @apply --label-checked;
            }
        </style>
    </template>
</dom-module><dom-module id="inkd-mc-option" assetpath="inkd-elements/multiple-choice/">

    <template>
        <style include="inkd-mc-option-styles"></style>
        
        
        <template is="dom-if" if="[[!multiple]]">
            <input type="radio" name="[[questionId]]" id="[[questionId]]-[[index]]" checked="[[checked]]" on-tap="_handleTap">
        </template>
        
        <template is="dom-if" if="[[multiple]]">
            <input type="checkbox" id="[[questionId]]-[[index]]" checked="[[checked]]" on-tap="_handleTap">
        </template>
        
        <label for$="[[questionId]]-[[index]]">
            <content></content>
        </label>
    </template>

    </dom-module><dom-module id="inkd-mc-multimedia" assetpath="inkd-elements/multiple-choice/">

    </dom-module><dom-module id="inkd-mc" assetpath="inkd-elements/multiple-choice/">

    <template>
        <style include="inkd-mc-styles"></style>

        
        <content select="*[active-section='true']"></content>
        
        <template is="dom-if" if="[[_showPrevious]]">
            <button type="button" class="previous-button" on-tap="_handlePrevious">Previous</button>
        </template>

        <template is="dom-if" if="[[_showNext]]">
            <button id="nextButton" type="button" class="next-button" on-tap="_handleNext" disabled="[[_disableNext]]">Next</button>
        </template>
        
        <span hidden="">
            <content select="*[active-section='false']"></content>
        </span>
        
        <content></content>
    </template>

    </dom-module><dom-module id="inkd-feedback" assetpath="inkd-elements/">

    </dom-module><dom-module id="inkd-list-styles" assetpath="inkd-styles/">
    <template>
        <style>
            .list {
                list-style: none;
                cursor: default;
                padding-left: 1.5em;
                
                @apply --list;
            }
            
            .list-item {   
                display: block;
                @apply --list-item;
            }
            
            .number {
                @apply --number;
            }
            
            .link {
                cursor: pointer;
                
                @apply --link;
            }
            
            .link:hover, .link:focus {
                @apply --link-hover;
            }
                        
            .link.visited {
                color: purple;
                @apply --list-link-visited;
            }
            
            .link.active {
                color: green;
                pointer-events: none;

                @apply --list-link-active;
            }
            
            .text {                
                @apply --list-text;
            }
            
            .number {
                padding-left: 23px;
                margin: 0;
            }
            
            .toggle-button ~ .number {
                padding-left: 0;
            }
            
            .toggle-button {
                background: url("inkd-images/down.svg");
                /* By Google Inc., CC BY 4.0, https://commons.wikimedia.org/w/index.php?curid=36333571 */
            }
            
            .hide-list .toggle-button {
                background: url("inkd-images/right.svg");
                /* By Google Inc., CC BY 4.0, https://commons.wikimedia.org/w/index.php?curid=36333583 */
            }
            
            .toggle-button, .hide-list .toggle-button {
                position: relative;
                border: none;
                padding: 0;
                margin: 0;
                top: 5px;
                width: 20px;
                height: 20px;
                background-size: 20px 20px;
                background-position: center;
                background-repeat: no-repeat;
            }
            
            .hide-list .sublist {
                display: none;
            }
        </style>
    </template>
</dom-module><dom-module id="inkd-list" assetpath="inkd-elements/">

    <template>
        <style include="inkd-list-styles"></style>

        <ol class="list">
            <template is="dom-repeat" items="[[data]]">
                <li class="list-item" on-tap="_handleTap">
                    <template is="dom-if" if="[[item.list]]">
                        <button type="button" class="toggle-button"></button>
                    </template>
                    
                    <span class="number">[[_getNumber(index)]]</span>
                    
                    <template is="dom-if" if="[[item.link]]">
                        <a href="#" on-tap="_handleLinkTap" class$="[[_getLinkClasses(item.active, item.visited)]]" data-index$="[[index]]" tabindex="0">[[item.text]]</a>
                    </template>
                    <template is="dom-if" if="[[!item.link]]">
                        <span class="text">[[item.text]]</span>
                    </template>
                    
                    <template is="dom-if" if="[[item.list]]">
                        <inkd-list data="[[item.list]]" subindex="[[_getNumber(index)]]" class="sublist"></inkd-list>
                    </template>
                </li>
            </template>
        </ol>
    </template>

    </dom-module><dom-module id="inkd-outline" assetpath="inkd-elements/">

    <template>
        <content></content>
        <inkd-list data="[[_listData]]"></inkd-list>
    </template>

    </dom-module><style is="custom-style">

    .modal-shown {
        overflow: hidden;
    }
    
    .animationSpan {
        display: inline-block;
        -webkit-animation-fill-mode: both;
        animation-fill-mode: both;
    }

.btn{-webkit-appearance:none;-moz-appearance:none;appearance:none;outline:none;display:inline-block;font-size:16px;font-size:1rem;font-family:inherit;line-height:inherit;text-align:center;text-transform:none;padding:0.5em 1em;margin:0;border:0.06em solid #d5d5d5;cursor:pointer;-webkit-transition:all .2s linear;transition:all .2s linear}.btn:enabled:hover{background-color:#fff;color:#000;border:0.06em solid #000}.btn[hidden]{display:none}.btn-small{font-size:12.8px;font-size:0.8rem;padding:0.250em 0.438em}.btn-medium{font-size:17.6px;font-size:1.1rem;padding:0.375em 0.750em}.btn-large{font-size:22.4px;font-size:1.4rem;padding:0.615em 1.063em}.btn-jumbo{font-size:27.2px;font-size:1.7rem;padding:0.938em 1.37em}.btn-green{background-color:#2ecc71;color:#fff}.btn-green:hover{color:#2ecc71;border-color:#2ecc71;background-color:transparent}.btn-green:enabled:hover{color:#2ecc71;border-color:#2ecc71}.btn-blue{background-color:#3498db;color:#fff}.btn-blue:hover{color:#3498db;border-color:#3498db;background-color:transparent}.btn-blue:enabled:hover{color:#3498db;border-color:#3498db}.btn-red{background-color:#e74c3c;color:#fff}.btn-red:hover{color:#e74c3c;border-color:#e74c3c;background-color:transparent}.btn-red:enabled:hover{color:#e74c3c;border-color:#e74c3c}.btn-black{background-color:#000;color:#fff}.btn-black:hover{color:#000;border-color:#000;background-color:transparent}.btn-black:enabled:hover{color:#000;border-color:#000}.btn-orange{background-color:#e67e22;color:#fff}.btn-orange:hover{color:#e67e22;border-color:#e67e22;background-color:transparent}.btn-orange:enabled:hover{color:#e67e22;border-color:#e67e22}.btn-brown{background-color:#795548;color:#fff}.btn-brown:hover{color:#795548;border-color:#795548;background-color:transparent}.btn-brown:enabled:hover{color:#795548;border-color:#795548}.btn-purple{background-color:#8e44ad;color:#fff}.btn-purple:hover{color:#8e44ad;border-color:#8e44ad;background-color:transparent}.btn-purple:enabled:hover{color:#8e44ad;border-color:#8e44ad}.btn-submit{white-space:nowrap;padding:0.5em 1em 0.5em 1.5em}.btn-submit:before{content:"\2714";float:left;width:1em;text-align:center;font-size:1em;margin:0 0.02em 0 -0.8em;padding:0 .2em;pointer-events:none}.btn-round{border-radius:1em}.btn-radius{border-radius:0.31em}.btn-circle{width:6em;height:6em;border-radius:50%}inkd-ml .node{display:block;position:relative;width:85%;height:auto;background-color:transparent;color:#000;padding:1em;margin:2em auto;border:0.06em solid #d5d5d5;overflow:hidden}.node-center{margin:0 auto}.node-blue{background-color:#3498db;border:0.06em solid #3498db}.node-grey{background-color:#d5d5d5}.node-pink{background-color:pink;border:0.06em solid pink}.node-green{background-color:#2ecc71;border:0.06em solid #2ecc71}.node-yellow{background-color:#f1c40f;border:0.06em solid #f1c40f}.background-node-img{position:absolute;z-index:-1;width:100%;height:auto;min-width:100%;min-height:100%;top:0;left:0;margin:0;padding:0}.node-letter{position:relative;box-shadow:0 8px 10px -6px #000;background:-webkit-linear-gradient(240deg, transparent 1.5em, #ecf0f1 0);background:linear-gradient(-150deg, transparent 1.5em, #ecf0f1 0);border-radius:.5em;border:0 none}.node-letter:before{content:'';position:absolute;top:0;right:0;width:1.73em;height:3em;background:-webkit-linear-gradient(right top, transparent 50%, rgba(0,0,0,0.2) 0, rgba(0,0,0,0.4)) 100% 0 no-repeat;background:linear-gradient(to left bottom, transparent 50%, rgba(0,0,0,0.2) 0, rgba(0,0,0,0.4)) 100% 0 no-repeat;-webkit-transform:translateY(-1.3em) rotate(-30deg);transform:translateY(-1.3em) rotate(-30deg);-webkit-transform-origin:bottom right;transform-origin:bottom right;border-bottom-left-radius:.5em;box-shadow:-0.2em 0.2em 0.3em -0.1em rgba(0,0,0,0.15)}.node-cutcorners{border:0 none;background-color:#3498db;-webkit-clip-path:polygon(20px 0, calc(100% - 20px) 0, 100% 20px, 100% calc(100% - 20px), calc(100% - 20px) 100%, 20px 100%, 0 calc(100% - 20px), 0 20px);clip-path:polygon(20px 0, calc(100% - 20px) 0, 100% 20px, 100% calc(100% - 20px), calc(100% - 20px) 100%, 20px 100%, 0 calc(100% - 20px), 0 20px)}.node-fadein{-webkit-animation:node-fadein .8s ease-out;animation:node-fadein .8s ease-out}@-webkit-keyframes node-fadein{from{opacity:0;-ms-filter:"progid:DXImageTransform.Microsoft.Alpha(Opacity=0)"}to{opacity:1;-ms-filter:"progid:DXImageTransform.Microsoft.Alpha(Opacity=100)"}}@keyframes node-fadein{from{opacity:0;-ms-filter:"progid:DXImageTransform.Microsoft.Alpha(Opacity=0)"}to{opacity:1;-ms-filter:"progid:DXImageTransform.Microsoft.Alpha(Opacity=100)"}}.node-fadeout{-webkit-animation:node-fadeout .8s ease-out;animation:node-fadeout .8s ease-out}@-webkit-keyframes node-fadeout{from{opacity:1;-ms-filter:"progid:DXImageTransform.Microsoft.Alpha(Opacity=100)"}to{opacity:0;-ms-filter:"progid:DXImageTransform.Microsoft.Alpha(Opacity=0)"}}@keyframes node-fadeout{from{opacity:1;-ms-filter:"progid:DXImageTransform.Microsoft.Alpha(Opacity=100)"}to{opacity:0;-ms-filter:"progid:DXImageTransform.Microsoft.Alpha(Opacity=0)"}}.node-slide{-webkit-animation:slide .8s ease-out;animation:slide .8s ease-out}@-webkit-keyframes slide{from{-webkit-transform:translateX(-100%);transform:translateX(-100%)}to{-webkit-transform:translateX(0);transform:translateX(0)}}@keyframes slide{from{-webkit-transform:translateX(-100%);transform:translateX(-100%)}to{-webkit-transform:translateX(0);transform:translateX(0)}}.node-hinge{-webkit-animation:hinge .8s ease-in-out;animation:hinge .8s ease-in-out}@-webkit-keyframes hinge{0%{opacity:0;-ms-filter:"progid:DXImageTransform.Microsoft.Alpha(Opacity=0)";-webkit-transform:rotate(60deg);transform:rotate(60deg);-webkit-transform-origin:bottom right;transform-origin:bottom right}20%{-webkit-transform:rotate(80deg);transform:rotate(80deg)}80%{opacity:1;-ms-filter:"progid:DXImageTransform.Microsoft.Alpha(Opacity=100)"}100%{opacity:1;-ms-filter:"progid:DXImageTransform.Microsoft.Alpha(Opacity=100)";-webkit-transform:rotate(0);transform:rotate(0)}}@keyframes hinge{0%{opacity:0;-ms-filter:"progid:DXImageTransform.Microsoft.Alpha(Opacity=0)";-webkit-transform:rotate(60deg);transform:rotate(60deg);-webkit-transform-origin:bottom right;transform-origin:bottom right}20%{-webkit-transform:rotate(80deg);transform:rotate(80deg)}80%{opacity:1;-ms-filter:"progid:DXImageTransform.Microsoft.Alpha(Opacity=100)"}100%{opacity:1;-ms-filter:"progid:DXImageTransform.Microsoft.Alpha(Opacity=100)";-webkit-transform:rotate(0);transform:rotate(0)}}inkd-ml .node-scale{-webkit-animation:scale .8s ease-in;animation:scale .8s ease-in}@-webkit-keyframes scale{from{-webkit-transform:scale(0);transform:scale(0)}to{-webkit-transform:scale(1);transform:scale(1)}}@keyframes scale{from{-webkit-transform:scale(0);transform:scale(0)}to{-webkit-transform:scale(1);transform:scale(1)}}.rollover-img{position:relative;cursor:pointer;overflow:hidden}.rollover-img-overlay{position:absolute;top:0;bottom:0;left:0;right:0;-webkit-transition:.5s ease;transition:.5s ease}.rollover-img-overlay:hover{opacity:0;-ms-filter:"progid:DXImageTransform.Microsoft.Alpha(Opacity=0)"}.rollover-img-fadein{opacity:0;-ms-filter:"progid:DXImageTransform.Microsoft.Alpha(Opacity=0)";-webkit-transition:.5s ease;transition:.5s ease}.rollover-img-fadein:hover{opacity:1;-ms-filter:"progid:DXImageTransform.Microsoft.Alpha(Opacity=100)"}.rollover-img-slide{overflow:hidden;left:0;-webkit-transition:.5s ease-in-out;transition:.5s ease-in-out}.rollover-img-slide:hover{left:-100%}.rollover-blur{-webkit-filter:blur(3px);filter:url("data:image/svg+xml;charset=utf-8,<svg xmlns=http://www.w3.org/2000/svg><filter id=filter><feGaussianBlur stdDeviation=3 /></filter></svg>#filter");filter:blur(3px);-webkit-transition:.3s ease-in-out;transition:.3s ease-in-out}.rollover-blur:hover{-webkit-filter:blur(0);filter:url("data:image/svg+xml;charset=utf-8,<svg xmlns=http://www.w3.org/2000/svg><filter id=filter><feGaussianBlur stdDeviation=0 /></filter></svg>#filter");filter:blur(0)}.rollover-fadein{opacity:0.5;-ms-filter:"progid:DXImageTransform.Microsoft.Alpha(Opacity=50)";-webkit-transition:opacity 1s ease-in-out;transition:opacity 1s ease-in-out}.rollover-fadein:hover{opacity:1.0;-ms-filter:"progid:DXImageTransform.Microsoft.Alpha(Opacity=100)";-webkit-transition:opacity .55s ease-in-out;transition:opacity .55s ease-in-out}.rollover-fadeout{opacity:1.0;-ms-filter:"progid:DXImageTransform.Microsoft.Alpha(Opacity=100)";-webkit-transition:opacity .55s ease-in-out;transition:opacity .55s ease-in-out}.rollover-fadeout:hover{opacity:0.5;-ms-filter:"progid:DXImageTransform.Microsoft.Alpha(Opacity=50)";-webkit-transition:opacity 1s ease-in-out;transition:opacity 1s ease-in-out}.rollover-gray{-webkit-filter:grayscale(100%);filter:url("data:image/svg+xml;charset=utf-8,<svg xmlns=http://www.w3.org/2000/svg><filter id=filter><feColorMatrix type=matrix color-interpolation-filters=sRGB values=0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0 /></filter></svg>#filter");filter:grayscale(100%);-webkit-transition:.3s ease-in-out;transition:.3s ease-in-out}.rollover-gray:hover{-webkit-filter:grayscale(0);filter:url("data:image/svg+xml;charset=utf-8,<svg xmlns=http://www.w3.org/2000/svg><filter id=filter><feColorMatrix type=matrix color-interpolation-filters=sRGB values=1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0 /></filter></svg>#filter");filter:grayscale(0)}.rollover-rotate{-webkit-transform:rotate(0) scale(1);transform:rotate(0) scale(1);-webkit-transition:.3s ease-in-out;transition:.3s ease-in-out}.rollover-rotate:hover{-webkit-transform:rotate(360deg) scale(1.4);transform:rotate(360deg) scale(1.4)}
    .rollover-sepia{-webkit-filter:sepia(100%);filter:url("data:image/svg+xml;charset=utf-8,<svg xmlns=http://www.w3.org/2000/svg><filter id=filter><feColorMatrix type=matrix color-interpolation-filters=sRGB values=0.393 0.769 0.189 0 0 0.349 0.686 0.168 0 0 0.272 0.534 0.131 0 0 0 0 0 1 0 /></filter></svg>#filter");filter:sepia(100%);-webkit-transition:.3s ease-in-out;transition:.3s ease-in-out}.rollover-sepia:hover{-webkit-filter:sepia(0);filter:url("data:image/svg+xml;charset=utf-8,<svg xmlns=http://www.w3.org/2000/svg><filter id=filter><feColorMatrix type=matrix color-interpolation-filters=sRGB values=1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0 /></filter></svg>#filter");filter:sepia(0)}.rollover-scale{-webkit-transform:scale(1);transform:scale(1);-webkit-transition:.3s ease-in-out;transition:.3s ease-in-out}.rollover-scale:hover{-webkit-transform:scale(1.3);transform:scale(1.3)}.reset-styles{border:none 0;padding:0;background-color:transparent;color:transparent}.reset-styles:hover{border:none 0;background-color:transparent}.img{border:0 none;outline:none;overflow:hidden}.img-center{display:block;margin:2em auto}.img-fullscreen{display:block;width:100%;max-width:none;max-height:none;height:auto}.img-radius{border-radius:0.31em}.img-round{border-radius:1.5em}.img-circle{width:15em;height:15em;border-radius:50%}.img-normal-border{border:0.31em solid #000}.img-double-border{border:0.31em double #000}.img-sepia{-webkit-filter:sepia(1);filter:url("data:image/svg+xml;charset=utf-8,<svg xmlns=http://www.w3.org/2000/svg><filter id=filter><feColorMatrix type=matrix color-interpolation-filters=sRGB values=0.393 0.769 0.189 0 0 0.349 0.686 0.168 0 0 0.272 0.534 0.131 0 0 0 0 0 1 0 /></filter></svg>#filter");filter:sepia(1)}.img-grayscale{-webkit-filter:grayscale(1);filter:url("data:image/svg+xml;charset=utf-8,<svg xmlns=http://www.w3.org/2000/svg><filter id=filter><feColorMatrix type=matrix color-interpolation-filters=sRGB values=0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0 /></filter></svg>#filter");filter:grayscale(1)}.body-text{font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;font-size:16px;font-size:1rem;font-weight:normal;line-height:1.5}.headline{font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;font-size:19.2px;font-size:1.2rem;font-weight:800;line-height:1.5}
    
    @import url("https://fonts.googleapis.com/css?family=Old+Standard+TT");@import url("https://fonts.googleapis.com/css?family=VT323");@import url("https://fonts.googleapis.com/css?family=Space+Mono");.layout-container{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center}.one-column-layout{display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;padding:1.2em;width:80%;height:auto}@media only screen and (max-width: 870px){.one-column-layout{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;height:auto;margin-top:5em;margin-bottom:2.5em}}@media only screen and (min-width: 1366px){.one-column-layout{height:80vh}}.one-column-layout > inkd-box:first-child{-ms-flex-preferred-size:100%;flex-basis:100%;padding:1em;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.one-column-layout > inkd-box:nth-child(2n){display:block;-ms-flex-preferred-size:100%;flex-basis:100%;margin:0 -1em;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}@media only screen and (max-width: 870px){.one-column-layout > inkd-box:nth-child(2n){-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-ms-flex-line-pack:justify;align-content:space-between}}.one-column-layout.fullscreen{width:100%;height:100vh}.one-column-layout p{margin-left:0.625em}@media only screen and (max-width: 870px){.one-column-layout p{padding:1em 0}}.one-column-layout inkd-button{width:30%;padding:1em 2em;margin:0 1em;cursor:pointer;font-size:1rem;text-align:center}@media only screen and (max-width: 870px){.one-column-layout inkd-button{width:60%;margin:1em 0}}.one-column-layout img{max-width:100%;height:auto}.two-column-layout{display:-webkit-box;display:-ms-flexbox;display:flex;width:80%;padding:1.2em;overflow:hidden}@media only screen and (max-width: 870px){.two-column-layout{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;margin-top:25em;margin-bottom:2.5em;height:auto}}@media only screen and (min-width: 1366px){.two-column-layout{height:80vh}}.two-column-layout.fullscreen{width:100%;height:100vh}.two-column-layout > inkd-box:first-child{-ms-flex-negative:0;flex-shrink:0;-webkit-box-flex:0;-ms-flex-positive:0;flex-grow:0;padding:1em;min-width:0;-ms-flex-preferred-size:50%;flex-basis:50%;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}@media only screen and (max-width: 870px){.two-column-layout > inkd-box:first-child{-ms-flex-preferred-size:100%;flex-basis:100%}}.two-column-layout > inkd-box:nth-child(2n){-ms-flex-negative:1;flex-shrink:1;-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}@media only screen and (max-width: 870px){.two-column-layout > inkd-box:nth-child(2n){-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-ms-flex-line-pack:justify;align-content:space-between}}.two-column-layout inkd-button{display:inline-block;width:60%;line-height:0;padding:1.2em 2em;margin:1em 0;cursor:pointer;font-size:1rem;text-align:center;zoom:1;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.two-column-layout p{font-size:1rem;padding-bottom:1em}@media only screen and (max-width: 870px){.two-column-layout p{padding:1em 0}}.two-column-layout img{max-width:100%;height:auto}.three-image-layout{width:100%;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-flow:row wrap;flex-flow:row wrap;-ms-flex-pack:distribute;justify-content:space-around;-webkit-box-align:center;-ms-flex-align:center;align-items:center}@media only screen and (max-width: 870px){.three-image-layout{width:100%;padding:0}}.three-image-layout figure{-webkit-box-flex:1;-ms-flex:auto;flex:auto;margin:.5vw;width:200px}@media only screen and (max-width: 870px){.three-image-layout figure{width:100%;margin:0}}.three-image-layout img{width:100%;height:auto}.old-theme{font-family:Old Standard TT,serif}.old-theme img{-webkit-filter:grayscale(100%);filter:grayscale(100%);border:0.625em solid #fff;border-bottom:2.8125em solid #fff;-webkit-box-shadow:0.1875em 0.1875em 0.1875em #777;box-shadow:0.1875em 0.1875em 0.1875em #777;-webkit-transform:rotate(-8deg) scale(0.98);transform:rotate(-8deg) scale(0.98);margin-left:1em;-webkit-transition:all .3s ease-in-out;transition:all .3s ease-in-out}@media only screen and (max-width: 870px){.old-theme img{margin-left:0}}.old-theme img:hover{-webkit-transform:rotate(-8deg) scale(1);transform:rotate(-8deg) scale(1)}.old-theme p{font-weight:800}.old-theme inkd-button{color:peru;background-color:#fff;-webkit-box-shadow:0.0625em 0.0625em 0.0625em #777;box-shadow:0.0625em 0.0625em 0.0625em #777;border-radius:0.31em;font-size:1em;font-weight:800;-webkit-transition:all .3s ease-in-out;transition:all .3s ease-in-out}.old-theme inkd-button:hover{background-color:peru;color:#fff}.old-theme .three-image-layout{margin-left:-2em}.terminal-theme{background-color:#000;border:0.625em solid #00ff40;font-family:VT323,serif;color:#00ff40;font-size:1em}.terminal-theme img{padding:1em;border:0.0625em solid #00ff40}.terminal-theme p{font-size:1.1rem}.terminal-theme inkd-button{background-color:#2C2C2C;color:#00ff40;border:0.0625em solid #00ff40;font-size:1em}.terminal-theme inkd-button:hover{background-color:#00ff40;color:#2C2C2C}.business-theme{background-color:#2C2C2C;color:#fff;border-top:1em solid #1abc9c;font-family:Space Mono,serif}.business-theme img{border:0.31em solid #1abc9c}.business-theme inkd-button{background-color:#bc9c1a;color:#2C2C2C}.business-theme inkd-button:hover{background-color:#836d12;color:#000}
    
    .hotspot__white {
        display: block;
        padding: 10px;
        border-radius: 10px;
        background-color: white;
        color: black;
        text-align: center;
    }
    
    .hotspot__black {
        display: block;
        padding: 10px;
        border-radius: 10px;
        background-color: black;
        color: white;
        text-align: center;
    }
    
    .hotspot__white[disabled], .hotspot__black[disabled] {
        cursor: not-allowed;
    }
    
    .tooltip {
        font-size: 1em;
        font-weight: 800;
        position: absolute; 
        border-radius: 0.18em;
        background-color: rgba(0,0,0,0.8);
        color: #fff;
        text-align: center;
        max-width: 200px;
        padding: 5px 10px;
        cursor: pointer;
    }

    .tooltip:after {
        content: '';
        position: absolute;
        width: 0;
        height: 0;
        border-width: 10px;
        border-style: solid;
        border-color: rgba(0,0,0,0.8) transparent transparent transparent;
        bottom: -20px;
        left: -10px;
        margin: 0 50%;
    }
    
</style>
</div><script>'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var GlobalBehavior = {

    ready: function ready() {
        this.globalElement = document.querySelector('inkd-ml');
    },

    attached: function attached() {
        this.isAttached = true;
    },

    detached: function detached() {
        this.isAttached = false;
    },

    onGlobalReady: function onGlobalReady(handler) {
        if (this.globalElement.isReady) {
            this[handler]();
        } else {
            this.listen(this.globalElement, 'inkdml-ready', handler);
        }
    },

    onGlobalAttach: function onGlobalAttach(handler) {
        if (this.globalElement.isAttached) {
            this[handler]();
        } else {
            this.listen(this.globalElement, 'inkdml-attached', handler);
        }
    },

    setGlobalProp: function setGlobalProp(prop, propValue) {
        var propType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'user-property';

        var data = this.globalElement.get('propertyData.' + prop);
        if (data === undefined || data.propType === propType) {
            this.globalElement.set('propertyData.' + prop, { propValue: propValue, propType: propType });
            this.globalElement.fire('property-changed-' + prop, { prop: prop, value: propValue });
        }
    },

    getGlobalProp: function getGlobalProp(prop) {
        if (this.globalElement.get !== undefined) {
            return this.globalElement.get('propertyData.' + prop);
        }
    },

    getGlobalPropValue: function getGlobalPropValue(prop) {
        var data = this.getGlobalProp(prop);
        if (data !== undefined) {
            return data.propValue;
        }
    },

    getGlobalPropType: function getGlobalPropType(prop) {
        var data = this.getGlobalProp(prop);
        if (data !== undefined) {
            return data.propType;
        }
    },

    onGlobalChange: function onGlobalChange(prop, handler) {
        this.listen(this.globalElement, 'property-changed-' + prop, handler);
    },

    setGlobalNameElement: function setGlobalNameElement(name, element) {
        this.setGlobalProp(name, element, 'element');
    },

    getGlobalNameElement: function getGlobalNameElement(name, tagsArray, attr) {
        var debugElement = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this;

        var data = this.getGlobalProp(name);
        if (data === undefined || data.propType !== 'element') {
            if (attr !== undefined) {
                this.addDebugError(attr, 'Element with name \'' + name + '\' does not exist', debugElement);
            }
        } else if (tagsArray) {
            var element = data.propValue;
            var tag = element.tagName.toLowerCase();
            tagsArray = [].concat(tagsArray);
            if (tagsArray.includes(tag)) {
                return element;
            } else if (attr !== undefined) {
                this.addDebugError(attr, '<' + tag + '> element \'' + name + '\' is not supported in \'' + attr + '\' attribute (Supported tags: <' + tagsArray.join('>, <') + '>)', debugElement);
            }
        } else {
            return data.propValue;
        }
    },

    fireGlobalEvent: function fireGlobalEvent(event, detail) {
        this.globalElement.fire(event, detail);
    },

    onGlobalEvent: function onGlobalEvent(event, handler) {
        this.listen(this.globalElement, event, handler);
    },

    updateGlobalHistory: function updateGlobalHistory(nodeName, replaceBoolean) {
        if (this.globalElement.bookmark) {
            var newurl = '' + window.location.origin + window.location.pathname + '?node=' + encodeURIComponent(nodeName);

            if (replaceBoolean) {
                window.history.replaceState({ path: newurl, node: nodeName }, '', newurl);
            } else {
                window.history.pushState({ path: newurl, node: nodeName }, '', newurl);
            }

            document.title = this.globalElement.topic + ' - ' + nodeName;
        }
    },

    parse: function parse(stringValue) {
        if (isNaN(stringValue)) {
            if (stringValue === 'true') {
                return { value: true, type: 'boolean' };
            } else if (stringValue === 'false') {
                return { value: false, type: 'boolean' };
            } else if (/(^'|").*\1$/.test(stringValue)) {
                return { value: stringValue.slice(1, -1).replace(/\\([,=:'"])/g, '$1'), type: 'string' };
            } else {
                var data = this.getGlobalProp(stringValue);
                if (data) {
                    return { value: data.propValue, type: data.propType };
                }
                return { value: null, type: 'error' };
            }
        } else {
            if (stringValue === '') {
                return { value: null, type: 'error' };
            }
            return { value: Number(stringValue), type: 'number' };
        }
    },

    getGlobalUniqueId: function getGlobalUniqueId() {
        this.globalElement.uniqueId++;
        return this.globalElement.uniqueId;
    }
};
var DomBehavior = {

    ready: function ready() {
        this.domParent = Polymer.dom(this).parentNode;
        this.domAttached = true;
    },

    domAdd: function domAdd() {
        if (!this.domAttached) {
            Polymer.dom(this.domParent).appendChild(this);
            this.domAttached = true;
        }
    },

    domRemove: function domRemove() {
        if (this.globalElement.isReady) {
            this._domRemove();
        } else {
            this.onGlobalReady('_domRemove');
        }
    },

    _domRemove: function _domRemove() {
        if (this.domAttached) {
            this.domParent = Polymer.dom(this).parentNode;
            Polymer.dom(this.domParent).removeChild(this);
            this.domAttached = false;
        }
    },

    domReplace: function domReplace(newElement) {
        if (this.domAttached) {
            this.domParent = Polymer.dom(this).parentNode;
            Polymer.dom(this.domParent).insertBefore(newElement, this);
            this.domRemove();
        }
    }
};
var DebugBehavior = {
    registered: function registered() {
        this._allProperties = Object.assign({}, this.properties);
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = this.behaviors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var behavior = _step.value;

                if (behavior.properties) {
                    Object.assign(this._allProperties, behavior.properties);
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    },

    ready: function ready() {
        this._debugOn = this.globalElement.hasAttribute('debug');
        this._tempDebugList = [];

        this._validateAttributes();

        if (!['INKD-ML', 'INKD-CONTENT'].includes(this.tagName)) {
            this.enforceAncestor('inkd-ml');
        }

        if (this._debugOn) {
            this.onGlobalReady('_pushTempDebug');
        }
    },

    addDebugError: function addDebugError(attribute, string) {
        var element = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this;

        this._addDebug(attribute, string, element, 'error');
    },

    addDebugWarn: function addDebugWarn(attribute, string) {
        var element = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this;

        this._addDebug(attribute, string, element, 'warning');
    },

    get tag() {
        return this.getTag(this);
    },

    getTag: function getTag(element) {
        if (element.innerHTML) {
            return element.outerHTML.slice(0, element.outerHTML.indexOf(element.innerHTML));
        } else {
            return element.outerHTML;
        }
    },

    enforceAncestor: function enforceAncestor() {
        for (var _len = arguments.length, ancestors = Array(_len), _key = 0; _key < _len; _key++) {
            ancestors[_key] = arguments[_key];
        }

        this._ancestorsToEnforce = ancestors;
        this.onGlobalAttach('_enforceAncestor');
    },

    enforceDirectAncestor: function enforceDirectAncestor() {
        for (var _len2 = arguments.length, ancestors = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            ancestors[_key2] = arguments[_key2];
        }

        this._ancestorsToEnforce = ancestors;
        this._enforceAncestorsDirect = true;
        this.onGlobalAttach('_enforceAncestor');
    },

    _addDebug: function _addDebug(attribute, string, element, type) {
        var text = '<' + element.tagName.toLowerCase() + '>' + (attribute === null ? '' : ' \'' + attribute + '\'') + ': ' + string;

        if (type === 'error') {
            console.error(text);
        } else if (type === 'warning') {
            console.warn(text);
        }

        if (this._debugOn) {
            var logData = { text: text, type: type, info: element.tag || this.getTag(element) };
            if (this.globalElement.isReady) {
                this.globalElement.push('debugList', logData);
            } else {
                this._tempDebugList.push(logData);
            }
        }
    },

    _pushTempDebug: function _pushTempDebug() {
        if (this._tempDebugList.length > 0) {
            this.globalElement.debugList = this.globalElement.debugList.concat(this._tempDebugList);
        }
    },

    _enforceAncestor: function _enforceAncestor() {
        var parent = Polymer.dom(this).parentNode;

        if (parent !== null && parent.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
            if (this._enforceAncestorsDirect) {
                if (!this._ancestorsToEnforce.includes(parent.tagName.toLowerCase())) {
                    this.addDebugError(null, '<' + this.tagName.toLowerCase() + '> has to be a direct child of <' + this._ancestorsToEnforce.join('> or <') + '>');
                    this.domRemove();
                }
            } else {
                var validAncestor = false;
                while (parent !== null && parent.tagName !== 'HTML') {
                    if (parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE || this._ancestorsToEnforce.includes(parent.tagName.toLowerCase())) {
                        validAncestor = true;
                        break;
                    } else {
                        parent = Polymer.dom(parent).parentNode;
                    }
                }

                if (parent !== null && !validAncestor) {
                    this.addDebugError(null, '<' + this.tagName.toLowerCase() + '> has to have a parent <' + this._ancestorsToEnforce.join('> or <') + '>');
                    this.domRemove();
                }
            }
        }
    },

    _validateAttributes: function _validateAttributes() {
        var htmlAttributes = ['accesskey', 'class', 'contenteditable', 'contextmenu', 'dir', 'draggable', 'dropzone', 'hidden', 'id', 'lang', 'spellcheck', 'style', 'tabindex', 'title', 'translate'];


        var privateAttributes = ['active-node', 'active-event', 'active-section', 'active-question'];

        for (var i = 0; i < this.attributes.length; i++) {
            var attr = this.attributes[i].nodeName;

            var _prop = attr.replace(/-([a-z])/g, function (x) {
                return x[1].toUpperCase();
            });

            if (this._allProperties.hasOwnProperty(_prop)) {
                var data = this._allProperties[_prop];
                var value = this.attributes[i].value;

                if (data === Boolean || (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object' && data.type === Boolean) {
                    if (value === 'false') {
                        this[_prop] = false;
                    } else if (value !== '' && value !== 'true') {
                        this.setAttribute(attr, '');
                        this.addDebugWarn(attr, '\'' + value + '\' is unused because \'' + attr + '\' is a Boolean flag');
                    }
                } else if (data === Number && (value === '' || isNaN(value))) {
                    this[_prop] = undefined;
                    this.addDebugError(attr, '\'' + value + '\' is not a number');
                } else if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object' && data.type === Number) {
                    if (value === '' || isNaN(value) || data.min !== undefined && value < data.min || data.max !== undefined && value > data.max) {
                        var descString = data.desc === undefined ? '' : data.desc;
                        var ruleString = void 0;

                        if (data.min !== undefined && data.max !== undefined) {
                            ruleString = ' (has to be a number between ' + data.min + ' and ' + data.max + ')';
                        } else if (data.min !== undefined) {
                            ruleString = ' (has to be a number greater than ' + data.min + ')';
                        } else if (data.max !== undefined) {
                            ruleString = ' (has to be a number less than ' + data.max + ')';
                        } else {
                            ruleString = ' (has to be a number)';
                        }

                        var defaultValue = data.value;
                        var defaultString = void 0;
                        if (defaultValue === undefined) {
                            defaultString = '';
                        } else {
                            defaultString = '. Default value ' + defaultValue + ' used';
                            this.setAttribute(attr, defaultValue);
                        }
                        this[_prop] = defaultValue;

                        this.addDebugError(attr, '\'' + value + '\' is not a valid \'' + descString + '\' value ' + ruleString + defaultString);
                    } else {
                        this[_prop] = value;
                    }
                } else if (data === String && value === '') {
                    this.addDebugError(attr, '\'\' is not a valid value');
                } else if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object' && data.type === String && value === '' && !data.flagAllowed) {
                    this.addDebugError(attr, '\'\' is not a valid value');
                }
            } else if (!(htmlAttributes.includes(attr) || privateAttributes.includes(attr) || attr.startsWith('data-') || attr.startsWith('aria-'))) {
                this.addDebugError(null, '\'' + attr + '\' is not a valid attribute');
            }
        }
    }
};
var TrackBehavior = {
    properties: {
        trackTag: String,
        trackData: String
    },

    ready: function ready() {
        this.trackOn = this.globalElement.hasAttribute('track');

        if (this.trackOn) {
            this.trackLogOn = this.globalElement.hasAttribute('debug');

            this.tempTrackList = [];
            this.tempTrackLogList = [];

            if (this.trackData) {
                var dataObject = {};
                var splitResult = this.trackData.split(',');
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                    for (var _iterator2 = splitResult[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        var keyValue = _step2.value;

                        var match = keyValue.match(/\s*(\S*)\s*:\s*(.*)\s*/);
                        if (match) {
                            var _match = _slicedToArray(match, 3),
                                key = _match[1],
                                value = _match[2];

                            dataObject[key] = value;
                        } else {
                            this.addDebugError('track-data', '\'' + keyValue + '\' is not a valid key\u2013value pair');
                        }
                    }
                } catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion2 && _iterator2.return) {
                            _iterator2.return();
                        }
                    } finally {
                        if (_didIteratorError2) {
                            throw _iteratorError2;
                        }
                    }
                }

                this.trackData = dataObject;
            }

            this.onGlobalReady('_handleGlobalReadyTrack');
        }
    },

    addTrackEvent: function addTrackEvent(eventName, tagsObject) {
        var trackElement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this;

        if (this.trackOn) {
            var newDate = new Date();
            var newObject = { event: eventName, time: newDate };
            if (tagsObject !== undefined) {
                newObject = Object.assign(tagsObject, newObject);
            }

            if (trackElement.trackTag) {
                newObject.tag = trackElement.trackTag;
            }
            if (trackElement.trackData) {
                var dataObject = trackElement.trackData;
                for (var key in dataObject) {
                    var dataKey = 'data-' + key;
                    if (dataKey in newObject) {
                        this.addDebugWarn('track-data', '\'' + key + ': ' + dataObject[key] + '\' unused because data \'' + newObject[dataKey] + '\' already defined for key \'' + key + '\'', trackElement);
                    } else {
                        newObject[dataKey] = dataObject[key];
                    }
                }
            }

            var info = '';
            for (var _key3 in newObject) {
                var value = newObject[_key3];
                if (!['event', 'time'].includes(_key3)) {
                    info += _key3 + ': ' + ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' ? JSON.stringify(value) : value) + '\r\n';
                }
            }
            var logData = {
                type: 'log',
                text: newDate.toTimeString().slice(0, 8) + ' - ' + newObject.event,
                info: info
            };
            if (this.globalElement.isReady) {
                this.globalElement.trackedEvents.push(newObject);

                if (this.trackLogOn) {
                    this.globalElement.push('trackLogList', logData);
                }
            } else {
                this.tempTrackList.push(newObject);

                if (this.trackLogOn) {
                    this.tempTrackLogList.push(logData);
                }
            }
        }
    },

    addTrackDetail: function addTrackDetail(detail, type) {
        if (this.trackOn) {
            this.globalElement.trackDetail[type].push(detail);
        }
    },

    fireSaveTrack: function fireSaveTrack() {
        if (this.trackOn) {
            this.fire('save-track');
        }
    },

    _handleGlobalReadyTrack: function _handleGlobalReadyTrack() {
        if (this.tempTrackList.length > 0) {
            var _globalElement$tracke;

            (_globalElement$tracke = this.globalElement.trackedEvents).push.apply(_globalElement$tracke, _toConsumableArray(this.tempTrackList));

            if (this.trackLogOn) {
                var _globalElement;

                (_globalElement = this.globalElement).push.apply(_globalElement, ['trackLogList'].concat(_toConsumableArray(this.tempTrackLogList)));
            }
        }
        if (this.trackTag) {
            this.addTrackDetail(this.trackTag, 'tags');
        }
        if (this.trackData) {
            this.addTrackDetail(this.trackData, 'data');
        }
    }
};
var InkdBehavior = [GlobalBehavior, DomBehavior, DebugBehavior, TrackBehavior];

if (typeof Object.assign != 'function') {
    Object.assign = function (target, varArgs) {
        'use strict';

        if (target == null) {
            throw new TypeError('Cannot convert undefined or null to object');
        }

        var to = Object(target);

        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
            for (var _iterator3 = arguments[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var nextSource = _step3.value;


                if (nextSource != null) {
                    for (var nextKey in nextSource) {
                        if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                            to[nextKey] = nextSource[nextKey];
                        }
                    }
                }
            }
        } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                    _iterator3.return();
                }
            } finally {
                if (_didIteratorError3) {
                    throw _iteratorError3;
                }
            }
        }

        return to;
    };
};
Polymer({
    is: 'inkd-console',

    properties: {
        header: {
            type: String,
            value: 'Console'
        },
        list: Array
    },

    observers: ['show(list.splices)'],

    show: function show() {
        var _this = this;

        this._showConsole = true;
        this.async(function () {
            var listContainer = _this.$$('#list-container');
            listContainer.scrollTop = listContainer.scrollHeight;
        });
        this.$.container.classList.remove('hide-console');
    },

    hide: function hide() {
        this._showConsole = false;
        this.$.container.classList.add('hide-console');
    },

    _handleHeaderTap: function _handleHeaderTap() {
        if (this._showConsole) {
            this.hide();
        } else {
            this.show();
        }
    },

    _handleIconTap: function _handleIconTap(_ref) {
        var target = _ref.target;

        target.classList.toggle('hide-info');
    }
});
Polymer({
    is: 'inkd-ml',

    properties: {
        topic: String,
        debug: Boolean,

        track: Boolean,
        userId: String,
        bookmark: Boolean,
        noExitWarn: Boolean
    },

    behaviors: [InkdBehavior],

    listeners: {
        'goto': '_handleGoto',
        'restart': '_handleRestart',
        'track-structure': '_handleTrackStructure',
        'save-track': '_handleSaveTrack',
        'save-remote': '_handleSaveRemote',
        'get-remote': '_handleGetRemote'
    },

    ready: function ready() {
        this.propertyData = {};

        this.uniqueId = 0;

        this._initiateQueryString();

        if (this.topic === undefined) {
            this.topic = document.title;
        }

        if (this.debug) {
            this.debugList = [];
        }

        if (this.track) {
            this._initiateTrack();

            if (this.debug) {
                this._trackLog = true;
                this.trackLogList = [];
            }
        }

        if (this.userId) {
            this._initiateUserId();
        }

        if (this.bookmark) {
            this.listen(window, 'popstate', '_handleHistory');
        }

        if (!this.noExitWarn && !this.debug) {
            this._initiateExitWarn();
        }

        this.isReady = true;
        this.fire('inkdml-ready');
    },

    attached: function attached() {
        this._nestedStructures = Polymer.dom(this).querySelectorAll('inkd-cyoa, inkd-pano');

        var notes = Polymer.dom(document).querySelectorAll('notes');
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
            for (var _iterator4 = notes[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                var element = _step4.value;

                var parent = Polymer.dom(element).parentNode;
                Polymer.dom(parent).removeChild(element);
            }
        } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion4 && _iterator4.return) {
                    _iterator4.return();
                }
            } finally {
                if (_didIteratorError4) {
                    throw _iteratorError4;
                }
            }
        }

        this.fire('inkdml-attached');
        if (this._queryData.node) {
            this._resolveGoto(this._queryData.node);
        }
    },

    _initiateQueryString: function _initiateQueryString() {
        var search = location.search.substring(1);
        if (search) {
            var jsonString = '{"' + search.replace(/&/g, '","').replace(/=/g, '":"') + '"}';
            this._queryData = JSON.parse(jsonString, function (key, value) {
                return key === '' ? value : decodeURIComponent(value);
            });

            for (var key in this._queryData) {
                var match = key.match(/^prop-(.+)/);
                if (match) {
                    var value = this._queryData[key];
                    this.setGlobalProp(match[1], this.parse(value).value);
                }
            }
        } else {
            this._queryData = {};
        }

        if (!this.bookmark) {
            var queryArray = [];
            for (var _key4 in this._queryData) {
                if (_key4 !== 'node') {
                    queryArray.push({ key: _key4, value: this._queryData[_key4] });
                }
            }
            if (queryArray.length > 0) {
                var newQueryString = '?' + queryArray.map(function (data) {
                    return data.key + '=' + data.value;
                }).join('&');
                window.history.replaceState({}, '', window.location.origin + window.location.pathname + newQueryString);
            }
        }
    },

    _initiateTrack: function _initiateTrack() {

        localStorage.removeItem('inkd-tracking-data');

        this._trackSessionID = new Date();
        this.trackDetail = { structures: [], tags: [], data: [] };
        this.trackedEvents = [{ event: 'tracking-initiated', time: new Date() }];

        this._pageActive = document.visibilityState === 'visible' && document.hasFocus();
        this._trackPageStatus();
    },

    _trackPageStatus: function _trackPageStatus() {

        this.listen(document, 'visibilitychange', '_checkPageActive');
        this.listen(window, 'blur', '_checkPageActive');
        this.listen(window, 'focus', '_checkPageActive');
    },

    _checkPageActive: function _checkPageActive() {
        if (this._pageActive) {
            if (document.visibilityState === 'hidden' || !document.hasFocus()) {
                this._pageActive = false;
                this.addTrackEvent('page-inactive');
            }
        } else {
            if (document.visibilityState === 'visible' || document.hasFocus()) {
                this._pageActive = true;
                this.addTrackEvent('page-active');
            }
        }
    },

    _initiateUserId: function _initiateUserId() {
        this._userID = null;
        if (this.userId) {
            var match = this.userId.replace(/\s/g, '').match(/^query:(.+)/);
            if (match) {
                this._userID = this._queryData[match[1]];
            }
        }
    },

    _initiateExitWarn: function _initiateExitWarn() {
        window.onbeforeunload = function (event) {
            var text = 'Leaving this page might cause you to lose data';
            event.returnValue = text;
            return text;
        };
    },

    _handleGoto: function _handleGoto(event) {
        var _this2 = this;

        event.stopPropagation();
        var gotoData = event.detail.gotoData;
        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;

        try {

            for (var _iterator5 = gotoData[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                var _step5$value = _step5.value,
                    element = _step5$value.element,
                    gotos = _step5$value.gotos;
                var _iteratorNormalCompletion6 = true;
                var _didIteratorError6 = false;
                var _iteratorError6 = undefined;

                try {
                    var _loop = function _loop() {
                        var goto = _step6.value;

                        var resolved = _this2._resolveGoto(goto, element);
                        if (!resolved) {
                            element.goto = element.goto.filter(function (g) {
                                return g !== goto;
                            });
                        }
                    };

                    for (var _iterator6 = gotos[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                        _loop();
                    }
                } catch (err) {
                    _didIteratorError6 = true;
                    _iteratorError6 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion6 && _iterator6.return) {
                            _iterator6.return();
                        }
                    } finally {
                        if (_didIteratorError6) {
                            throw _iteratorError6;
                        }
                    }
                }
            }
        } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion5 && _iterator5.return) {
                    _iterator5.return();
                }
            } finally {
                if (_didIteratorError5) {
                    throw _iteratorError5;
                }
            }
        }
    },

    _resolveGoto: function _resolveGoto(goto) {
        var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;

        var gotoTags = ['inkd-node', 'inkd-pano-scene', 'inkd-drop-section', 'inkd-drag-section', 'inkd-mc-section'];

        var value = this.getGlobalPropValue(goto);
        var gotoName = typeof value === 'string' || value === null ? value : goto;

        if (gotoName === null) {
            this.addDebugWarn('goto', '\'' + goto + '\' does not exist yet', element);
            return true;
        }

        var gotoElement = this.getGlobalNameElement(gotoName, gotoTags, 'goto', element);
        if (gotoElement === undefined) {
            return false;
        } else {
            gotoElement.handleInkdmlGoto({ element: element, gotos: [goto] });
            return true;
        }
    },

    _handleRestart: function _handleRestart(event) {
        var _this3 = this;

        var restartTags = ['inkd-cyoa', 'inkd-pano'];

        var restartArray = event.detail.restart,
            eventTarget = event.target;


        var unresolvedRestarts = [];
        var _iteratorNormalCompletion7 = true;
        var _didIteratorError7 = false;
        var _iteratorError7 = undefined;

        try {
            var _loop2 = function _loop2() {
                var restart = _step7.value;

                if (restart === '') {
                    var _iteratorNormalCompletion8 = true;
                    var _didIteratorError8 = false;
                    var _iteratorError8 = undefined;

                    try {
                        for (var _iterator8 = _this3._nestedStructures[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                            var element = _step8.value;

                            element.start();
                        }
                    } catch (err) {
                        _didIteratorError8 = true;
                        _iteratorError8 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion8 && _iterator8.return) {
                                _iterator8.return();
                            }
                        } finally {
                            if (_didIteratorError8) {
                                throw _iteratorError8;
                            }
                        }
                    }
                } else {
                    var restartElement = _this3.getGlobalNameElement(restart, restartTags, 'restart', eventTarget);
                    if (restartElement === undefined) {
                        eventTarget.restart = eventTarget.restart.filter(function (r) {
                            return r !== restart;
                        });
                    } else {
                        restartElement.handleInkdmlRestart();
                    }
                }
            };

            for (var _iterator7 = restartArray[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                _loop2();
            }
        } catch (err) {
            _didIteratorError7 = true;
            _iteratorError7 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion7 && _iterator7.return) {
                    _iterator7.return();
                }
            } finally {
                if (_didIteratorError7) {
                    throw _iteratorError7;
                }
            }
        }
    },

    _handleHistory: function _handleHistory(_ref2) {
        var node = _ref2.state.node;

        this._resolveGoto(node);
    },

    _handleTrackStructure: function _handleTrackStructure(event) {
        event.stopPropagation();
        this.addTrackDetail(event.detail, 'structures');
    },

    _handleSaveTrack: function _handleSaveTrack(event) {
        event.stopPropagation();
        var data = {
            sessionID: this._trackSessionID,
            userID: this._userID,
            userAgent: navigator.userAgent,
            detail: this.trackDetail,
            events: this.trackedEvents
        };
        this._sendPostRequest('/saveInkdmlTracking', data);

        if (this.debug) {
            console.log(data);
        }
    },

    _handleSaveRemote: function _handleSaveRemote(event) {
        event.stopPropagation();
        var detail = event.detail,
            target = event.target;


        if (this._userID) {
            var data = { userID: this._userID, data: detail };
            this._sendPostRequest('/saveInkdmlData', data);
        } else {
            this.addDebugWarn('save-remote', 'User ID required for remote saving', target);
            target.saveRemote = false;
        }
    },

    _handleGetRemote: function _handleGetRemote(event) {
        event.stopPropagation();
        var _event$detail = event.detail,
            keys = _event$detail.keys,
            callback = _event$detail.callback,
            target = event.target;


        if (this._userID) {
            var data = { userID: this._userID, keys: [].concat(keys) };
            this._sendPostRequest('/getInkdmlData', data, target[callback].bind(target));
        } else {
            this.addDebugWarn('save-remote', 'User ID required for remote saving', target);
            target.saveRemote = false;
        }
    },

    _sendPostRequest: function _sendPostRequest(url, dataObject, callback) {
        var xhr = new XMLHttpRequest();
        xhr.open('POST', url);
        xhr.setRequestHeader('Content-Type', 'application/json;charset=UTF-8');

        if (callback) {
            xhr.onreadystatechange = function () {
                if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
                    callback(JSON.parse(xhr.responseText));
                }
            };
        }
        xhr.send(JSON.stringify(dataObject));
    },

    _handleCyoa: function _handleCyoa(_ref3) {
        var detail = _ref3.detail;

        console.log(detail);
    }
});
var NameAttribute = {

    properties: {
        name: String
    },

    ready: function ready() {
        this.onGlobalReady('_setName');
    },

    setBuiltinProps: function setBuiltinProps(propObject) {
        if (this._validName === undefined) {
            this._tempBuiltinProps = Object.assign(this._tempBuiltinProps || {}, propObject);
        } else if (this._validName) {
            this._setBuiltinProps(propObject);
        }
    },

    setBuiltinProp: function setBuiltinProp(key, value) {
        var propObject = {};
        propObject[key] = value;
        this.setBuiltinProps(propObject);
    },

    _setName: function _setName() {
        this._validName = false;
        if (this.name) {
            var tempName = this.name.trim();
            if (/^(?!(?:true|false)$)(?:[\$A-Z_a-z])(?:[\$0-9A-Z_a-z\-])*$/.test(tempName)) {
                var element = this.getGlobalNameElement(tempName);
                if (element === undefined) {
                    this.setGlobalNameElement(tempName, this);
                    this._validName = true;
                    this.name = tempName;

                    this._setBuiltinProps(this._tempBuiltinProps);
                } else {
                    this.addDebugError('name', 'Name \'' + tempName + '\' already used by another element <' + element.tag + '>');
                    this.name = undefined;
                }
            } else {
                this.addDebugError('name', '\'' + this.name + '\' is not a valid name (only letters, numbers and characters $, -, and _ allowed; has to start with a letter, $ or _)');
                this.name = undefined;
            }
        }
    },

    _setBuiltinProps: function _setBuiltinProps(propObject) {
        for (var key in propObject) {
            this.setGlobalProp(this.name + '.' + key, propObject[key], 'builtin-property');
        }
    }
};
var SetPropAttribute = {

    properties: {
        setProp: String
    },

    ready: function ready() {
        this._setPropData = [];
        if (this.setProp) {
            this.onGlobalAttach('_initiateSetProp');
        }
    },

    _initiateSetProp: function _initiateSetProp() {
        var splitResult = this.setProp.match(/(?:\\,|[^,])+/g);
        var _iteratorNormalCompletion9 = true;
        var _didIteratorError9 = false;
        var _iteratorError9 = undefined;

        try {
            for (var _iterator9 = splitResult[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
                var declaration = _step9.value;

                var match = declaration.match(/((?:\\=|\\:|[^=:])*)(=|:)((?:\\=|\\:|[^=:])*)/);

                if (!match) {
                    this.addDebugError('set-prop', 'Property assigner (= or :) missing in \'' + declaration + '\'');
                } else {
                    var key = match[1].trim();
                    var assigner = match[2];
                    var value = match[3].trim();
                    var data = { key: key, assigner: assigner, value: value };

                    if (key === '') {
                        this.addDebugError('set-prop', 'No property name specified in \'' + declaration + '\'');
                        break;
                    } else if (/^(?!(?:true|false)$)(?:[\$A-Z_a-z])(?:[\$0-9A-Z_a-z\-])*$/.test(key)) {
                        var _parse = this.parse(key),
                            keyValue = _parse.value,
                            keyType = _parse.type;

                        if (keyType === 'element') {
                            this.addDebugError('set-prop', 'Property name \'' + key + '\' already used in \'name\' attribute of an <' + keyValue.tagName.toLowerCase() + '> element');
                            break;
                        } else if (keyType === 'builtin-property') {
                            this.addDebugError('set-prop', 'Value of \'' + key + ' cannot be changed because it is a built-in property\'');
                            break;
                        }
                    } else {
                        this.addDebugError('set-prop', '\'' + key + '\' is not a valid property name (only letters, numbers and characters $, -, and _ allowed; has to start with a letter, $ or _)');
                        break;
                    }

                    if (assigner === ':') {
                        if (value.trim() === 'toggle') {
                            data.operator = 'toggle';
                        } else if (/^[+\-*/]/.test(value)) {
                            data.operator = value.charAt(0);
                            value = value.slice(1).trim();
                        } else {
                            var _match2 = value.replace(/\s/g, '').match(/^random\((.*)\|(.*)\)$/);
                            if (_match2) {
                                data.operator = 'random';
                                value = [_match2[1], _match2[2]];
                            } else {
                                this.addDebugError('set-prop', '\'' + value + '\' is not a valid operation');
                                break;
                            }
                        }
                        data.value = value;
                    }

                    var validValues = true;
                    var _iteratorNormalCompletion10 = true;
                    var _didIteratorError10 = false;
                    var _iteratorError10 = undefined;

                    try {
                        for (var _iterator10 = [].concat(value)[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
                            var val = _step10.value;

                            if (val === '') {
                                this.addDebugError('set-prop', 'No property value specified in \'' + declaration + '\'');
                                validValues = false;
                                break;
                            }

                            var _parse2 = this.parse(val),
                                parsedValue = _parse2.value,
                                parsedType = _parse2.type;

                            if (parsedType === 'element') {
                                this.addDebugError('set-prop', '\'' + val + '\' cannot be used in property assignment because it refers to \'name\' attribute of an <' + parsedValue.tagName.toLowerCase() + '> element');
                                validValues = false;
                                break;
                            }
                        }
                    } catch (err) {
                        _didIteratorError10 = true;
                        _iteratorError10 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion10 && _iterator10.return) {
                                _iterator10.return();
                            }
                        } finally {
                            if (_didIteratorError10) {
                                throw _iteratorError10;
                            }
                        }
                    }

                    if (!validValues) {
                        break;
                    }
                    this._setPropData.push(data);
                }
            }
        } catch (err) {
            _didIteratorError9 = true;
            _iteratorError9 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion9 && _iterator9.return) {
                    _iterator9.return();
                }
            } finally {
                if (_didIteratorError9) {
                    throw _iteratorError9;
                }
            }
        }
    },

    handleSetProp: function handleSetProp() {
        var _iteratorNormalCompletion11 = true;
        var _didIteratorError11 = false;
        var _iteratorError11 = undefined;

        try {
            for (var _iterator11 = this._setPropData[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
                var _step11$value = _step11.value,
                    key = _step11$value.key,
                    assigner = _step11$value.assigner,
                    value = _step11$value.value,
                    _operator = _step11$value.operator;

                if (assigner === ':') {
                    if (_operator === 'toggle') {
                        this._toggleBoolean(key);
                    } else if (['+', '-', '*', '/'].includes(_operator)) {
                        var parsedValue = this.parse(value).value;
                        if (typeof parsedValue === 'number') {
                            this._operateNumber(key, _operator, value);
                        } else if (_operator === '+' && typeof parsedValue === 'string') {
                            this._concatString(key, value);
                        } else {
                            this.addDebugError('set-prop', '\'' + value + '\' is not a valid value for \'' + _operator + '\' operation');
                        }
                    } else if (_operator === 'random') {
                        this._setRandomNumber.apply(this, [key].concat(_toConsumableArray(value)));
                    }
                } else {
                    this._assignValue(key, value);
                }
            }
        } catch (err) {
            _didIteratorError11 = true;
            _iteratorError11 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion11 && _iterator11.return) {
                    _iterator11.return();
                }
            } finally {
                if (_didIteratorError11) {
                    throw _iteratorError11;
                }
            }
        }
    },

    _toggleBoolean: function _toggleBoolean(key) {
        var oldValue = this.getGlobalPropValue(key);
        if (oldValue === undefined) {
            oldValue = false;
            this.addDebugWarn('set-prop', '\'' + key + '\' does not have an initial value. (Default of \'false\' used for \'toggle\' operation)');
        }

        if (typeof oldValue === 'boolean') {
            this.setGlobalProp(key, !oldValue);
        } else {
            this.addDebugError('set-prop', 'Operation \'toggle\' is not valid because \'' + key + '\' is not a Boolean');
        }
    },

    _operateNumber: function _operateNumber(key, operator, value) {
        var oldValue = this.getGlobalPropValue(key);
        if (oldValue === undefined) {
            oldValue = 0;
            this.addDebugWarn('set-prop', '\'' + key + '\' does not have an initial value. (Default of 0 used for \'' + operator + '\' operation)');
        }

        var parsedValue = this.parse(value).value;
        if (typeof oldValue === 'number') {
            switch (operator) {
                case '+':
                    this.setGlobalProp(key, oldValue + parsedValue);
                    break;
                case '-':
                    this.setGlobalProp(key, oldValue - parsedValue);
                    break;
                case '*':
                    this.setGlobalProp(key, oldValue * parsedValue);
                    break;
                case '/':
                    this.setGlobalProp(key, oldValue / parsedValue);
                    break;
            }
        } else {
            this.addDebugError('set-prop', 'Type mismatch in \'' + operator + '\' operation. \'' + key + '\' is a ' + (typeof oldValue === 'undefined' ? 'undefined' : _typeof(oldValue)) + ' and \'' + value + '\' is a number');
        }
    },

    _concatString: function _concatString(key, value) {
        var oldValue = this.getGlobalPropValue(key);
        if (oldValue === undefined) {
            oldValue = '';
            this.addDebugWarn('set-prop', '\'' + key + '\' does not have an initial value. (Default of \'\' used for \'' + operator + '\' operation)');
        }

        var parsedValue = this.parse(value).value;
        if (typeof oldValue == 'string') {
            this.setGlobalProp(key, oldValue + parsedValue);
        } else {
            this.addDebugError('set-prop', 'Type mismatch in \'+\' operation. \'' + key + '\' is a ' + (typeof oldValue === 'undefined' ? 'undefined' : _typeof(oldValue)) + ' and \'' + value + '\' is a string');
        }
    },

    _setRandomNumber: function _setRandomNumber(key, start, end) {
        var startValue = this.parse(start).value;
        var endValue = this.parse(end).value;

        if (typeof startValue !== 'number') {
            this.addDebugError('set-prop', 'Operation \'random\' is not valid because \'' + start + '\' is not a number');
        } else if (typeof endValue !== 'number') {
            this.addDebugError('set-prop', 'Operation \'random\' is not valid because \'' + end + '\' is not a number');
        } else if (startValue === endValue) {
            this.addDebugError('set-prop', 'Upper limit and lower limit cannot be the same value for random number generation in \'random(' + start + '|' + end + ')\'');
        } else {
            var lowerLimit = Math.min(startValue, endValue);
            var upperLimit = Math.max(startValue, endValue);
            this.setGlobalProp(key, Math.floor(Math.random() * (upperLimit - lowerLimit + 1) + lowerLimit));
        }
    },

    _assignValue: function _assignValue(key, value) {
        var _parse3 = this.parse(value),
            parsedValue = _parse3.value,
            parsedType = _parse3.type;

        if (parsedType === 'error') {
            this.addDebugError('set-prop', '\'' + value + '\' is not a valid property value');
        } else {
            this.setGlobalProp(key, parsedValue);
        }
    }
};
Polymer({
    is: 'inkd-include',

    properties: {
        content: String
    },

    behaviors: [InkdBehavior],

    ready: function ready() {
        if (this.content === undefined) {
            this.addDebugError('content', 'No <inkd-content> name specified');
        } else {
            this._contentElement = this.getGlobalNameElement(this.content, 'inkd-content');

            if (this._contentElement === undefined) {
                this.onGlobalEvent(this.content + '-content-ready', '_getContent');
                this.onGlobalAttach('_checkContent');
            } else {
                this._appendContent();
            }
        }
    },

    _getContent: function _getContent(_ref4) {
        var content = _ref4.detail.content;

        this._contentElement = content;
        this._appendContent();
    },

    _appendContent: function _appendContent() {
        Polymer.dom(this.domParent).insertBefore(this._contentElement.contentFragment, this);
        this._contentElement.handleSetProp();

        this.domRemove();
    },

    _checkContent: function _checkContent() {
        if (this.content !== undefined && this._contentElement === undefined) {
            this.addDebugError('content', '<inkd-content> with name \'' + this.content + '\' does not exist');
        }
    }
});
Polymer({
    is: 'inkd-content',

    behaviors: [InkdBehavior, NameAttribute, SetPropAttribute],

    ready: function ready() {
        this.setBuiltinProp('contentHtml', Polymer.dom(this).innerHTML);

        this.onGlobalReady('_setContent');
    },

    _setContent: function _setContent() {
        this.contentFragment = document.createDocumentFragment();

        var childNodes = Polymer.dom(this).childNodes;
        var _iteratorNormalCompletion12 = true;
        var _didIteratorError12 = false;
        var _iteratorError12 = undefined;

        try {
            for (var _iterator12 = childNodes[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
                var child = _step12.value;

                this.contentFragment.appendChild(child);
            }
        } catch (err) {
            _didIteratorError12 = true;
            _iteratorError12 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion12 && _iterator12.return) {
                    _iterator12.return();
                }
            } finally {
                if (_didIteratorError12) {
                    throw _iteratorError12;
                }
            }
        }

        this.fireGlobalEvent(this.name + '-content-ready', { content: this });
    }
});
var ConditionBehavior = {
    observers: ['handleConditionChange(_conditionTrue)'],

    ready: function ready() {
        this._conditionData = [];
    },

    attached: function attached() {
        if (!this._initiated && this._conditionData.length > 0) {
            this._addConditionListeners();
            this._checkCondition();
            this._initiated = true;
        }
    },

    initiateCondition: function initiateCondition(attr) {
        this._conditionAttribute = attr;
        this._conditionOperator = null;

        var string = this[attr];
        var andRegex = /\s(?:and|AND|&&)\s/;
        var orRegex = /\s(?:or|OR|\|\|)\s/;
        if (andRegex.test(string) && orRegex.test(string)) {
            this.addDebugError(attr, 'Both \'AND\' and \'OR\' cannot be used at the same time');
        } else {
            var conditionArray = void 0;
            if (andRegex.test(string)) {
                conditionArray = string.split(andRegex);
                this._conditionOperator = 'and';
            } else if (orRegex.test(string)) {
                conditionArray = string.split(orRegex);
                this._conditionOperator = 'or';
            } else {
                conditionArray = [string];
            }

            var _iteratorNormalCompletion13 = true;
            var _didIteratorError13 = false;
            var _iteratorError13 = undefined;

            try {
                for (var _iterator13 = conditionArray[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
                    var condition = _step13.value;

                    var match = condition.match(/\s*([^><!=\s]*)\s*(>=|<=|<|>|!=|==|=|\sis\s|\sIS\s)\s*(\S*)\s*/);
                    if (match) {
                        this._conditionData.push({
                            left: match[1],
                            operator: match[2],
                            right: match[3]
                        });
                    } else {
                        this.addDebugError(attr, 'Condition (=, ==, !=, <, >, <=, >=) missing in \'' + condition + '\'');
                    }
                }
            } catch (err) {
                _didIteratorError13 = true;
                _iteratorError13 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion13 && _iterator13.return) {
                        _iterator13.return();
                    }
                } finally {
                    if (_didIteratorError13) {
                        throw _iteratorError13;
                    }
                }
            }
        }
    },

    _addConditionListeners: function _addConditionListeners() {
        var _iteratorNormalCompletion14 = true;
        var _didIteratorError14 = false;
        var _iteratorError14 = undefined;

        try {
            for (var _iterator14 = this._conditionData[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
                var _step14$value = _step14.value,
                    left = _step14$value.left,
                    _operator2 = _step14$value.operator,
                    right = _step14$value.right;
                var _arr = [left, right];


                for (var _i = 0; _i < _arr.length; _i++) {
                    var value = _arr[_i];
                    var _parse4 = this.parse(value),
                        parsedValue = _parse4.value,
                        parsedType = _parse4.type;

                    if (parsedType === 'error') {
                        this.addDebugError(this._conditionAttribute, '\'' + value + '\' is not a valid condition value');
                    } else if (parsedType === 'element') {
                        this.addDebugError(this._conditionAttribute, '\'' + value + '\' cannot be used in condition because it refers to \'name\' attribute of an <' + parsedValue.tagName.toLowerCase() + '> element');
                    } else if (parsedType === 'user-property' || parsedType === 'builtin-property') {
                        this.onGlobalChange(value, '_checkCondition');
                    }
                }
            }
        } catch (err) {
            _didIteratorError14 = true;
            _iteratorError14 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion14 && _iterator14.return) {
                    _iterator14.return();
                }
            } finally {
                if (_didIteratorError14) {
                    throw _iteratorError14;
                }
            }
        }
    },

    _checkCondition: function _checkCondition() {
        var conditionIsTrue = false;
        var _iteratorNormalCompletion15 = true;
        var _didIteratorError15 = false;
        var _iteratorError15 = undefined;

        try {
            for (var _iterator15 = this._conditionData[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
                var _step15$value = _step15.value,
                    left = _step15$value.left,
                    _operator3 = _step15$value.operator,
                    right = _step15$value.right;


                var leftValue = this.parse(left).value;
                var rightValue = this.parse(right).value;

                if (['>=', '<=', '>', '<'].includes(_operator3)) {
                    if (isNaN(leftValue)) {
                        this.addDebugError(this._conditionAttribute, 'Comparison \'' + _operator3 + '\' is not valid because \'' + left + '\' is not a number');
                    } else if (isNaN(rightValue)) {
                        this.addDebugError(this._conditionAttribute, 'Comparison \'' + _operator3 + '\' is not valid because \'' + right + '\' is not a number');
                    } else {
                        switch (_operator3) {
                            case '>=':
                                conditionIsTrue = leftValue >= rightValue;
                                break;
                            case '<=':
                                conditionIsTrue = leftValue <= rightValue;
                                break;
                            case '>':
                                conditionIsTrue = leftValue > rightValue;
                                break;
                            case '<':
                                conditionIsTrue = leftValue < rightValue;
                                break;
                        }
                    }
                } else if (['!=', '==', '=', 'is', 'IS'].includes(_operator3)) {
                    switch (_operator3) {
                        case '!=':
                            conditionIsTrue = leftValue !== rightValue;
                            break;
                        case '==':
                        case '=':
                        case 'is':
                        case 'IS':
                            conditionIsTrue = leftValue === rightValue;
                            break;
                    }
                }

                if (this._conditionOperator === 'and' && !conditionIsTrue || this._conditionOperator === 'or' && conditionIsTrue) {
                    break;
                }
            }
        } catch (err) {
            _didIteratorError15 = true;
            _iteratorError15 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion15 && _iterator15.return) {
                    _iterator15.return();
                }
            } finally {
                if (_didIteratorError15) {
                    throw _iteratorError15;
                }
            }
        }

        this._conditionTrue = conditionIsTrue;
    }
};
Polymer({
    is: 'inkd-if',

    properties: {
        rule: String
    },

    behaviors: [InkdBehavior, ConditionBehavior, SetPropAttribute],

    ready: function ready() {
        this._initiateElse();

        this._ruleTrue = false;
        if (this.rule === undefined) {
            this.addDebugError('rule', 'No condition specified');
        } else {
            this.initiateCondition('rule');
        }
    },

    handleConditionChange: function handleConditionChange(conditionTrue) {
        this._ruleTrue = conditionTrue;
        if (conditionTrue) {
            this.handleSetProp();
            if (this._elseElement) {
                this._elseElement.domRemove();
            }
        } else {
            if (this._elseElement) {
                this._elseElement.domAdd();
                this.handleSetProp();
            }
        }
    },

    _initiateElse: function _initiateElse() {
        var elseTags = Polymer.dom(this).children.filter(function (node) {
            return node.tagName === 'INKD-ELSE';
        });
        if (elseTags !== null) {
            this._elseElement = elseTags[0];
        }

        if (elseTags.length > 1) {
            var unused = [];
            var _iteratorNormalCompletion16 = true;
            var _didIteratorError16 = false;
            var _iteratorError16 = undefined;

            try {
                for (var _iterator16 = elseTags[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
                    var element = _step16.value;

                    element.domRemove();
                    unused.push(element.tag);
                }
            } catch (err) {
                _didIteratorError16 = true;
                _iteratorError16 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion16 && _iterator16.return) {
                        _iterator16.return();
                    }
                } finally {
                    if (_didIteratorError16) {
                        throw _iteratorError16;
                    }
                }
            }

            this.addDebugWarn(null, '\'' + unused.join('\', \'') + '\' unused because only one <inkd-else> allowed for <inkd-if>');
        }
    }
});
Polymer({
    is: 'inkd-else',

    behaviors: [InkdBehavior, SetPropAttribute],

    ready: function ready() {
        this.enforceDirectAncestor('inkd-if');
    }
});
Polymer({
    is: 'inkd-value',

    properties: {
        prop: String
    },

    behaviors: [InkdBehavior],

    ready: function ready() {
        this.onGlobalAttach('_initiate');
    },

    attached: function attached() {
        if (this.getGlobalPropValue(this.prop) == undefined) {
            this.addDebugError('prop', 'Property \'' + this.prop + '\' does not exist');
        }
    },

    _initiate: function _initiate() {
        var data = this.getGlobalProp(this.prop);
        if (data !== undefined && data.propType === 'element') {
            this.addDebugError('prop', '\'' + this.prop + '\' refers to \'name\' attribute of an \'<' + data.propValue.tagName.toLowerCase() + '>\' element');
        } else {
            this._value = data ? data.propValue : undefined;
            this.onGlobalChange(this.prop, '_updateValue');
        }
    },

    _updateValue: function _updateValue(_ref5) {
        var value = _ref5.detail.value;

        this._value = value;
    }
});
var NavigateEvent = {

    properties: {
        goto: String,
        restart: {
            type: String,
            flagAllowed: true
        }
    },

    ready: function ready() {
        this.goto = this.goto === undefined ? [] : this.goto.replace(/\s/g, '').split(',');

        if (this.restart === undefined) {
            this.restart = [];
        } else if (this.restart === '') {
            this.restart = [''];
        } else {
            this.restart = this.restart.replace(/\s/g, '').split(',');
        }
    },

    fireNavigate: function fireNavigate() {
        var gotos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.goto;
        var restart = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.restart;

        if (gotos.length > 0) {
            this.fire('goto', { gotoData: [{ element: this, gotos: gotos }] });
        }

        if (restart.length > 0) {
            this.fire('restart', { restart: restart });
        }
    }
};
var ActionAttributes = {
    properties: {
        playAudio: String,
        pauseAudio: String,
        restartAudio: String,
        setAudioVolume: String,
        playVideo: String,
        pauseVideo: String,
        restartVideo: String,
        setVideoVolume: String,
        showModal: String,
        hideModal: String,
        saveTrack: Boolean
    },

    ready: function ready() {
        this.onGlobalAttach('_initiateActions');
    },

    handleActions: function handleActions() {
        for (var attr in this._actionData) {
            var propData = this._actionData[attr];
            if (propData.elementsData) {
                var elementsData = propData.elementsData;
                for (var name in elementsData) {
                    var _elementsData$name = elementsData[name],
                        element = _elementsData$name.element,
                        args = _elementsData$name.args;

                    element[propData.handler].apply(element, args);
                }
            }
        }

        if (this.saveTrack) {
            this.fireSaveTrack();
        }
    },

    undoActions: function undoActions() {
        for (var attr in this._actionData) {
            var propData = this._actionData[attr];
            if (propData.undoHandler || propData.undoArguments) {
                if (propData.elementsData) {
                    var elementsData = propData.elementsData;
                    for (var name in elementsData) {
                        var _elementsData$name2 = elementsData[name],
                            element = _elementsData$name2.element,
                            args = _elementsData$name2.args;

                        if (propData.undoArguments) {
                            element[propData.handler].apply(element, undoArgs);
                        } else {
                            element[propData.undoHandler]();
                        }
                    }
                }
            }
        }
    },

    _initiateActions: function _initiateActions() {
        this._actionData = {
            'play-audio': { tags: ['inkd-audio'], handler: 'play', undoHandler: 'pause' },
            'pause-audio': { tags: ['inkd-audio'], handler: 'pause', undoHandler: 'play' },
            'restart-audio': { tags: ['inkd-audio'], handler: 'restart', undoHandler: 'pause' },
            'set-audio-volume': { tags: ['inkd-audio'], handler: 'setVolume', arguments: [{ desc: 'volume', min: 0, max: 1, required: true }], undoArguments: ['volume'] },

            'play-video': { tags: ['inkd-video'], handler: 'play', undoHandler: 'pause' },
            'pause-video': { tags: ['inkd-video'], handler: 'pause', undoHandler: 'play' },
            'restart-video': { tags: ['inkd-video'], handler: 'restart', undoHandler: 'pause' },
            'set-video-volume': { tags: ['inkd-video'], handler: 'setVolume', arguments: [{ desc: 'volume', min: 0, max: 1, required: true }], undoArguments: ['volume'] },

            'show-modal': { tags: ['inkd-modal'], handler: 'show', undoHandler: 'hide' },
            'hide-modal': { tags: ['inkd-modal'], handler: 'hide', undoHandler: 'show' }
        };

        for (var attr in this._actionData) {
            var _prop2 = attr.replace(/-([a-z])/g, function (x) {
                return x[1].toUpperCase();
            });

            if (this[_prop2]) {
                this._actionData[attr].elementsData = {};

                var splitResult = this[_prop2].replace(/\s/g, '').split(',');
                var _iteratorNormalCompletion17 = true;
                var _didIteratorError17 = false;
                var _iteratorError17 = undefined;

                try {
                    for (var _iterator17 = splitResult[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
                        var splitPart = _step17.value;

                        var params = splitPart.split(':');
                        var name = params[0];
                        params.shift();

                        var element = this._getElement(name, attr);
                        if (element !== undefined) {
                            var args = this._getArguments(params, attr);
                            if (args !== undefined) {
                                var _undoArgs = this._getUndoArguments(name, attr);
                                this._actionData[attr].elementsData[name] = { element: element, args: args, undoArgs: _undoArgs };
                            }
                        }
                    }
                } catch (err) {
                    _didIteratorError17 = true;
                    _iteratorError17 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion17 && _iterator17.return) {
                            _iterator17.return();
                        }
                    } finally {
                        if (_didIteratorError17) {
                            throw _iteratorError17;
                        }
                    }
                }
            }
        }
    },

    _getElement: function _getElement(name, attr) {
        var propData = this._actionData[attr];
        if (propData.elementsData.hasOwnProperty(name)) {
            var tag = propData.elementsData[name].element.tagName.toLowerCase();
            this.addDebugWarn(attr, '<' + tag + '> name \'' + name + '\' repeated');
        } else {
            var element = this.getGlobalNameElement(name, propData.tags, attr);
            if (element !== undefined) {
                return element;
            }
        }
    },

    _getArguments: function _getArguments(params, attr) {
        var propData = this._actionData[attr];
        if (propData.arguments) {
            var numArgs = propData.arguments.length;
            for (var i = 0; i < numArgs; i++) {
                var argData = propData.arguments[i];
                var value = params[i];

                if (value === undefined || value === '') {
                    if (argData.required) {
                        this.addDebugError(attr, 'Value not specified for ' + argData.desc);
                        return;
                    }
                } else if (isNaN(value) || argData.min !== undefined && value < argData.min || argData.max !== undefined && value > argData.max) {
                    var descString = argData.desc === undefined ? '' : argData.desc + ' ';
                    var ruleString = void 0;

                    if (argData.min !== undefined && argData.max !== undefined) {
                        ruleString = '(has to be a number between ' + argData.min + ' and ' + argData.max + ')';
                    } else if (argData.min !== undefined) {
                        ruleString = '(has to be a number greater than ' + argData.min + ')';
                    } else if (argData.max !== undefined) {
                        ruleString = '(has to be a number less than ' + argData.max + ')';
                    } else {
                        ruleString = '(has to be a number)';
                    }

                    this.addDebugError(attr, '\'' + value + '\' is not a valid ' + descString + 'value ' + ruleString);

                    return;
                }
            }

            if (params.length > numArgs) {
                this.addDebugWarn(attr, params.slice(numArgs).join('\', \'') + '\' unused because \'' + attr + '\' takes only name of element (<' + propData.tags.join('>, <') + '>) and ' + numArgs + ' other argument' + (numArgs > 1 ? 's' : ''));
            }
            return params.slice(0, numArgs);
        } else {
            if (params.length > 0) {
                this.addDebugWarn(attr, '\'' + params.join('\', \'') + '\' unused because only name of element (<' + propData.tags.join('>, <') + '>) is needed');
            }
            return null;
        }
    },

    _getUndoArguments: function _getUndoArguments(name, attr) {
        var propData = this._actionData[attr];
        if (propData.undoArguments) {
            var _undoArgs2 = [];
            var _iteratorNormalCompletion18 = true;
            var _didIteratorError18 = false;
            var _iteratorError18 = undefined;

            try {
                for (var _iterator18 = propData.undoArguments[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {
                    var undoProp = _step18.value;

                    _undoArgs2.push(this.getGlobalPropValue(name + '.' + undoProp));
                }
            } catch (err) {
                _didIteratorError18 = true;
                _iteratorError18 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion18 && _iterator18.return) {
                        _iterator18.return();
                    }
                } finally {
                    if (_didIteratorError18) {
                        throw _iteratorError18;
                    }
                }
            }

            return _undoArgs2;
        }
        return null;
    }
};
var ButtonBehaviorImpl = {
    properties: {
        disabled: {
            type: String,
            flagAllowed: true,
            reflectToAttribute: true
        },
        validate: {
            type: String,
            flagAllowed: true
        },
        reset: {
            type: String,
            flagAllowed: true
        },
        reload: Boolean,
        tabindex: {
            type: Number,
            min: -1,
            max: 32767,
            value: 0,
            desc: 'tab order',
            reflectToAttribute: true
        }
    },

    ready: function ready() {
        this.setBuiltinProp('disabled', this.disabled !== undefined);
        if (this.disabled !== undefined) {
            if (this.disabled === '') {
                this.disabled = true;
            } else {
                this.initiateCondition('disabled');
            }
        }

        this._initialTabIndex = this.tabindex;

        this.onGlobalAttach('_initiate');
    },

    click: function click(callbackFunction) {
        if (!this.disabled) {
            var _iteratorNormalCompletion19 = true;
            var _didIteratorError19 = false;
            var _iteratorError19 = undefined;

            try {
                for (var _iterator19 = this._validateElements[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {
                    var element = _step19.value;

                    element.validate();
                }
            } catch (err) {
                _didIteratorError19 = true;
                _iteratorError19 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion19 && _iterator19.return) {
                        _iterator19.return();
                    }
                } finally {
                    if (_didIteratorError19) {
                        throw _iteratorError19;
                    }
                }
            }

            var _iteratorNormalCompletion20 = true;
            var _didIteratorError20 = false;
            var _iteratorError20 = undefined;

            try {
                for (var _iterator20 = this._resetElements[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {
                    var _element = _step20.value;

                    _element.reset();
                }
            } catch (err) {
                _didIteratorError20 = true;
                _iteratorError20 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion20 && _iterator20.return) {
                        _iterator20.return();
                    }
                } finally {
                    if (_didIteratorError20) {
                        throw _iteratorError20;
                    }
                }
            }

            this.handleSetProp();
            this.handleActions();

            this.fireNavigate();

            if (this.reload) {
                window.onbeforeunload = function () {
                    return null;
                };
                location.reload();
            }

            callbackFunction.call(this);
        }
    },

    handleConditionChange: function handleConditionChange(conditionTrue) {
        this.disabled = conditionTrue;
        this.setBuiltinProp('disabled', conditionTrue);
        this.tabindex = conditionTrue ? false : this._initialTabIndex;
    },

    _initiate: function _initiate() {
        if (this.validate === undefined) {
            this.validate = [];
        } else if (this.validate === '') {
            this.validate = [''];
        } else {
            this.validate = this.validate.replace(/\s/g, '').split(',');
        }

        if (this.reset === undefined) {
            this.reset = [];
        } else if (this.reset === '') {
            this.reset = [''];
        } else {
            this.reset = this.reset.replace(/\s/g, '').split(',');
        }

        var repeated = this.reset.filter(function (name) {
            return this.validate.includes(name);
        }.bind(this));
        if (repeated.length > 0) {
            this.addDebugWarn(null, '\'' + repeated.join('\', \'') + '\' unused in \'reset\' because already used in \'validate\'');
            this.reset = this.reset.filter(function (name) {
                return !repeated.includes(name);
            });
        }

        this._validateElements = this._getTaskElements('validate');
        this._resetElements = this._getTaskElements('reset');
    },

    _getTaskElements: function _getTaskElements(attr) {
        var taskTags = ['inkd-textarea', 'inkd-dd', 'inkd-drop-section', 'inkd-droptarget', 'inkd-mc', 'inkd-mc-section', 'inkd-mc-question'];

        var nameArray = this[attr];
        var taskElements = [];
        var _iteratorNormalCompletion21 = true;
        var _didIteratorError21 = false;
        var _iteratorError21 = undefined;

        try {
            for (var _iterator21 = nameArray[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {
                var name = _step21.value;

                if (name === '') {
                    var parent = Polymer.dom(this).parentNode;
                    while (parent !== null && parent.tagName !== 'HTML') {
                        if (taskTags.includes(parent.tagName.toLowerCase())) {
                            taskElements.push(parent);
                            break;
                        } else {
                            parent = Polymer.dom(parent).parentNode;
                        }
                    }

                    if (parent === null || parent.tagName === 'HTML') {
                        this.addDebugError(attr, 'No parent task element (<' + taskTags.join('>, <') + '>) found');
                    }
                } else {
                    var element = this.getGlobalNameElement(name, taskTags, attr);
                    if (element !== undefined) {
                        taskElements.push(element);
                    }
                }
            }
        } catch (err) {
            _didIteratorError21 = true;
            _iteratorError21 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion21 && _iterator21.return) {
                    _iterator21.return();
                }
            } finally {
                if (_didIteratorError21) {
                    throw _iteratorError21;
                }
            }
        }

        return taskElements;
    }
};

var ButtonBehavior = [InkdBehavior, ConditionBehavior, NameAttribute, SetPropAttribute, NavigateEvent, ActionAttributes, ButtonBehaviorImpl];
Polymer({
    is: 'inkd-button',

    behaviors: [ButtonBehavior],

    listeners: {
        'tap': '_handleTap',
        'keypress': '_handleKeypress'
    },

    _handleTap: function _handleTap() {
        this.click(this._clickCallback);
    },

    _handleKeypress: function _handleKeypress(_ref6) {
        var keyCode = _ref6.keyCode;

        if (keyCode === 13) {
            this.click(this._clickCallback);
        }
    },

    _clickCallback: function _clickCallback() {
        this.addTrackEvent('button-click', { button: Polymer.dom(this).textContent.replace(/^\s+|\s+$/g, '') });
    }
});
Polymer({
    is: 'inkd-action',

    behaviors: [ButtonBehavior],

    listeners: {
        'tap': '_handleTap',
        'keypress': '_handleKeypress'
    },

    _handleTap: function _handleTap() {
        this.click(this._clickCallback);
    },

    _handleKeypress: function _handleKeypress(_ref7) {
        var keyCode = _ref7.keyCode;

        if (keyCode === 13) {
            this.click(this._clickCallback);
        }
    },

    _clickCallback: function _clickCallback() {
        this.addTrackEvent('button-click', { button: Polymer.dom(this).textContent.replace(/^\s+|\s+$/g, '') });
    }
});
var NavigateHandler = {

    listeners: {
        'goto': '_handleGoto',
        'restart': '_handleRestart'
    },

    ready: function ready() {
        this._gotoElements = {};
    },

    initiateNavigate: function initiateNavigate(gotoElements, restartElementName, nestedTagsArray) {
        this._gotoElements = gotoElements;
        for (var key in gotoElements) {
            this.listen(gotoElements[key], 'goto', '_handleGoto');
        }

        this._restartElementName = restartElementName;

        this._nestedStructures = Polymer.dom(this).querySelectorAll(nestedTagsArray.join(', '));

        var data = {},
            names = Object.keys(gotoElements);
        data[this.tagName.toLowerCase().match(/[a-z]+$/)[0]] = this.name;
        data[gotoElements[names[0]].tagName.toLowerCase().match(/[a-z]+$/)[0] + 's'] = names;
        this.fire('track-structure', data);
    },

    handleInkdmlRestart: function handleInkdmlRestart() {
        this._resolveRestart();
    },

    _handleGoto: function _handleGoto(event) {
        var gotoData = event.detail.gotoData;


        var navigateGotoData = { navigate: null, unresolved: [] };
        var _iteratorNormalCompletion22 = true;
        var _didIteratorError22 = false;
        var _iteratorError22 = undefined;

        try {
            for (var _iterator22 = gotoData[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {
                var _step22$value = _step22.value,
                    element = _step22$value.element,
                    gotos = _step22$value.gotos;

                var elementData = { navigate: null, unresolved: [] };
                var _iteratorNormalCompletion23 = true;
                var _didIteratorError23 = false;
                var _iteratorError23 = undefined;

                try {
                    for (var _iterator23 = gotos[Symbol.iterator](), _step23; !(_iteratorNormalCompletion23 = (_step23 = _iterator23.next()).done); _iteratorNormalCompletion23 = true) {
                        var _goto = _step23.value;

                        var value = this.getGlobalPropValue(_goto);
                        var gotoName = typeof value === 'string' || value === null ? value : _goto;

                        if (gotoName === null) {
                            this.addDebugWarn('goto', '\'' + _goto + '\' does not exist yet', element);
                        } else if (this._gotoElements.hasOwnProperty(gotoName)) {
                            if (elementData.navigate === null) {
                                elementData.navigate = gotoName;
                                elementData.navigateGoto = _goto;
                            } else {
                                this.addDebugWarn('goto', '\'' + _goto + '\' unused because \'' + elementData.navigateGoto + '\' already exists in the same <' + this.tagName.toLowerCase() + '>', element);
                            }
                        } else {
                            elementData.unresolved.push(_goto);
                        }
                    }
                } catch (err) {
                    _didIteratorError23 = true;
                    _iteratorError23 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion23 && _iterator23.return) {
                            _iterator23.return();
                        }
                    } finally {
                        if (_didIteratorError23) {
                            throw _iteratorError23;
                        }
                    }
                }

                if (elementData.navigate !== null && navigateGotoData.navigate === null) {
                    navigateGotoData.navigate = elementData.navigate;
                }
                if (elementData.unresolved.length > 0) {
                    navigateGotoData.unresolved.push({ element: element, gotos: elementData.unresolved });
                }
            }
        } catch (err) {
            _didIteratorError22 = true;
            _iteratorError22 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion22 && _iterator22.return) {
                    _iterator22.return();
                }
            } finally {
                if (_didIteratorError22) {
                    throw _iteratorError22;
                }
            }
        }

        if (navigateGotoData.navigate !== null) {
            this.gotoNavigate(navigateGotoData.navigate);
            this.updateGlobalHistory(navigateGotoData.navigate);

            if (!this.isAttached) {
                this.fire('detached-navigate');
            }
        }

        if (navigateGotoData.unresolved.length > 0) {
            event.detail.gotoData = navigateGotoData.unresolved;
        } else {
            event.stopPropagation();
        }
    },

    _handleRestart: function _handleRestart(event) {
        var restartArray = event.detail.restart;


        var unresolvedRestarts = [];
        var _iteratorNormalCompletion24 = true;
        var _didIteratorError24 = false;
        var _iteratorError24 = undefined;

        try {
            for (var _iterator24 = restartArray[Symbol.iterator](), _step24; !(_iteratorNormalCompletion24 = (_step24 = _iterator24.next()).done); _iteratorNormalCompletion24 = true) {
                var _restart = _step24.value;

                if (_restart === '' || this.name === _restart) {
                    this._resolveRestart();
                } else {
                    unresolvedRestarts.push(_restart);
                }
            }
        } catch (err) {
            _didIteratorError24 = true;
            _iteratorError24 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion24 && _iterator24.return) {
                    _iterator24.return();
                }
            } finally {
                if (_didIteratorError24) {
                    throw _iteratorError24;
                }
            }
        }

        if (unresolvedRestarts.length > 0) {
            event.detail.restart = unresolvedRestarts;
        } else {
            event.stopPropagation();
        }
    },

    _resolveRestart: function _resolveRestart() {
        this.start();
        this.updateGlobalHistory(this._restartElementName);

        var _iteratorNormalCompletion25 = true;
        var _didIteratorError25 = false;
        var _iteratorError25 = undefined;

        try {
            for (var _iterator25 = this._nestedStructures[Symbol.iterator](), _step25; !(_iteratorNormalCompletion25 = (_step25 = _iterator25.next()).done); _iteratorNormalCompletion25 = true) {
                var element = _step25.value;

                element.start();
            }
        } catch (err) {
            _didIteratorError25 = true;
            _iteratorError25 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion25 && _iterator25.return) {
                    _iterator25.return();
                }
            } finally {
                if (_didIteratorError25) {
                    throw _iteratorError25;
                }
            }
        }

        if (!this.isAttached) {
            this.fire('detached-navigate');
        }
    }
};
var LayoutAttribute = {
    properties: {
        layout: String
    },

    ready: function ready() {
        this._validLayoutsData = {
            'one-column': {
                tags: ['inkd-node', 'inkd-cyoa', 'inkd-modal'],
                childTags: ['inkd-box'],
                childNum: 2,
                directChild: true,
                class: 'one-column-layout',
                parentClass: 'layout-container'
            },
            'two-column': {
                tags: ['inkd-node', 'inkd-cyoa', 'inkd-modal'],
                childTags: ['inkd-box'],
                childNum: 2,
                directChild: true,
                class: 'two-column-layout',
                parentClass: 'layout-container',
                arguments: [{ desc: 'first-column percentage', default: 50, min: 0, max: 100,
                    handler: function handler(childTags, value) {
                        childTags[0].style['-ms-flex-preferred-size'] = value + '%';
                        childTags[0].style['flex-basis'] = value + '%';
                    }
                }] },
            'three-image': {
                tags: ['inkd-box'],
                childTags: ['img', 'figure'],
                childNum: 3,
                class: 'three-image-layout'
            }
        };
    },

    addLayout: function addLayout() {
        var attrElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;
        var applyElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;

        if (attrElement.layout && !(attrElement !== this && this.layout)) {
            var params = attrElement.layout.split(':');
            var layoutName = params[0];
            params.shift();
            var layoutData = this._validLayoutsData[layoutName];

            if (layoutData === undefined) {
                this.addDebugError('layout', '\'' + layoutName + '\' is not a valid layout name', attrElement);
            } else if (!layoutData.tags.includes(attrElement.tagName.toLowerCase())) {
                this.addDebugError('layout', '\'' + layoutName + '\' can only be used in <' + layoutData.tags.join('>, <') + '>');
            } else {
                var childTags = void 0;
                if (layoutData.directChild) {
                    childTags = Polymer.dom(applyElement).getEffectiveChildNodes().filter(function (el) {
                        return el.tagName && layoutData.childTags.includes(el.tagName.toLowerCase());
                    });
                } else {
                    childTags = Polymer.dom(applyElement).querySelectorAll('' + layoutData.childTags.join(', '));
                }
                if (childTags.length !== layoutData.childNum) {
                    this.addDebugError('layout', '\'' + layoutName + '\' layout needs ' + layoutData.childNum + ' <' + layoutData.childTags.join('>, <') + '> children' + (applyElement !== this ? ' in ' + this.getTag(applyElement) : '') + ' to work correctly', attrElement);
                } else {
                    var parent = Polymer.dom(applyElement).parentNode;
                    Polymer.dom(parent).classList.add('layout-container');
                    Polymer.dom(applyElement).classList.add(layoutData.class);

                    if (layoutData.arguments) {
                        var numArgs = layoutData.arguments.length;
                        for (var i = 0; i < numArgs; i++) {
                            var argData = layoutData.arguments[i];
                            var value = params[i];

                            if (value === undefined || value === '') {
                                value = argData.default;
                            } else if (isNaN(value) || argData.min !== undefined && value < argData.min || argData.max !== undefined && value > argData.max) {
                                var descString = argData.desc === undefined ? '' : argData.desc + ' ';
                                var ruleString = void 0;

                                if (argData.min !== undefined && argData.max !== undefined) {
                                    ruleString = '(has to be a number between ' + argData.min + ' and ' + argData.max + ')';
                                } else if (argData.min !== undefined) {
                                    ruleString = '(has to be a number greater than ' + argData.min + ')';
                                } else if (argData.max !== undefined) {
                                    ruleString = '(has to be a number less than ' + argData.max + ')';
                                } else {
                                    ruleString = '(has to be a number)';
                                }

                                var defaultValue = argData.default;
                                var defaultString = '. Default value ' + defaultValue + ' used';

                                this.addDebugError('layout', '\'' + value + '\' is not a valid \'' + descString + 'value ' + ruleString + defaultString, attrElement);

                                value = argData.default;
                            }


                            argData.handler(childTags, value);
                        }

                        if (params.length > numArgs) {
                            this.addDebugWarn('layout', params.slice(numArgs).join('\', \'') + '\' unused because \'' + layoutName + '\' layout takes only ' + numArgs + ' argument' + (numArgs > 1 ? 's' : ''), attrElement);
                        }
                    } else {
                        if (params.length > 0) {
                            this.addDebugWarn('layout', '\'' + params.join('\', \'') + '\' unused because \'' + layoutName + '\' layout does not take any arguments', attrElement);
                        }
                    }
                }
            }
        }
    }
};
var ThemeAttribute = {
    properties: {
        theme: String
    },

    ready: function ready() {
        this._validThemesData = {
            'terminal': { tags: ['inkd-node', 'inkd-cyoa', 'inkd-box', 'inkd-modal'], class: 'terminal-theme' },
            'business': { tags: ['inkd-node', 'inkd-cyoa', 'inkd-box', 'inkd-modal'], class: 'business-theme' },
            'old': { tags: ['inkd-node', 'inkd-cyoa', 'inkd-box', 'inkd-modal'], class: 'old-theme' }
        };
    },

    addTheme: function addTheme() {
        var attrElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;
        var applyElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;

        if (attrElement.theme && !(attrElement !== this && this.theme)) {
            var themeName = attrElement.theme.trim();
            var themeData = this._validThemesData[themeName];

            if (themeData === undefined) {
                this.addDebugError('theme', '\'' + themeName + '\' is not a valid theme name', attrElement);
            } else if (!themeData.tags.includes(attrElement.tagName.toLowerCase())) {
                this.addDebugError('theme', '\'' + themeName + '\' can only be used in <' + themeData.tags.join('>, <') + '>');
            } else {
                Polymer.dom(applyElement).classList.add(themeData.class);
            }
        }
    }
};
var GotoElement = {

    listeners: {
        'detached-navigate': '_handleDetachedNavigate',
        'track-structure': '_handleTrackStructure'
    },

    handleInkdmlGoto: function handleInkdmlGoto(gotoData) {
        this.fire('goto', { gotoData: [].concat(gotoData) });
    },

    _handleDetachedNavigate: function _handleDetachedNavigate(event) {
        this.fire('goto', { gotoData: [{ element: this.globalElement, gotos: [this.name] }] });
        event.stopPropagation();
    },

    _handleTrackStructure: function _handleTrackStructure(event) {
        event.stopPropagation();
        var detail = event.detail;

        if (!detail.parent) {
            detail.parent = this.name;
        }
        this.addTrackDetail(detail, 'structures');
    }
};
Polymer({
    is: 'inkd-node',

    properties: {
        start: Boolean,
        topic: String,
        number: String,
        editorData: Object
    },

    behaviors: [InkdBehavior, SetPropAttribute, NameAttribute, ActionAttributes, GotoElement, LayoutAttribute, ThemeAttribute],

    ready: function ready() {
        this.enforceDirectAncestor('inkd-cyoa');

        this.topic = this.topic || this.name;
        if (this.number !== undefined && /[^\s\d.]/g.test(this.number)) {
            this.addDebugError('number', '\'' + this.number + '\' is not a valid outline number (can only contain numbers separated by decimal points)');
        }

        this.visited = 0;

        this.addLayout();
        this.addTheme();
    },

    attached: function attached() {
        this.handleSetProp();
        this.handleActions();
    },

    set visited(value) {
        this._visited = value;
        this.setBuiltinProp('visited', value);
    },

    get visited() {
        return this._visited;
    }
});
Polymer({
    is: 'inkd-cyoa',

    properties: {
        noScroll: Boolean
    },

    behaviors: [InkdBehavior, SetPropAttribute, NameAttribute, ActionAttributes, NavigateHandler, LayoutAttribute, ThemeAttribute],

    observers: ['_updateNodesVisited(_activeNode)'],

    ready: function ready() {
        this.setBuiltinProps({ prevNode: null, prevNodeTopic: null, currentNode: null, currentNodeTopic: null, allNodesVisited: false });

        this._startNodeName = null;
        this._nodes = {};
        Polymer.dom(this).observeNodes(this._handleChildrenChange);

        this.onGlobalAttach('_initiate');
    },

    attached: function attached() {
        if (this._initiated && !this._started) {
            this.start();
            this.updateGlobalHistory(this._startNodeName, true);
        }
    },

    start: function start() {
        this.setBuiltinProps({ prevNode: null, prevNodeTopic: null });
        this._resetNodesVisited();

        this.handleSetProp();
        this.handleActions();

        this.addTrackEvent('cyoa-start', { cyoa: this.name, nodes: Object.keys(this._nodes) });

        this._updateActiveNode(this._startNodeName);

        this._started = true;
    },

    gotoNavigate: function gotoNavigate(gotoName) {
        if (!this._started) {
            this.start();
        }

        this._updateActiveNode(gotoName);
    },

    get nodes() {
        var nodeArray = [];
        for (var name in this._nodes) {
            nodeArray.push(this._nodes[name]);
        }
        return nodeArray;
    },

    _handleChildrenChange: function _handleChildrenChange(_ref8) {
        var newChildren = _ref8.addedNodes;
        var _iteratorNormalCompletion26 = true;
        var _didIteratorError26 = false;
        var _iteratorError26 = undefined;

        try {
            for (var _iterator26 = newChildren[Symbol.iterator](), _step26; !(_iteratorNormalCompletion26 = (_step26 = _iterator26.next()).done); _iteratorNormalCompletion26 = true) {
                var child = _step26.value;

                if (child.tagName === 'INKD-NODE') {
                    if (child.name) {
                        var node = child;
                        this._nodes[node.name] = node;
                        if (node.start) {
                            if (this._startNodeName === null) {
                                this._startNodeName = node.name;
                            } else {
                                this.addDebugWarn(null, '\'start\' unused because \'' + this._startNodeName + '\' already defined as start node', node);
                            }
                        }
                        node.addLayout(this);
                        node.addTheme(this);
                    } else {
                        this.addDebugError(null, '\'name\' attribute required for cyoa node');
                    }
                } else if (!(['INKD-INCLUDE', 'INKD-MODAL'].includes(child.tagName) || child.nodeType === Node.COMMENT_NODE || child.nodeType === Node.TEXT_NODE && !child.nodeValue.replace(/^\s+|\s+$/g, ''))) {
                    this.addDebugWarn(null, '\'' + (this.getTag(child) || child.textContent.trim()) + '\' unused because <inkd-cyoa> only accepts <inkd-node> elements as direct children');
                }
            }
        } catch (err) {
            _didIteratorError26 = true;
            _iteratorError26 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion26 && _iterator26.return) {
                    _iterator26.return();
                }
            } finally {
                if (_didIteratorError26) {
                    throw _iteratorError26;
                }
            }
        }
    },

    _initiate: function _initiate() {
        if (Object.keys(this._nodes).length > 0) {
            if (this._startNodeName === null) {
                this._startNodeName = Object.keys(this._nodes)[0];
            }

            this.initiateNavigate(this._nodes, this._startNodeName, ['inkd-cyoa', 'inkd-pano']);
            this._initiated = true;
        } else {
            this.addDebugError(null, 'No <inkd-node> children found');
        }
    },

    _updateActiveNode: function _updateActiveNode(nodeName) {
        if (nodeName !== this._activeNode) {
            if (this._activeNode !== undefined) {
                var _node = this._nodes[this._activeNode];
                Polymer.dom(_node).removeAttribute('active-node');
                this.setBuiltinProps({ prevNode: this._activeNode, prevNodeTopic: _node.topic });
            }

            this._activeNode = nodeName;
            var node = this._nodes[nodeName];

            Polymer.dom(node).setAttribute('active-node', '');
            this.setBuiltinProps({ currentNode: nodeName, currentNodeTopic: node.topic });

            this.addTrackEvent('cyoa-node-change', { cyoa: this.name, node: nodeName }, node);

            if (!this.noScroll) {
                window.scrollTo(0, 0);
            }
        }
    },

    _updateNodesVisited: function _updateNodesVisited() {
        var element = this._nodes[this._activeNode];
        element.visited++;

        if (!this._allNodesVisited) {
            var value = true;
            for (var name in this._nodes) {
                if (this._nodes[name].visited === 0) {
                    value = false;
                    break;
                }
            }
            this._allNodesVisited = value;
            this.setBuiltinProp('allNodesVisited', value);
        }
    },

    _resetNodesVisited: function _resetNodesVisited() {
        for (var name in this._nodes) {
            this._nodes[name].visited = 0;
        }
        this.setBuiltinProp('allNodesVisited', false);
    }
});
var PanoAttributes = {

    properties: {
        vAngle: {
            type: Number,
            value: 0,
            min: -90,
            max: 90,
            desc: 'vertical angle'
        },
        hAngle: {
            type: Number,
            value: 0,
            min: -180,
            max: 180,
            desc: 'horizontal angle'
        },
        field: {
            type: Number,
            value: 100,
            min: 50,
            max: 120,
            desc: 'horizontal field of view angle'
        },
        minTilt: {
            type: Number,
            value: -90,
            min: -90,
            max: 90,
            desc: 'minimum horizontal tilt'
        },
        maxTilt: {
            type: Number,
            value: 90,
            min: -90,
            max: 90,
            desc: 'maximum horizontal tilt'
        },
        autorotate: {
            type: String,
            flagAllowed: true
        },
        noZoom: Boolean,
        controls: Boolean
    },

    handlePanoAttributes: function handlePanoAttributes(configObject) {
        configObject.pitch = Number(this.vAngle);
        configObject.yaw = Number(this.hAngle);
        configObject.hfov = Number(this.field);
        configObject.minPitch = Number(this.minTilt);
        configObject.maxPitch = Number(this.maxTilt);

        if (this.autorotate !== undefined) {
            var splitResult = this.autorotate.replace(/\s/g, '').split(':');

            var degrees = splitResult[0];
            if (degrees === '') {
                configObject.autoRotate = 1;
            } else if (!isNaN(degrees)) {
                configObject.autoRotate = Number(degrees);
            } else {
                this.addDebugError('autorotate', '\'' + degrees + '\' is not a valid degrees/second value');
            }

            if (splitResult[1]) {
                var delay = splitResult[1];
                if (delay.endsWith('ms') && !isNaN(delay.slice(0, -2))) {
                    configObject.autoRotateInactivityDelay = Number(delay.slice(0, -2));
                } else if (delay.endsWith('s') && !isNaN(delay.slice(0, -1))) {
                    configObject.autoRotateInactivityDelay = Number(delay.slice(0, -1)) * 1000;
                } else if (!isNaN(time)) {
                    configObject.autoRotateInactivityDelay = Number(delay) * 1000;
                } else {
                    this.addDebugError('autorotate', '\'' + delay + '\' is not a valid inactivity delay value');
                }
            }

            if (splitResult[2]) {
                this.addDebugWarn('autorotate', '\'' + splitResult.slice(2).join('\', \'') + '\' unused because only two values needed for degrees/second and inactivity delay');
            }
        }

        if (this.noZoom) {
            configObject.showZoomCtrl = false;
            configObject.keyboardZoom = false;
            configObject.mouseZoom = false;
        }

        if (this.controls) {
            configObject.showControls = true;
            configObject.compass = true;
        }

        configObject.autoLoad = true;
    }
};
Polymer({
    is: 'inkd-pano-scene',

    properties: {
        src: String,
        start: Boolean
    },

    behaviors: [InkdBehavior, PanoAttributes, SetPropAttribute, NameAttribute, ActionAttributes, GotoElement],

    listeners: {
        'hotspot-clicked': '_handleHotspotClick'
    },

    ready: function ready() {
        var _this4 = this;

        this.enforceDirectAncestor('inkd-pano');

        this.visited = 0;

        if (this.src === undefined) {
            this.addDebugError('src', 'No image files specified');
        } else {
            (function () {
                var images = _this4.src.split(/\s*,\s*/);

                if (images.length < 6) {
                    _this4.sceneObject = {
                        'type': 'equirectangular',
                        'panorama': images[0]
                    };

                    if (images.length > 1) {
                        _this4.addDebugWarn('src', '\'' + images.slice(1).join('\', \'') + '\' unused because only 1 image is needed for equirectangular panorama (Note: 6 images needed for cubemap panorama)');
                    }
                } else {
                    (function () {
                        _this4.sceneObject = {
                            'type': 'cubemap',
                            'cubeMap': images.slice(0, 6)
                        };

                        var dimension = void 0,
                            firstIndex = void 0;

                        var _loop3 = function _loop3(i) {
                            var img = document.createElement('img');
                            img.src = images[i];

                            img.addEventListener('load', function () {
                                if (img.naturalWidth !== img.naturalHeight) {
                                    _this4.addDebugError('src', 'Width and height of image \'' + images[i] + '\' are not equal (Cubemap panoramas require 6 square images with the same dimensions)');
                                } else {
                                    if (dimension === undefined) {
                                        dimension = img.naturalWidth;
                                        firstIndex = i;
                                    } else if (img.naturalWidth !== dimension) {
                                        _this4.addDebugError('src', 'Dimensions of image \'' + images[i] + '\' are not equal to those of \'' + images[firstIndex] + '\' (cubemap panoramas require 6 square images with the same dimensions)');
                                    }
                                }
                            });
                        };

                        for (var i = 0; i < 6; i++) {
                            _loop3(i);
                        }

                        if (images.length > 6) {
                            _this4.addDebugWarn('src', '\'' + images.slice(6).join('\', \'') + '\' unused because only 6 images are needed for cubemap panorama');
                        }
                    })();
                }
            })();
        }

        this.handlePanoAttributes(this.sceneObject);

        this.sceneObject.hotSpots = [];

        this._currentHotspotIds = [];
        this._nextHotspotId = 0;
        this._hotspotIdPrefix = this.name === undefined ? 'unnamed' : this.name;

        Polymer.dom(this).observeNodes(this._handleChildrenChange);
        this.onGlobalReady('_initiateScene');
    },

    set visited(value) {
        this._visited = value;
        this.setBuiltinProp('visited', value);
    },

    get visited() {
        return this._visited;
    },

    _initiateScene: function _initiateScene() {
        var hotspots = Polymer.dom(this).querySelectorAll('INKD-PANO-HOTSPOT');

        var _iteratorNormalCompletion27 = true;
        var _didIteratorError27 = false;
        var _iteratorError27 = undefined;

        try {
            for (var _iterator27 = hotspots[Symbol.iterator](), _step27; !(_iteratorNormalCompletion27 = (_step27 = _iterator27.next()).done); _iteratorNormalCompletion27 = true) {
                var element = _step27.value;

                element.hotspotObject.id = this._hotspotIdPrefix + this._nextHotspotId;
                this._nextHotspotId++;

                this.listen(element, 'hotspot-changed', '_handleHotspotChange');
            }
        } catch (err) {
            _didIteratorError27 = true;
            _iteratorError27 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion27 && _iterator27.return) {
                    _iterator27.return();
                }
            } finally {
                if (_didIteratorError27) {
                    throw _iteratorError27;
                }
            }
        }
    },

    _handleChildrenChange: function _handleChildrenChange(_ref9) {
        var newChildren = _ref9.addedNodes;
        var _iteratorNormalCompletion28 = true;
        var _didIteratorError28 = false;
        var _iteratorError28 = undefined;

        try {
            for (var _iterator28 = newChildren[Symbol.iterator](), _step28; !(_iteratorNormalCompletion28 = (_step28 = _iterator28.next()).done); _iteratorNormalCompletion28 = true) {
                var child = _step28.value;

                if (!this._checkElement(child, ['inkd-pano-hotspot', 'inkd-modal', 'inkd-include'])) {
                    if (this._checkElement(child, 'inkd-if')) {
                        var ifChildren = Polymer.dom(child).childNodes;
                        var _iteratorNormalCompletion29 = true;
                        var _didIteratorError29 = false;
                        var _iteratorError29 = undefined;

                        try {
                            for (var _iterator29 = ifChildren[Symbol.iterator](), _step29; !(_iteratorNormalCompletion29 = (_step29 = _iterator29.next()).done); _iteratorNormalCompletion29 = true) {
                                var ifChild = _step29.value;

                                if (!this._checkElement(ifChild, 'inkd-pano-hotspot')) {
                                    if (this._checkElement(ifChild, 'inkd-else')) {
                                        var elseChildren = Polymer.dom(ifChild).childNodes;
                                        var _iteratorNormalCompletion30 = true;
                                        var _didIteratorError30 = false;
                                        var _iteratorError30 = undefined;

                                        try {
                                            for (var _iterator30 = elseChildren[Symbol.iterator](), _step30; !(_iteratorNormalCompletion30 = (_step30 = _iterator30.next()).done); _iteratorNormalCompletion30 = true) {
                                                var elseChild = _step30.value;

                                                if (!this._checkElement(elseChild, 'inkd-pano-hotspot')) {
                                                    this.addDebugWarn(null, '\'' + (this.getTag(elseChild) || elseChild.textContent.trim()) + '\' unused because <inkd-pano-scene> only accepts <inkd-pano-hotspot> elements as direct children');
                                                    Polymer.dom(ifChild).removeChild(elseChild);
                                                }
                                            }
                                        } catch (err) {
                                            _didIteratorError30 = true;
                                            _iteratorError30 = err;
                                        } finally {
                                            try {
                                                if (!_iteratorNormalCompletion30 && _iterator30.return) {
                                                    _iterator30.return();
                                                }
                                            } finally {
                                                if (_didIteratorError30) {
                                                    throw _iteratorError30;
                                                }
                                            }
                                        }
                                    } else {
                                        this.addDebugWarn(null, '\'' + (this.getTag(ifChild) || ifChild.textContent.trim()) + '\' unused because <inkd-pano-scene> only accepts <inkd-pano-hotspot> elements as direct children');
                                        Polymer.dom(child).removeChild(ifChild);
                                    }
                                }
                            }
                        } catch (err) {
                            _didIteratorError29 = true;
                            _iteratorError29 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion29 && _iterator29.return) {
                                    _iterator29.return();
                                }
                            } finally {
                                if (_didIteratorError29) {
                                    throw _iteratorError29;
                                }
                            }
                        }
                    } else {
                        this.addDebugWarn(null, '\'' + (this.getTag(child) || child.textContent.trim()) + '\' unused because <inkd-pano-scene> only accepts <inkd-pano-hotspot> elements as direct children');
                        Polymer.dom(this).removeChild(child);
                    }
                }
            }
        } catch (err) {
            _didIteratorError28 = true;
            _iteratorError28 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion28 && _iterator28.return) {
                    _iterator28.return();
                }
            } finally {
                if (_didIteratorError28) {
                    throw _iteratorError28;
                }
            }
        }
    },

    _checkElement: function _checkElement(element, tags) {
        return element.nodeType === Node.ELEMENT_NODE && [].concat(tags).includes(element.tagName.toLowerCase()) || element.nodeType === Node.COMMENT_NODE || element.nodeType === Node.TEXT_NODE && !element.nodeValue.replace(/^\s+|\s+$/g, '');
    },


    _handleHotspotChange: function _handleHotspotChange(event) {
        event.stopPropagation();
        var _event$detail2 = event.detail,
            eventType = _event$detail2.eventType,
            hotspotElement = _event$detail2.hotspotElement;


        if (hotspotElement.hotspotObject.id === undefined) {
            hotspotElement.hotspotObject.id = this._hotspotIdPrefix + this._nextHotspotId;
            this._nextHotspotId++;
        }

        var hotspotId = hotspotElement.hotspotObject.id;

        if (eventType === 'add') {
            if (!this._currentHotspotIds.includes(hotspotId)) {
                this._currentHotspotIds.push(hotspotId);
                this.fire('hotspot-changed', { eventType: eventType, hotspotElement: hotspotElement, sceneElement: this });
            }
        } else if (eventType === 'remove') {
            var index = this._currentHotspotIds.indexOf(hotspotId);
            if (index !== -1) {
                this._currentHotspotIds.splice(index, 1);
                this.fire('hotspot-changed', { eventType: eventType, hotspotElement: hotspotElement, sceneElement: this });
            }
        }
    },

    _handleHotspotClick: function _handleHotspotClick(_ref10) {
        var detail = _ref10.detail;

        detail.sceneElement = this;
    }
});
Polymer({
    is: 'inkd-pano-hotspot',

    properties: {
        vAngle: {
            type: Number,
            value: 0,
            min: -90,
            max: 90,
            desc: 'vertical angle'
        },
        hAngle: {
            type: Number,
            value: 0,
            min: -180,
            max: 180,
            desc: 'horizontal angle'
        }
    },

    behaviors: [InkdBehavior, NameAttribute, ButtonBehavior],

    ready: function ready() {
        this.enforceAncestor('inkd-pano-scene');

        this._hotspotElement = document.createElement('span');
        this._hotspotElement.className = this.className;
        var childNodes = Polymer.dom(this).childNodes;
        var _iteratorNormalCompletion31 = true;
        var _didIteratorError31 = false;
        var _iteratorError31 = undefined;

        try {
            for (var _iterator31 = childNodes[Symbol.iterator](), _step31; !(_iteratorNormalCompletion31 = (_step31 = _iterator31.next()).done); _iteratorNormalCompletion31 = true) {
                var child = _step31.value;

                this._hotspotElement.appendChild(child);
            }
        } catch (err) {
            _didIteratorError31 = true;
            _iteratorError31 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion31 && _iterator31.return) {
                    _iterator31.return();
                }
            } finally {
                if (_didIteratorError31) {
                    throw _iteratorError31;
                }
            }
        }

        this.hotspotObject = {
            pitch: this.vAngle,
            yaw: this.hAngle,
            type: 'scene',
            createTooltipFunc: this._createHotspot.bind(this),
            createTooltipArgs: this._hotspotElement,
            clickHandlerFunc: this._clickHotspot.bind(this)
        };

        this.style.display = 'none';
    },

    attached: function attached() {
        this.fire('hotspot-changed', { eventType: 'add', hotspotElement: this });
    },

    detached: function detached() {
        this.fire('hotspot-changed', { eventType: 'remove', hotspotElement: this });
    },

    _createHotspot: function _createHotspot(hotspotDiv, element) {
        this.hotspotDiv = hotspotDiv;
        hotspotDiv.appendChild(element);
    },

    _clickHotspot: function _clickHotspot() {
        var _this5 = this;

        this.click(function () {
            _this5.fire('hotspot-clicked', { hotspotElement: _this5 });
        });
    }
});
Polymer({
    is: 'inkd-pano',

    properties: {
        width: {
            type: String,
            value: '700px'
        },
        height: {
            type: String,
            value: '300px'
        },
        fadeTime: {
            type: String,
            value: '1'
        }
    },

    behaviors: [InkdBehavior, PanoAttributes, SetPropAttribute, NameAttribute, NavigateHandler, ActionAttributes],

    listeners: {
        'hotspot-changed': '_handleHotspotChange',
        'hotspot-clicked': '_handleHotspotClick'
    },

    observers: ['_updateScenesVisited(_activeScene)'],

    ready: function ready() {
        this.setBuiltinProps({ prevScene: null, currentScene: null, allScenesVisited: false });

        this.customStyle['--width'] = '' + this.width + (isNaN(this.width) ? '' : 'px');
        this.customStyle['--height'] = '' + this.height + (isNaN(this.height) ? '' : 'px');

        this._configuration = {
            'default': {},
            'scenes': {}
        };

        this._tempHotspotData = [];

        this._startSceneName = null;
        this._scenes = {};
        Polymer.dom(this).observeNodes(this._handleChildrenChange);

        this.onGlobalAttach('_initiate');
    },

    attached: function attached() {
        if (this._initiated && !this._panoLoaded) {
            this._panorama = pannellum.viewer(this.$.panorama, this._configuration);
            this._panorama.on('load', this._handlePanoLoad.bind(this));
            this._panorama.on('error', this._handleError.bind(this));
        }
    },

    start: function start() {
        if (this._panoLoaded) {
            this.setBuiltinProp('prevScene', null);
            this._resetScenesVisited();

            this.handleSetProp();
            this.handleActions();

            this.addTrackEvent('pano-start', { pano: this.name, scenes: Object.keys(this._scenes) });

            var sceneName = this._tempStartScene ? this._tempStartScene : this._startSceneName;

            this._updateActiveScene(sceneName);
        }
    },

    gotoNavigate: function gotoNavigate(gotoName) {
        if (this._panoLoaded) {
            this._updateActiveScene(gotoName);
        } else {
            this._tempStartScene = gotoName;
        }
    },

    _handleChildrenChange: function _handleChildrenChange(_ref11) {
        var newChildren = _ref11.addedNodes;
        var _iteratorNormalCompletion32 = true;
        var _didIteratorError32 = false;
        var _iteratorError32 = undefined;

        try {
            for (var _iterator32 = newChildren[Symbol.iterator](), _step32; !(_iteratorNormalCompletion32 = (_step32 = _iterator32.next()).done); _iteratorNormalCompletion32 = true) {
                var child = _step32.value;

                if (child.tagName === 'INKD-PANO-SCENE') {
                    if (child.name) {
                        var scene = child;
                        var sceneName = scene.name,
                            sceneObject = scene.sceneObject;


                        this._scenes[sceneName] = scene;
                        if (scene.start) {
                            if (this._startSceneName === null) {
                                this._startSceneName = scene.name;
                            } else {
                                this.addDebugWarn(null, '\'start\' unused because \'' + this._startSceneName + '\' already defined as start scene', scene);
                            }
                        }

                        this._configuration.scenes[sceneName] = sceneObject;
                    } else {
                        this.addDebugError(null, '\'name\' attribute required for pano scene');
                    }
                } else if (!(['INKD-INCLUDE', 'INKD-MODAL'].includes(child.tagName) || child.nodeType === Node.COMMENT_NODE || child.nodeType === Node.TEXT_NODE && !child.nodeValue.replace(/^\s+|\s+$/g, ''))) {
                    this.addDebugWarn(null, '\'' + (this.getTag(child) || child.textContent.trim()) + '\' unused because <inkd-pano> only accepts <inkd-pano-scene> elements as direct children');
                }
            }
        } catch (err) {
            _didIteratorError32 = true;
            _iteratorError32 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion32 && _iterator32.return) {
                    _iterator32.return();
                }
            } finally {
                if (_didIteratorError32) {
                    throw _iteratorError32;
                }
            }
        }
    },

    _initiate: function _initiate() {
        if (Object.keys(this._scenes).length > 0) {
            if (this._startSceneName === null) {
                this._startSceneName = Object.keys(this._scenes)[0];
            }

            this.initiateNavigate(this._scenes, this._startSceneName, ['inkd-pano', 'inkd-cyoa']);

            var defaultConfig = this._configuration.default;
            var match = this.fadeTime.replace(/\s/g, '').match(/^(\d+(?:\.\d+)?)(m?s)?$/);
            if (match) {
                var _time = Number(match[1]);
                var unit = match[2];
                if (unit === undefined || unit === 's') {
                    _time *= 1000;
                }
                defaultConfig.sceneFadeDuration = _time;
            } else {
                this.addDebugError('fade-time', '\'' + this.fadeTime + '\' is not a valid duration');
            }

            this.handlePanoAttributes(defaultConfig);

            this._configuration.default.firstScene = this._startSceneName;
            this._initiated = true;
        } else {
            this.addDebugError(null, 'No <inkd-pano-scene> children found');
        }
    },

    _updateActiveScene: function _updateActiveScene(sceneName) {
        if (sceneName !== this._activeScene) {
            if (this._activeScene !== undefined) {
                this.setBuiltinProp('prevScene', this._activeScene);
            }

            this._activeScene = sceneName;

            this._panorama.loadScene(sceneName);
            this._scenes[sceneName].handleSetProp();
            this._scenes[sceneName].handleActions();

            this.setBuiltinProp('currentScene', sceneName);

            this.addTrackEvent('pano-scene-change', { pano: this.name, scene: sceneName }, this._scenes[sceneName]);
        }
    },

    _updateScenesVisited: function _updateScenesVisited() {
        var element = this._scenes[this._activeScene];
        element.visited++;

        if (!this._allScenesVisited) {
            var value = true;
            for (var name in this._scenes) {
                if (this._scenes[name].visited === 0) {
                    value = false;
                    break;
                }
            }
            this._allScenesVisited = value;
            this.setBuiltinProp('allScenesVisited', value);
        }
    },

    _resetScenesVisited: function _resetScenesVisited() {
        for (var name in this._scenes) {
            this._scenes[name].visited = 0;
        }
        this.setBuiltinProp('allScenesVisited', false);
    },

    _updateHotspot: function _updateHotspot(_ref12) {
        var eventType = _ref12.eventType,
            hotspotElement = _ref12.hotspotElement,
            sceneElement = _ref12.sceneElement;

        if (eventType === 'add') {
            this._panorama.addHotSpot(hotspotElement.hotspotObject, sceneElement.name);
        } else if (eventType === 'remove') {
            this._panorama.removeHotSpot(hotspotElement.hotspotObject.id, sceneElement.name);
        }
    },

    _handlePanoLoad: function _handlePanoLoad() {
        if (!this._panoLoaded) {
            var _iteratorNormalCompletion33 = true;
            var _didIteratorError33 = false;
            var _iteratorError33 = undefined;

            try {
                for (var _iterator33 = this._tempHotspotData[Symbol.iterator](), _step33; !(_iteratorNormalCompletion33 = (_step33 = _iterator33.next()).done); _iteratorNormalCompletion33 = true) {
                    var hotspotData = _step33.value;

                    this._updateHotspot(hotspotData);
                }
            } catch (err) {
                _didIteratorError33 = true;
                _iteratorError33 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion33 && _iterator33.return) {
                        _iterator33.return();
                    }
                } finally {
                    if (_didIteratorError33) {
                        throw _iteratorError33;
                    }
                }
            }

            this._panoLoaded = true;

            this.start();
            this.updateGlobalHistory(this._tempStartScene ? this._tempStartScene : this._startSceneName, true);
        }
    },

    _handleHotspotChange: function _handleHotspotChange(event) {
        event.stopPropagation();
        var target = event.target,
            detail = event.detail;

        if (target.tagName === 'INKD-PANO-SCENE') {
            if (this._panoLoaded) {
                this._updateHotspot(detail);
            } else {
                this._tempHotspotData.push(detail);
            }
        }
    },

    _handleHotspotClick: function _handleHotspotClick(event) {
        event.stopPropagation();
        var _event$detail3 = event.detail,
            hotspotElement = _event$detail3.hotspotElement,
            sceneElement = _event$detail3.sceneElement;

        this.addTrackEvent('pano-hotspot-click', {
            pano: this.name,
            scene: sceneElement.name,
            hotspot: Polymer.dom(hotspotElement.hotspotDiv).textContent.replace(/^\s+|\s+$/g, '')
        }, sceneElement);
    },

    _handleError: function _handleError(errorMsg) {
        this.addDebugError(null, 'Error loading panorama');
        this._error = true;
        this._errorText = errorMsg.includes('accessed') ? errorMsg : 'Panorama could not be loaded. Your browser might not support panoramic images or the image file could not be accessed.';
    }
});
Polymer({
    is: 'inkd-img',

    properties: {
        src: String,
        preload: Boolean,
        width: {
            type: String,
            value: 'auto'
        },
        height: {
            type: String,
            value: 'auto'
        },
        alt: String,
        longdesc: String
    },

    behaviors: [InkdBehavior, NameAttribute],

    ready: function ready() {
        if (this.src) {
            var _arr2 = ['width', 'height'];

            for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
                var _prop3 = _arr2[_i2];
                this[_prop3] = '' + this[_prop3] + (isNaN(this[_prop3]) ? '' : 'px');
            }

            if (/\s/.test(this.src)) {
                this.addDebugWarn('src', 'Spaces in path \'' + this.src + '\' might cause an issue in loading the file from a server');
            }

            if (this.preload) {
                var relList = document.createElement('link').relList;
                var htmlPreloadSupport = relList && relList.supports && relList.supports('preload');

                var preloadElement = void 0;
                if (htmlPreloadSupport) {
                    preloadElement = document.createElement('link');
                    preloadElement.rel = 'preload';
                    preloadElement.as = 'image';
                    preloadElement.href = this.src;
                    document.head.appendChild(preloadElement);
                } else {
                    preloadElement = new Image();
                    preloadElement.src = this.src;
                }

                this.listen(preloadElement, 'error', '_handleError');
            }
        } else {
            this.addDebugError('src', 'No image files specified');
        }
    },

    attached: function attached() {
        if (this._loadError && navigator.userAgent.indexOf('Firefox') !== -1) {
            this.addDebugError('src', 'Error loading image \'' + this.src + '\'');
        }
    },

    _handleLoad: function _handleLoad() {
        var element = this.$.image;
        var naturalAspect = element.naturalWidth / element.naturalHeight;
        var aspect = element.width / element.height;

        if (aspect > naturalAspect + 0.05) {
            this.addDebugWarn('width\' and \'height', 'Image \'' + this.src + '\' might be squished vertically because its aspect ratio (width/height) is greater than the natural aspect ratio of the original file');
        } else if (aspect < naturalAspect - 0.05) {
            this.addDebugWarn('width\' and \'height', 'Image \'' + this.src + '\' might be squished horizontally because its aspect ratio (width/height) is less than the natural aspect ratio of the original file');
        }

        this._loadError = false;
    },

    _handleError: function _handleError() {
        if (!this._loadError) {
            if (navigator.userAgent.indexOf('Firefox') === -1) {
                this.addDebugError('src', 'Error loading image \'' + this.src + '\'');
            }
            this._loadError = true;
        }
    }
});
Polymer({
    is: 'inkd-audio',

    properties: {
        src: String,
        volume: {
            type: Number,
            value: 1,
            min: 0,
            max: 1
        },
        autoplay: Boolean,
        preload: Boolean,
        controls: {
            type: Boolean,
            value: false
        },
        loop: {
            type: Boolean,
            value: false
        }
    },

    behaviors: [InkdBehavior, NameAttribute],

    ready: function ready() {
        var _this6 = this;

        this.setBuiltinProps({ playing: false, volume: this.volume });

        this._createHtmlAudio = false;
        if (this.src === undefined) {
            this.addDebugError(null, 'No audio file or URL specified');
        } else {
            var lowerSrc = this.src.toLowerCase();
            if (lowerSrc.endsWith('.mp3')) {
                this._mediaType = 'audio/mpeg';
            } else if (lowerSrc.endsWith('.ogg')) {
                this._mediaType = 'audio/ogg';
            } else if (lowerSrc.endsWith('.wav')) {
                this._mediaType = 'audio/wav';
            } else if (lowerSrc.endsWith('.aif') || lowerSrc.endsWith('.aiff')) {
                this._mediaType = 'audio/aiff';
            } else if (lowerSrc.endsWith('')) {
                this._mediaType = '';
                this.addDebugWarn('src', 'Audio file \'' + this.src + '\' might not be supported in all browsers (.mp3 is recommended)');
            }

            this._createHtmlAudio = true;
            this.async(function () {
                _this6._audioElement = _this6.$$('#audioElement');
                _this6._audioElement.volume = _this6.volume;
            });
            this.preload = this.preload ? 'auto' : 'none';
        }
    },

    attached: function attached() {
        if (this.autoplay) {
            this.play();
        }
    },

    detached: function detached() {
        this.pause();

        this._savePlayback();
    },

    play: function play() {
        this._audioElement.play();
    },

    pause: function pause() {
        this._audioElement.pause();
    },

    restart: function restart() {
        this._audioElement.currentTime = 0;
        this._audioElement.play();
    },

    setVolume: function setVolume(value) {
        this._audioElement.volume = value;
    },

    _savePlayback: function _savePlayback() {
        var playedData = [];
        var playedDuration = 0;

        var playedTimeRanges = this._audioElement.played;
        for (var i = 0; i < playedTimeRanges.length; i++) {
            var start = playedTimeRanges.start(i);
            var end = playedTimeRanges.end(i);
            playedData.push({ start: start, end: end });
            playedDuration += end - start;
        }

        this.addTrackEvent('audio-playback', {
            video: this.name,
            played: playedData,
            playedPercent: Math.round(playedDuration * 100 / this._audioElement.duration) || 0
        });
    },

    _handleError: function _handleError() {
        this.addDebugError('src', 'Error loading audio \'' + this.src + '\'');
    },

    _handlePlay: function _handlePlay() {
        this.setBuiltinProp('playing', true);
        this.addTrackEvent('audio-play', { audio: this.name, currentTime: this._audioElement.currentTime });
    },

    _handlePause: function _handlePause() {
        this.setBuiltinProp('playing', false);
        this.addTrackEvent('audio-pause', { audio: this.name, currentTime: this._audioElement.currentTime });
    },

    _handleVolumeChange: function _handleVolumeChange() {
        this.volume = this._audioElement.volume;
        this.setBuiltinProp('volume', this.volume);
    }
});
Polymer({
    is: 'inkd-video',

    properties: {
        src: String,
        volume: {
            type: Number,
            value: 1,
            min: 0,
            max: 1
        },
        width: {
            type: String,
            value: '500px'
        },
        height: {
            type: String,
            value: 'auto'
        },
        autoplay: Boolean,
        preload: Boolean,
        controls: {
            type: Boolean,
            value: false
        },
        loop: {
            type: Boolean,
            value: false
        }
    },

    behaviors: [InkdBehavior, NameAttribute],

    ready: function ready() {
        this.setBuiltinProps({ playing: false, volume: this.volume });

        this.customStyle['--width'] = '' + this.width + (isNaN(this.width) ? '' : 'px');
        this.customStyle['--height'] = '' + this.height + (isNaN(this.height) ? '' : 'px');

        this._typeIsHtml5 = false;
        this._typeIsYoutube = false;
        this._typeIsVimeo = false;

        this._vimeoAttach = false;

        if (this.src === undefined) {
            this.addDebugError(null, 'No video file or URL specified');
        } else if (/^(http|https):\/\/(www.youtube.com\/watch\?v=|youtu.be\/)/.test(this.src)) {
            this._initiateYoutube();
        } else if (/^(http|https):\/\/(vimeo.com\/)/.test(this.src)) {
            this._initiateVimeo();
        } else {
            this._initiateHtml5();
        }
    },

    attached: function attached() {
        if (this._typeIsHtml5 && this.autoplay) {
            this.play();
        } else if (this._typeIsVimeo) {
            this._vimeoAttach = true;
            this._loadVimeoPlayer();
        }
    },

    detached: function detached() {
        if (this._typeIsYoutube) {
            this._youtubeReady = false;
            this._youtubeSavedTime = this._youtubeElement.currenttime;
        } else if (this._typeIsVimeo) {
            this._vimeoAttach = false;
            this._vimeoReady = false;
            this._vimeoSavedTime = this._vimeoCurrentTime;
        }

        this.setBuiltinProp('playing', false);

        this._savePlaybackInfo();
    },

    play: function play() {
        if (this._typeIsHtml5) {
            this._html5Element.play();
        } else if (this._typeIsYoutube && this._youtubeReady) {
            if (this._youtubeSavedTime) {
                this._youtubeElement.seekTo(this._youtubeSavedTime);
                this._youtubeSavedTime = null;
            }
            this._youtubeElement.play();
        } else if (this._typeIsVimeo && this._vimeoReady) {
            if (this._vimeoSavedTime) {
                this._vimeoElement.setCurrentTime(this._vimeoSavedTime);
                this._vimeoSavedTime = null;
            }
            this._vimeoElement.play();
        }
    },

    pause: function pause() {
        if (this._typeIsHtml5) {
            this._html5Element.pause();
        } else if (this._typeIsYoutube && this._youtubeReady) {
            this._youtubeElement.pause();
        } else if (this._typeIsVimeo && this._vimeoReady) {
            this._vimeoElement.pause();
        }
    },

    restart: function restart() {
        if (this._typeIsHtml5) {
            this._html5Element.currentTime = 0;
            this._html5Element.play();
        } else if (this._typeIsYoutube && this._youtubeReady) {
            this._youtubeElement.seekTo(0);
            this._youtubeElement.play();
        } else if (this._typeIsVimeo && this._vimeoReady) {
            this._vimeoElement.setCurrentTime(0);
            this._vimeoElement.play();
        }
    },

    setVolume: function setVolume(value) {
        if (this._typeIsHtml5) {
            this._html5Element.volume = value;
        } else if (this._typeIsYoutube && this._youtubeReady) {
            this._youtubeElement.setVolume(value * 100);
        } else if (this._typeIsVimeo && this._vimeoReady) {
            this._vimeoElement.setVolume(value);
        }
    },

    _initiateHtml5: function _initiateHtml5() {
        var _this7 = this;

        var lowerSrc = this.src.toLowerCase();
        if (lowerSrc.endsWith('.mp4')) {
            this._html5MediaType = 'video/mp4';
        } else if (lowerSrc.endsWith('.ogg')) {
            this._html5MediaType = 'video/ogg';
        } else if (lowerSrc.endsWith('.webm')) {
            this._html5MediaType = 'video/webm';
        } else {
            this._html5MediaType = '';
            this.addDebugWarn('src', 'Video file/URL \'' + this.src + '\' might not supported in all browsers (.mp4 or .webm files and Youtube or Vimeo links are recommended)');
        }

        this._typeIsHtml5 = true;
        this.async(function () {
            _this7._html5Element = _this7.$$('#html5Element');
            _this7._html5Element.volume = _this7.volume;
        });
        this.preload = this.preload ? 'auto' : 'none';
    },

    _initiateYoutube: function _initiateYoutube() {
        var _this8 = this;

        var match = this.src.match(/^.*(youtu\.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*).*/);
        if (match && match[2].length == 11) {
            this._youtubeVideoId = match[2];

            this._typeIsYoutube = true;
            this.async(function () {
                _this8._youtubeElement = _this8.$$('#youtubeElement');
                _this8.listen(_this8._youtubeElement, 'google-youtube-ready', '_handleYoutubeReady');
                _this8.listen(_this8._youtubeElement, 'google-youtube-error', '_handleError');
                _this8.listen(_this8._youtubeElement, 'google-youtube-state-change', '_handleYoutubeStateChange');
                _this8.listen(_this8._youtubeElement, 'google-youtube-volume-change', '_handleVolumeChange');
            });
        } else {
            this.addDebugError('src', 'Invalid Youtube link \'' + this.src + '\'');
        }

        if (this.preload) {
            this.addDebugWarn('preload', 'Youtube video cannot be preloaded');
        }
    },

    _initiateVimeo: function _initiateVimeo() {
        var tempSrc = this.src.replace('vimeo.com', 'player.vimeo.com/video');
        this.src = tempSrc + '?loop=' + (this.loop ? '1' : '0') + '&controls=' + (this.controls ? '1' : '0');

        this._typeIsVimeo = true;
        this._vimeoCurrentTime = 0;

        if (this.preload) {
            this.addDebugWarn('preload', 'Vimeo video cannot be preloaded');
        }
    },

    _loadVimeoPlayer: function _loadVimeoPlayer() {
        var _this9 = this;

        this.async(function () {
            _this9._vimeoElement = new Vimeo.Player(_this9.$$('#vimeoElement'));
            _this9._vimeoElement.ready().then(_this9._handleVimeoReady.bind(_this9));
            _this9._vimeoElement.on('error', _this9._handleError.bind(_this9));
            _this9._vimeoElement.on('play', _this9._handleVimeoPlay.bind(_this9));
            _this9._vimeoElement.on('pause', _this9._handlePause.bind(_this9));
            _this9._vimeoElement.on('ended', _this9._handlePause.bind(_this9));
            _this9._vimeoElement.on('volumechange', _this9._handleVolumeChange.bind(_this9));

            _this9._vimeoElement.on('timeupdate', _this9._handleVimeoTimeUpdate.bind(_this9));

            Promise.all([_this9._vimeoElement.getVideoWidth(), _this9._vimeoElement.getVideoHeight()]).then(function (dimensions) {
                _this9.customStyle['--vimeo-padding-top'] = 100 * dimensions[1] / dimensions[0] + '%';
                _this9.updateStyles();
            });
        });
    },

    _savePlaybackInfo: function _savePlaybackInfo() {
        if (this._typeIsHtml5) {
            var playedData = [];
            var playedDuration = 0;

            var playedTimeRanges = this._html5Element.played;
            for (var i = 0; i < playedTimeRanges.length; i++) {
                var start = playedTimeRanges.start(i);
                var end = playedTimeRanges.end(i);
                playedData.push({ start: start, end: end });
                playedDuration += end - start;
            }

            this.addTrackEvent('video-playback', {
                video: this.name,
                played: playedData,
                playedPercent: Math.round(playedDuration * 100 / this._html5Element.duration) || 0
            });
        }
    },

    get _currentTime() {
        if (this._typeIsHtml5) {
            return Math.round(this._html5Element.currentTime);
        } else if (this._typeIsYoutube) {
            return this._youtubeElement.currenttime;
        } else if (this._typeIsVimeo) {
            return this._vimeoCurrentTime;
        }
    },

    _handlePlay: function _handlePlay() {
        this.setBuiltinProp('playing', true);
        this.addTrackEvent('video-play', { video: this.name, currentTime: this._currentTime });
    },

    _handlePause: function _handlePause() {
        this.setBuiltinProp('playing', false);
        this.addTrackEvent('video-pause', { video: this.name, currentTime: this._currentTime });
    },

    _handleVolumeChange: function _handleVolumeChange(event) {
        var value = void 0;
        if (this._typeIsHtml5) {
            value = this._html5Element.muted ? 0 : this._html5Element.volume;
        } else if (this._typeIsYoutube) {
            value = this._youtubeElement.volume / 100;
        } else if (this._typeIsVimeo) {
            value = event.volume;
        }
        this.volume = value;
        this.setBuiltinProp('volume', value);
    },

    _handleError: function _handleError() {
        this.addDebugError('src', 'Error loading video \'' + this.src + '\'');
    },

    _handleHtml5Load: function _handleHtml5Load() {
        var naturalAspect = this._html5Element.videoWidth / this._html5Element.videoHeight;
        var aspect = this.offsetWidth / this.offsetHeight;

        if (aspect > naturalAspect + 0.05) {
            this.addDebugWarn('width\' and \'height', 'Video \'' + this.src + '\' might be letterboxed on the sides because its aspect ratio (width/height) is greater than the natural aspect ratio of the original file');
        } else if (aspect < naturalAspect - 0.05) {
            this.addDebugWarn('width\' and \'height', 'Video \'' + this.src + '\' might be letterboxed at the top and bottom because its aspect ratio (width/height) is less than the natural aspect ratio of the original file');
        }
    },

    _handleYoutubeReady: function _handleYoutubeReady() {
        this._youtubeReady = true;
        this._youtubeElement.setVolume(this.volume * 100);
        if (this._youtubeSavedTime && this.autoplay) {
            this._youtubeElement.seekTo(this._youtubeSavedTime);
            this._youtubeSavedTime = null;
        }
    },

    _handleYoutubeStateChange: function _handleYoutubeStateChange(_ref13) {
        var state = _ref13.detail.data;

        if (state === 1) {
            if (this._youtubeSavedTime) {
                this._youtubeElement.seekTo(this._youtubeSavedTime);
                this._youtubeSavedTime = null;
            }
            this._handlePlay();
        } else if (state === 0 || state === 2) {
            this._handlePause();
        }
    },

    _handleVimeoReady: function _handleVimeoReady() {
        this._vimeoReady = true;
        this._vimeoElement.setVolume(this.volume);
        if (this.autoplay) {
            this._vimeoElement.setCurrentTime(this._vimeoSavedTime || 0);
            this._vimeoSavedTime = null;
        }
    },

    _handleVimeoPlay: function _handleVimeoPlay() {
        if (this._vimeoSavedTime) {
            this._vimeoElement.setCurrentTime(this._vimeoSavedTime);
            this._vimeoSavedTime = null;
        }
        this._handlePlay();
    },

    _handleVimeoTimeUpdate: function _handleVimeoTimeUpdate(_ref14) {
        var seconds = _ref14.seconds;

        this._vimeoCurrentTime = seconds;
    }
});
var EffectAttribute = {

    properties: {
        effect: String
    },

    ready: function ready() {
        this._validEffectsData = {
            'blur': { default: 1, min: 0, suffix: 'px' },
            'brightness': { default: 1, min: 0 },
            'contrast': { default: 1, min: 0 },

            'grayscale': { default: 1, min: 0, max: 1 },
            'hue-rotate': { default: 180, min: 0, max: 360, suffix: 'deg' },
            'invert': { default: 1, min: 0, max: 1 },
            'opacity': { default: 1, min: 0, max: 1 },
            'saturate': { default: 1, min: 0 },
            'sepia': { default: 1, min: 0, max: 1 }
        };

        this.effectsObject = {};
        this._currentEffects = {};
        this._parseEffects();
    },

    addEffects: function addEffects() {
        var attrElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;
        var transition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '0.3s';

        var addData = attrElement.effectsObject;
        this.style['transition'] = transition + ' ease-in-out';

        if (Object.keys(addData).length > 0) {
            for (var key in addData) {
                if (!this._currentEffects.hasOwnProperty(key)) {
                    this._currentEffects[key] = addData[key];
                }
            }

            this._updateEffects();
        }
    },

    removeEffects: function removeEffects() {
        var attrElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;
        var transition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '0.3s';

        var removeData = attrElement.effectsObject;
        this.style['transition'] = transition + ' ease-in-out';

        if (Object.keys(removeData).length > 0) {
            for (var key in removeData) {
                if (this._currentEffects.hasOwnProperty(key)) {
                    delete this._currentEffects[key];
                }
            }

            this._updateEffects();
        }
    },

    _parseEffects: function _parseEffects() {
        if (this.effect) {
            var effects = this.effect.replace(/\s/g, '').split(',');

            var _iteratorNormalCompletion34 = true;
            var _didIteratorError34 = false;
            var _iteratorError34 = undefined;

            try {
                for (var _iterator34 = effects[Symbol.iterator](), _step34; !(_iteratorNormalCompletion34 = (_step34 = _iterator34.next()).done); _iteratorNormalCompletion34 = true) {
                    var effect = _step34.value;

                    var splitResult = effect.split(':');
                    var name = splitResult[0];
                    var value = splitResult[1];
                    if (splitResult[2]) {
                        this.addDebugWarn('effect', '\'' + splitResult.slice(2).join('\', \'') + '\' unused because only one parameter is needed for \'' + name + '\' effect');
                    }

                    var effectData = this._validEffectsData[name];
                    if (effectData === undefined) {
                        this.addDebugError('effect', '\'' + name + '\' is not a valid effect name');
                    } else {
                        if (value !== undefined) {
                            if (isNaN(value)) {
                                this.addDebugError('effect', '\'' + value + '\' is not a valid effect parameter. Default value \'' + effectData.default + '\' used');
                                value = effectData.default;
                            } else {
                                if (effectData.min && Number(value) < effectData.min) {
                                    this.addDebugWarn('effect', 'Parameter \'' + value + '\' is less than the minimum allowed value \'' + effectData.min + '\' for the \'' + name + '\' effect. Default value \'' + effectData.default + '\' used');
                                    value = effectData.default;
                                }

                                if (effectData.max && Number(value) > effectData.max) {
                                    this.addDebugWarn('effect', 'Parameter \'' + value + '\' is more than the maximum allowed value \'' + effectData.max + '\' for the \'' + name + '\' effect. Default value \'' + effectData.default + '\' used');
                                    value = effectData.default;
                                }
                            }
                        } else {
                            value = effectData.default;
                        }

                        var suffix = effectData.suffix === undefined ? '' : effectData.suffix;

                        this.effectsObject[effect] = name + '(' + value + suffix + ')';
                    }
                }
            } catch (err) {
                _didIteratorError34 = true;
                _iteratorError34 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion34 && _iterator34.return) {
                        _iterator34.return();
                    }
                } finally {
                    if (_didIteratorError34) {
                        throw _iteratorError34;
                    }
                }
            }
        }
    },

    _updateEffects: function _updateEffects() {
        var cssString = '';
        for (var key in this._currentEffects) {
            cssString += ' ' + this._currentEffects[key];
        }

        this.style['filter'] = cssString;
        this.style['-webkit-filter'] = cssString;
    }
};
var AnimationAttribute = {

    properties: {
        animation: String
    },

    ready: function ready() {
        this._validAnimationNames = ['bounce', 'flash', 'pulse', 'rubberBand', 'shake', 'headShake', 'swing', 'tada', 'wobble', 'jello', 'bounceIn', 'bounceInDown', 'bounceInLeft', 'bounceInRight', 'bounceInUp', 'bounceOut', 'bounceOutDown', 'bounceOutLeft', 'bounceOutRight', 'bounceOutUp', 'fadeIn', 'fadeInDown', 'fadeInDownBig', 'fadeInLeft', 'fadeInLeftBig', 'fadeInRight', 'fadeInRightBig', 'fadeInUp', 'fadeInUpBig', 'fadeOut', 'fadeOutDown', 'fadeOutDownBig', 'fadeOutLeft', 'fadeOutLeftBig', 'fadeOutRight', 'fadeOutRightBig', 'fadeOutUp', 'fadeOutUpBig', 'flip', 'flipInX', 'flipInY', 'flipOutX', 'flipOutY', 'lightSpeedIn', 'lightSpeedOut', 'rotateIn', 'rotateInDownLeft', 'rotateInDownRight', 'rotateInUpLeft', 'rotateInUpRight', 'rotateOut', 'rotateOutDownLeft', 'rotateOutDownRight', 'rotateOutUpLeft', 'rotateOutUpRight', 'hinge', 'rollIn', 'rollOut', 'zoomIn', 'zoomInDown', 'zoomInLeft', 'zoomInRight', 'zoomInUp', 'zoomOut', 'zoomOutDown', 'zoomOutLeft', 'zoomOutRight', 'zoomOutUp', 'slideInDown', 'slideInLeft', 'slideInRight', 'slideInUp', 'slideOutDown', 'slideOutLeft', 'slideOutRight', 'slideOutUp'];

        this._animationParameters = ['name', 'duration', 'iteration-count', 'delay'];

        Polymer.dom(this).classList.add('animationSpan');

        this.animationsObject = {};
        this._currentAnimations = {};
        this._parseAnimations();
    },

    addAnimations: function addAnimations() {
        var attrElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;

        var addData = attrElement.animationsObject;

        if (Object.keys(addData).length > 0) {
            for (var key in addData) {
                if (!this._currentAnimations.hasOwnProperty(key)) {
                    this._currentAnimations[key] = addData[key];
                }
            }

            this._updateAnimations();
        }
    },

    removeAnimations: function removeAnimations() {
        var attrElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;

        var removeData = attrElement.animationsObject;

        if (Object.keys(removeData).length > 0) {
            for (var key in removeData) {
                if (this._currentAnimations.hasOwnProperty(key)) {
                    delete this._currentAnimations[key];
                }
            }

            this._updateAnimations();
        }
    },

    _parseAnimations: function _parseAnimations() {
        if (this.animation) {
            var animations = this.animation.replace(/\s/g, '').split(',');

            var delay = 0;

            var _iteratorNormalCompletion35 = true;
            var _didIteratorError35 = false;
            var _iteratorError35 = undefined;

            try {
                for (var _iterator35 = animations[Symbol.iterator](), _step35; !(_iteratorNormalCompletion35 = (_step35 = _iterator35.next()).done); _iteratorNormalCompletion35 = true) {
                    var anim = _step35.value;

                    var splitResult = anim.split(':');

                    var name = null;
                    var duration = null;
                    var iteration = null;

                    var _iteratorNormalCompletion36 = true;
                    var _didIteratorError36 = false;
                    var _iteratorError36 = undefined;

                    try {
                        for (var _iterator36 = splitResult[Symbol.iterator](), _step36; !(_iteratorNormalCompletion36 = (_step36 = _iterator36.next()).done); _iteratorNormalCompletion36 = true) {
                            var value = _step36.value;


                            if (this._validAnimationNames.includes(value) || value === 'wait') {
                                if (name === null) {
                                    name = value;
                                } else {
                                    this.addDebugWarn(prop, '\'' + value + '\' unused in \'' + anim + '\' because animation type already set to \'' + name + '\'');
                                }
                            } else if (!isNaN(value) || value === 'infinite') {
                                if (iteration === null) {
                                    iteration = value;
                                } else {
                                    this.addDebugWarn(prop, '\'' + value + '\' unused in \'' + anim + '\' because animation count already set to \'' + iteration + '\'');
                                }
                            } else if (value.endsWith('s') && !isNaN(value.slice(0, -1))) {
                                if (duration === null) {
                                    duration = Number(value.slice(0, -1));
                                } else {
                                    this.addDebugWarn(prop, '\'' + value + '\' unused in \'' + anim + '\' because animation duration already set to \'' + duration + '\'');
                                }
                            } else if (value.endsWith('ms') && !isNaN(value.slice(0, -2))) {
                                if (duration === null) {
                                    duration = Number(value.slice(0, -2)) / 1000;
                                } else {
                                    this.addDebugWarn(prop, '\'' + value + '\' unused in \'' + anim + '\' because animation duration already set to \'' + duration + '\'');
                                }
                            } else {
                                this.addDebugError(prop, '\'' + value + '\' is not a valid animation parameter');
                            }
                        }
                    } catch (err) {
                        _didIteratorError36 = true;
                        _iteratorError36 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion36 && _iterator36.return) {
                                _iterator36.return();
                            }
                        } finally {
                            if (_didIteratorError36) {
                                throw _iteratorError36;
                            }
                        }
                    }

                    if (name === null) {
                        this.addDebugError(prop, 'No animation type specified in \'' + anim + '\'');
                    } else if (name === 'wait') {
                        duration = duration === null ? 1 : duration;
                        delay += duration;

                        if (iteration !== null) {
                            this.addDebugWarn(prop, '\'' + iteration + '\' unused in \'' + anim + '\' because \'wait\' does not need animation count');
                        }
                    } else {
                        duration = duration === null ? '1s' : duration + 's';
                        iteration = iteration === null ? 1 : iteration;

                        var dataObject = {
                            'name': name,
                            'duration': duration,
                            'iteration-count': iteration,
                            'delay': delay + 's'
                        };
                        this.animationsObject[anim] = dataObject;
                    }
                }
            } catch (err) {
                _didIteratorError35 = true;
                _iteratorError35 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion35 && _iterator35.return) {
                        _iterator35.return();
                    }
                } finally {
                    if (_didIteratorError35) {
                        throw _iteratorError35;
                    }
                }
            }
        }
    },

    _updateAnimations: function _updateAnimations() {
        var _iteratorNormalCompletion37 = true;
        var _didIteratorError37 = false;
        var _iteratorError37 = undefined;

        try {
            for (var _iterator37 = this._animationParameters[Symbol.iterator](), _step37; !(_iteratorNormalCompletion37 = (_step37 = _iterator37.next()).done); _iteratorNormalCompletion37 = true) {
                var animParam = _step37.value;

                var cssArray = [];
                for (var key in this._currentAnimations) {
                    cssArray.push(this._currentAnimations[key][animParam]);
                }

                this.style['animation-' + animParam] = cssArray.toString();
                this.style['-webkit-animation-' + animParam] = cssArray.toString();
            }
        } catch (err) {
            _didIteratorError37 = true;
            _iteratorError37 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion37 && _iterator37.return) {
                    _iterator37.return();
                }
            } finally {
                if (_didIteratorError37) {
                    throw _iteratorError37;
                }
            }
        }
    }
};
Polymer({
    is: 'inkd-style',

    behaviors: [InkdBehavior, EffectAttribute, AnimationAttribute],

    ready: function ready() {
        this.addEffects();
        this.addAnimations();
    }
});
Polymer({
    is: 'inkd-box',

    behaviors: [InkdBehavior, NameAttribute, EffectAttribute, AnimationAttribute, LayoutAttribute, ThemeAttribute],

    ready: function ready() {
        this.ondragstart = function () {
            return false;
        };

        this._eventSwapTracker = 0;

        this.addLayout();
        this.addTheme();
    },

    handleEvent: function handleEvent(eventElement) {
        var transitionData = eventElement.transitionData,
            overlayElement = eventElement.overlayElement;

        this.$.defaultContent.addEffects(eventElement, transitionData.fadeTime);
        this.$.defaultContent.addAnimations(eventElement);

        if (overlayElement) {
            clearTimeout(overlayElement.fadeTimer);

            if (transitionData.slideDirection) {
                this.$.slideContent.appendChild(overlayElement);
            } else {
                this.$.overlayContent.appendChild(overlayElement);
            }

            window.getComputedStyle(overlayElement).opacity;
            overlayElement.style.left = eventElement.x;
            overlayElement.style.top = eventElement.y;
            overlayElement.style.opacity = 1;

            if (eventElement.swap) {
                this._eventSwapTracker++;

                if (this._eventSwapTracker > 0) {
                    this.$.defaultContent.style.opacity = 0;
                }
            }
        }
    },

    handleToggleEvent: function handleToggleEvent(eventElement) {
        var _this10 = this;

        var transitionData = eventElement.transitionData,
            overlayElement = eventElement.overlayElement;

        this.$.defaultContent.removeEffects(eventElement, transitionData.fadeTime);
        this.$.defaultContent.removeAnimations(eventElement);

        if (overlayElement) {
            overlayElement.style.opacity = 0;
            switch (transitionData.slideDirection) {
                case 'right':
                    overlayElement.style.left = '-100%';
                    break;
                case 'left':
                    overlayElement.style.left = '100%';
                    break;
                case 'up':
                    overlayElement.style.top = '100%';
                    break;
                case 'down':
                    overlayElement.style.top = '-100%';
                    break;
            }
            var match = transitionData.fadeTime.match(/^(.+)(m?s)$/);
            var _time2 = match[2] === 'ms' ? Number(match[1]) : Number(match[1]) * 1000;

            overlayElement.fadeTimer = setTimeout(function () {
                if (transitionData.slideDirection) {
                    _this10.$.slideContent.removeChild(overlayElement);
                } else {
                    _this10.$.overlayContent.removeChild(overlayElement);
                }
            }, _time2);

            if (eventElement.swap) {
                this._eventSwapTracker--;

                if (this._eventSwapTracker === 0) {
                    this.$.defaultContent.style.opacity = 1;
                }
            }
        }
    }
});
var EventBehaviorImpl = {
    properties: {
        box: String,
        on: String,
        swap: Boolean,
        x: {
            type: String,
            value: '0px'
        },
        y: {
            type: String,
            value: '0px'
        },
        transition: String,

        noToggle: Boolean
    },

    ready: function ready() {
        this.onGlobalAttach('_initiate');

        this.x = '' + this.x + (isNaN(this.x) ? '' : 'px');
        this.y = '' + this.y + (isNaN(this.y) ? '' : 'px');

        this._initiateTransition();
    },

    detached: function detached() {
        if (this._eventOn) {
            this._handleToggleEvent();
        }
    },

    initiateEvents: function initiateEvents(event, toggleEvent) {
        this.event = event;
        this.toggleEvent = toggleEvent;
    },

    _initiate: function _initiate() {
        if (this.box) {
            var element = this.getGlobalNameElement(this.box, 'inkd-box', 'box');
            if (element !== undefined) {
                this.eventBox = element;
            }
        } else {
            var parent = Polymer.dom(this).parentNode;
            while (parent !== null) {
                if (parent.tagName === 'INKD-BOX') {
                    this.eventBox = parent;
                    break;
                } else {
                    parent = Polymer.dom(parent).parentNode;
                }
            }

            if (parent === null) {
                this.addDebugError(null, 'No \'box\' specified for \'' + this.event + '\' event and no parent <inkd-box> found');
            }
        }

        if (this.eventBox) {
            this.applyBox = this.eventBox;

            if (this.on) {
                var _element2 = this.getGlobalNameElement(this.on, 'inkd-box', 'on');
                if (_element2 !== undefined) {
                    this.applyBox = _element2;
                }
            }

            this.listen(this.eventBox, this.event, '_handleEvent');

            if (!this.noToggle && this.toggleEvent !== this.event) {
                this.listen(this.eventBox, this.toggleEvent, '_handleToggleEvent');
            }

            if (Polymer.dom(this).childNodes.length > 0) {
                this.overlayElement = document.createElement('span');
                this.overlayElement.className = this.className;
                this.overlayElement.style.cssText = 'position: absolute; opacity: 0;    \n                        transition: opacity ' + this.transitionData.fadeTime + ' ease-in-out, top ' + this.transitionData.slideTime + ', left ' + this.transitionData.slideTime + ';';

                switch (this.transitionData.slideDirection) {
                    case 'right':
                        this.overlayElement.style.left = '-100%';
                        break;
                    case 'left':
                        this.overlayElement.style.left = '100%';
                        break;
                    case 'up':
                        this.overlayElement.style.top = '100%';
                        break;
                    case 'down':
                        this.overlayElement.style.top = '-100%';
                        break;
                }
                Polymer.dom(this.overlayElement).innerHTML = Polymer.dom(this).innerHTML;
            }
        }

        this.style.display = 'none';
    },

    _initiateTransition: function _initiateTransition() {
        var defaultTime = '0.3s';
        this.transitionData = { fadeTime: defaultTime, slideTime: defaultTime };

        if (this.transition) {
            var splitResult = this.transition.replace(/\s/g, '').split(',');
            var _iteratorNormalCompletion38 = true;
            var _didIteratorError38 = false;
            var _iteratorError38 = undefined;

            try {
                for (var _iterator38 = splitResult[Symbol.iterator](), _step38; !(_iteratorNormalCompletion38 = (_step38 = _iterator38.next()).done); _iteratorNormalCompletion38 = true) {
                    var splitPart = _step38.value;

                    var match = splitPart.match(/^([^:]+):(.+)$/);
                    if (match) {
                        var _match3 = _slicedToArray(match, 3),
                            key = _match3[1],
                            value = _match3[2];

                        if (key === 'fade') {
                            var valueMatch = value.match(/^\d+(?:\.\d+)?((?:m?s)?)$/);
                            if (valueMatch) {
                                this.transitionData.fadeTime = value + (valueMatch[1] ? '' : 's');
                            } else {
                                this.addDebugError('transition', '\'' + value + '\' is not valid transition fade value');
                            }
                        } else if (key === 'slide') {
                            var _valueMatch = value.match(/^(right|left|up|down):(\d+(?:\.\d+)?((?:m?s)?))?$/);
                            if (_valueMatch) {
                                this.transitionData.slideDirection = _valueMatch[1];
                                this.transitionData.slideTime = _valueMatch[2] ? _valueMatch[2] + (_valueMatch[3] ? '' : 's') : defaultTime;
                            } else {
                                this.addDebugError('transition', '\'' + value + '\' is not valid transition slide value');
                            }
                        } else {
                            this.addDebugError('transition', '\'' + key + '\' is not a valid transition property (Supported properties: fade, slide)');
                        }
                    } else {
                        this.addDebugError('transition', '\'' + splitPart + '\' is not a valid transition property declaration');
                    }
                }
            } catch (err) {
                _didIteratorError38 = true;
                _iteratorError38 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion38 && _iterator38.return) {
                        _iterator38.return();
                    }
                } finally {
                    if (_didIteratorError38) {
                        throw _iteratorError38;
                    }
                }
            }
        }
    },

    _handleEvent: function _handleEvent() {
        this._eventOn = true;

        this.applyBox.handleEvent(this);
        this.handleActions();

        if (this.noToggle) {
            this.unlisten(this.eventBox, this.event, '_handleEvent');
        } else if (this.toggleEvent === this.event) {
            this.unlisten(this.eventBox, this.event, '_handleEvent');
            this.listen(this.eventBox, this.toggleEvent, '_handleToggleEvent');
        }
    },

    _handleToggleEvent: function _handleToggleEvent() {
        this._eventOn = false;

        this.applyBox.handleToggleEvent(this);
        this.undoActions();

        if (this.toggleEvent === this.event) {
            this.unlisten(this.eventBox, this.toggleEvent, '_handleToggleEvent');
            this.listen(this.eventBox, this.event, '_handleEvent');
        }
    }
};

var EventBehavior = [InkdBehavior, EffectAttribute, AnimationAttribute, ActionAttributes, EventBehaviorImpl];
Polymer({
    is: 'inkd-click',

    behaviors: [EventBehavior],

    ready: function ready() {
        this.initiateEvents('tap', 'tap');
    }
});
Polymer({
    is: 'inkd-over',

    behaviors: [EventBehavior],

    ready: function ready() {
        this.initiateEvents('mouseover', 'mouseout');
    }
});
Polymer({
    is: 'inkd-down',

    behaviors: [EventBehavior],

    ready: function ready() {
        this.initiateEvents('down', 'up');
    }
});
Polymer({
    is: 'inkd-a',

    properties: {
        href: String,
        node: String,
        props: String,
        tabindex: {
            type: Number,
            min: -1,
            max: 32767,
            value: 0,
            desc: 'tab order',
            reflectToAttribute: true
        }
    },

    behaviors: [InkdBehavior],

    listeners: {
        'tap': '_handleTap'
    },

    ready: function ready() {
        if (this.href === undefined) {
            this.addDebugError('href', 'No link specified');
        } else {
            if (this.node === undefined) {
                this.addDebugWarn('node', 'No node specified for \'' + this.href + '\'. Default starting node will be used');
            }

            this.props = this.props ? this.props.replace(/\s/g, '').split(',') : [];
            this._propsData = {};
        }
    },

    _updatePropsData: function _updatePropsData() {
        var _iteratorNormalCompletion39 = true;
        var _didIteratorError39 = false;
        var _iteratorError39 = undefined;

        try {
            for (var _iterator39 = this.props[Symbol.iterator](), _step39; !(_iteratorNormalCompletion39 = (_step39 = _iterator39.next()).done); _iteratorNormalCompletion39 = true) {
                var key = _step39.value;

                var data = this.getGlobalProp(key);
                if (data === undefined) {
                    this.addDebugError('props', 'Property \'' + key + '\' has not been set');
                } else if (data.propType === 'element') {
                    this.addDebugError('props', '\'' + key + '\' refers to \'name\' attribute of an <' + data.propValue.tagName.toLowerCase() + '> element');
                } else {
                    this._propsData[key] = data.propValue;
                }
            }
        } catch (err) {
            _didIteratorError39 = true;
            _iteratorError39 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion39 && _iterator39.return) {
                    _iterator39.return();
                }
            } finally {
                if (_didIteratorError39) {
                    throw _iteratorError39;
                }
            }
        }
    },

    get _queryString() {
        var stringArray = this.node ? ['node=' + this.node] : [];
        for (var key in this._propsData) {
            var value = this._propsData[key];
            value = typeof value === 'string' ? '\'' + value + '\'' : value;
            stringArray.push('prop-' + key + '=' + value);
        }

        return stringArray.length > 0 ? '?' + encodeURI(stringArray.join('&')) : '';
    },

    _handleTap: function _handleTap() {
        if (this.href !== undefined) {
            this._updatePropsData();
            location.assign(this.href + this._queryString);
            this.addTrackEvent('link-click', { link: this.href, node: this.node, props: this._propsData });
        }
    }
});
Polymer({
    is: 'inkd-modal',

    properties: {
        width: String,
        height: String,
        x: String,
        y: String,
        noClose: {
            type: Boolean,
            value: false
        },
        noFullscreen: {
            type: Boolean,
            value: false
        }
    },

    behaviors: [InkdBehavior, NameAttribute, LayoutAttribute, ThemeAttribute],

    ready: function ready() {
        this.setBuiltinProp('showing', false);

        var _arr3 = ['width', 'height', 'x', 'y'];
        for (var _i3 = 0; _i3 < _arr3.length; _i3++) {
            var _prop4 = _arr3[_i3];
            this[_prop4] = '' + this[_prop4] + (isNaN(this[_prop4]) ? '' : 'px');
        }

        this._showModal = true;
    },

    attached: function attached() {
        if (!this._initiated) {
            this._showModal = false;
            this._initiated = true;
        }
    },

    show: function show() {
        this._showModal = true;
        this.setBuiltinProp('showing', true);
        if (!this.noFullscreen) {
            document.body.classList.add('modal-shown');
        }

        if (!this._layoutInitiated) {
            Polymer.dom(this).flush();
            this.addLayout(this, this.$$('#window'));
            this.addTheme(this, this.$$('#window'));
            this._layoutInitiated = true;
        }
        this.addTrackEvent('modal-show', { modal: this.name });
    },

    hide: function hide() {
        this._showModal = false;
        this.setBuiltinProp('showing', false);
        if (!this.noFullscreen) {
            document.body.classList.remove('modal-shown');
        }
        this.addTrackEvent('modal-hide', { modal: this.name });
    },

    _handleOverlayTap: function _handleOverlayTap() {
        if (!this.noClose) {
            this.hide();
        }
    },

    _cancelEvent: function _cancelEvent(event) {
        event.stopPropagation();
    }
});
Polymer({
    is: 'inkd-textarea',

    properties: {
        autofocus: Boolean,
        tabindex: {
            type: Number,
            min: -1,
            max: 32767,
            value: 0,
            desc: 'tab order'
        },
        saveRemote: Boolean
    },

    behaviors: [InkdBehavior, NameAttribute],

    ready: function ready() {
        var _this11 = this;

        this._initialValue = Polymer.dom(this).textContent.trim();

        this.setBuiltinProps({ value: this._initialValue, focused: false });

        if (this.saveRemote && this.name === undefined) {
            this.addDebugError('save-remote', 'Textarea needs a \'name\' for remote saving');
            this.saveRemote = false;
        }

        this.async(function () {
            _this11._textareaElement = _this11.$$('#textareaElement');
        });
    },

    attached: function attached() {
        if (!this._initiated && this.saveRemote) {
            this.fire('get-remote', { keys: this.name, callback: '_getValue' });
            this._initiated = true;
        }
        if (this.autofocus) {
            this._textareaElement.focus();
            Polymer.dom(this).classList.add('focused');
            this.setBuiltinProp('focused', true);
        }
    },

    validate: function validate() {
        return true;
    },

    reset: function reset() {
        this._textareaElement.value = this._initialValue;
        this.setBuiltinProp('value', this._initialValue);
        this._saveValue();
    },

    _getValue: function _getValue(data) {
        this._textareaElement.value = data[this.name] || '';
    },

    _saveValue: function _saveValue() {
        if (this.saveRemote) {
            var data = {};
            data[this.name] = this._textareaElement.value.trim();
            this.fire('save-remote', data);
        }
        this.addTrackEvent('textarea-save', { textarea: this.name, value: this._textareaElement.value.trim() });
    },

    _handleInput: function _handleInput() {
        this.setBuiltinProp('value', this._textareaElement.value.trim());
    },

    _handleChange: function _handleChange() {
        this._saveValue();
    },

    _handleFocus: function _handleFocus() {
        Polymer.dom(this).classList.add('focused');
        this.setBuiltinProp('focused', true);
    },

    _handleBlur: function _handleBlur() {
        Polymer.dom(this).classList.remove('focused');
        this.setBuiltinProp('focused', false);
    }
});
var TaskBehaviorImpl = {
    properties: {
        goto: String,
        autoValidate: Boolean
    },

    ready: function ready() {
        this.setBuiltinProps({ done: false, correct: null, feedback: '' });

        if (this.goto) {
            this.goto = this.goto.replace(/\s/g, '').split(',');
        }

        this.taskCorrect = null;
        this._initiateFeedback();
    },

    setTaskDependents: function setTaskDependents(elementArray) {
        this._taskDependents = elementArray;
        var _iteratorNormalCompletion40 = true;
        var _didIteratorError40 = false;
        var _iteratorError40 = undefined;

        try {
            for (var _iterator40 = elementArray[Symbol.iterator](), _step40; !(_iteratorNormalCompletion40 = (_step40 = _iterator40.next()).done); _iteratorNormalCompletion40 = true) {
                var element = _step40.value;

                this.listen(element, 'done-changed', '_handleDoneChange');
                this.listen(element, 'correct-changed', '_handleCorrectChange');
                this.listen(element, 'task-goto', '_handleTaskGoto');
            }
        } catch (err) {
            _didIteratorError40 = true;
            _iteratorError40 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion40 && _iterator40.return) {
                    _iterator40.return();
                }
            } finally {
                if (_didIteratorError40) {
                    throw _iteratorError40;
                }
            }
        }
    },

    set taskDone(value) {
        if (value !== this._taskDone) {
            this._taskDone = value;
            this.setBuiltinProp('done', value);

            var eventData = { value: value };
            if (value) {
                if (this.autoValidate) {
                    this.validateTask();
                }

                if (this.goto || this._unresolvedGotoData) {
                    var _ref15;

                    var gotoData = (_ref15 = []).concat.apply(_ref15, _toConsumableArray(this._unresolvedGotos || []).concat(_toConsumableArray(this.goto ? [{ element: this, gotos: this.goto }] : [])));
                    if (this.handleTaskGoto) {
                        var unresolvedData = this.handleTaskGoto(gotoData);
                        if (unresolvedData) {
                            this.fireNavigate(unresolvedData);
                        }
                    } else {
                        eventData.gotoData = gotoData;
                    }
                    this._unresolvedGotos = null;
                }
            }

            this.fire('done-changed', eventData);
        }
    },

    get taskDone() {
        return this._taskDone;
    },

    set taskCorrect(value) {
        if (value !== this._taskCorrect) {
            this._taskCorrect = value;
            this.setBuiltinProp('correct', value);

            if (value === null) {
                this.taskFeedback = '';
            } else {
                this.taskFeedback = value ? this._correctFeedback : this._wrongFeedback;
            }

            this.fire('correct-changed', { value: value });
        }
    },

    get taskCorrect() {
        return this._taskCorrect;
    },

    set taskFeedback(value) {
        this._taskFeedback = value;
        this.setBuiltinProp('feedback', value);
    },

    get taskFeedback() {
        return this._taskFeedback;
    },

    validateTask: function validateTask() {
        if (this._taskDependents) {
            var _iteratorNormalCompletion41 = true;
            var _didIteratorError41 = false;
            var _iteratorError41 = undefined;

            try {
                for (var _iterator41 = this._taskDependents[Symbol.iterator](), _step41; !(_iteratorNormalCompletion41 = (_step41 = _iterator41.next()).done); _iteratorNormalCompletion41 = true) {
                    var element = _step41.value;

                    element.validateTask();
                }
            } catch (err) {
                _didIteratorError41 = true;
                _iteratorError41 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion41 && _iterator41.return) {
                        _iterator41.return();
                    }
                } finally {
                    if (_didIteratorError41) {
                        throw _iteratorError41;
                    }
                }
            }
        } else {
            this.validate();
        }
    },

    resetTask: function resetTask() {
        if (this._taskDependents) {
            var _iteratorNormalCompletion42 = true;
            var _didIteratorError42 = false;
            var _iteratorError42 = undefined;

            try {
                for (var _iterator42 = this._taskDependents[Symbol.iterator](), _step42; !(_iteratorNormalCompletion42 = (_step42 = _iterator42.next()).done); _iteratorNormalCompletion42 = true) {
                    var element = _step42.value;

                    element.resetTask();
                }
            } catch (err) {
                _didIteratorError42 = true;
                _iteratorError42 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion42 && _iterator42.return) {
                        _iterator42.return();
                    }
                } finally {
                    if (_didIteratorError42) {
                        throw _iteratorError42;
                    }
                }
            }
        } else {
            this.reset(false);
        }
    },

    _initiateFeedback: function _initiateFeedback() {
        this._correctFeedback = '';
        this._wrongFeedback = '';

        this._feedbackElements = Polymer.dom(this).children.filter(function (el) {
            return el.tagName === 'INKD-FEEDBACK';
        });
        var _iteratorNormalCompletion43 = true;
        var _didIteratorError43 = false;
        var _iteratorError43 = undefined;

        try {
            for (var _iterator43 = this._feedbackElements[Symbol.iterator](), _step43; !(_iteratorNormalCompletion43 = (_step43 = _iterator43.next()).done); _iteratorNormalCompletion43 = true) {
                var element = _step43.value;

                if (element.hasAttribute('wrong')) {
                    this._wrongFeedback += element.outerHTML;
                } else {
                    this._correctFeedback += element.outerHTML;
                }
            }
        } catch (err) {
            _didIteratorError43 = true;
            _iteratorError43 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion43 && _iterator43.return) {
                    _iterator43.return();
                }
            } finally {
                if (_didIteratorError43) {
                    throw _iteratorError43;
                }
            }
        }

        if (this._feedbackElements.length > 0) {
            this.onGlobalAttach('_removeFeedback');
        }

        if (this.taskDone) {
            this.taskFeedback = this.taskCorrect ? this._correctFeedback : this._wrongFeedback;
        }
    },

    _removeFeedback: function _removeFeedback() {
        var _iteratorNormalCompletion44 = true;
        var _didIteratorError44 = false;
        var _iteratorError44 = undefined;

        try {
            for (var _iterator44 = this._feedbackElements[Symbol.iterator](), _step44; !(_iteratorNormalCompletion44 = (_step44 = _iterator44.next()).done); _iteratorNormalCompletion44 = true) {
                var element = _step44.value;

                element.domRemove();
            }
        } catch (err) {
            _didIteratorError44 = true;
            _iteratorError44 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion44 && _iterator44.return) {
                    _iterator44.return();
                }
            } finally {
                if (_didIteratorError44) {
                    throw _iteratorError44;
                }
            }
        }
    },

    _handleDoneChange: function _handleDoneChange(event) {
        event.stopPropagation();
        var _event$detail4 = event.detail,
            value = _event$detail4.value,
            gotoData = _event$detail4.gotoData;


        if (gotoData) {
            this._unresolvedGotoData = gotoData;
        }
        this.taskDone = value && this._taskDependents.every(function (element) {
            return element.taskDone;
        });
        if (this._unresolvedGotoData) {
            if (this.handleTaskGoto) {
                var unresolvedData = this.handleTaskGoto(this._unresolvedGotoData);
                if (unresolvedData) {
                    this.fireNavigate(unresolvedData);
                }
            } else {
                this.fire('task-goto', { gotoData: this._unresolvedGotoData });
            }
            this._unresolvedGotoData = null;
        }
    },

    _handleCorrectChange: function _handleCorrectChange(event) {
        event.stopPropagation();
        var value = event.detail.value;

        this.taskCorrect = this.taskDone ? this._taskDependents.every(function (element) {
            return element.taskCorrect;
        }) : null;
    },

    _handleTaskGoto: function _handleTaskGoto(event) {
        var gotoData = event.detail.gotoData;

        if (this.handleTaskGoto) {
            event.stopPropagation();
            var unresolvedData = this.handleTaskGoto(gotoData);
            if (unresolvedData) {
                this.fire('goto', { gotoData: unresolvedData });
            }
        }
    }
};

var TaskBehavior = [NameAttribute, TaskBehaviorImpl];
Polymer({
    is: 'inkd-drag-section',

    properties: {
        label: String
    },

    behaviors: [InkdBehavior, TaskBehavior, GotoElement],

    ready: function ready() {
        this.enforceAncestor('inkd-dd');

        this._dragElements = Polymer.dom(this).querySelectorAll('inkd-draggable');

        if (this._dragElements.length > 0) {
            this.setTaskDependents(this._dragElements);
            this.onGlobalAttach('_initiateChildren');
        } else {
            this.addDebugError(null, 'No <inkd-draggable> children found');
        }
    },

    validate: function validate() {},

    reset: function reset() {
        this.resetTask();
    },

    _initiateChildren: function _initiateChildren() {
        var _iteratorNormalCompletion45 = true;
        var _didIteratorError45 = false;
        var _iteratorError45 = undefined;

        try {
            for (var _iterator45 = this._dragElements[Symbol.iterator](), _step45; !(_iteratorNormalCompletion45 = (_step45 = _iterator45.next()).done); _iteratorNormalCompletion45 = true) {
                var element = _step45.value;

                element.dragSectionParent = this;
            }
        } catch (err) {
            _didIteratorError45 = true;
            _iteratorError45 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion45 && _iterator45.return) {
                    _iterator45.return();
                }
            } finally {
                if (_didIteratorError45) {
                    throw _iteratorError45;
                }
            }
        }
    }
});
Polymer({
    is: 'inkd-drop-section',

    properties: {
        label: String,
        correct: String,
        allow: String,
        reject: String,
        allowMultiple: Boolean
    },

    behaviors: [InkdBehavior, TaskBehavior, GotoElement],

    listeners: {
        'reset': '_handleReset'
    },

    ready: function ready() {
        this.enforceAncestor('inkd-dd');

        this.correct = this.correct === undefined ? [] : this.correct.replace(/\s/g, '').split(',');

        this.allow = this.allow === undefined ? [] : this.allow.replace(/\s/g, '').split(',');
        this.reject = this.reject === undefined ? [] : this.reject.replace(/\s/g, '').split(',');

        if (this.allow.length > 0 && this.reject.length > 0) {
            this.addDebugWarn(null, '\'reject\' = "' + this.reject.join(', ') + '" unused because \'allow\' is defined');
            this.reject = [];
        }

        this._dropElements = Polymer.dom(this).querySelectorAll('inkd-droptarget');

        if (this._dropElements.length > 0) {
            this.setTaskDependents(this._dropElements);
            this.onGlobalAttach('_initiateChildren');
        } else {
            this.addDebugError(null, 'No <inkd-droptarget> children found');
        }
    },

    validate: function validate() {},

    reset: function reset() {
        var track = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

        if (track) {
            this.fire('reset', { sectionElement: this });
        }
        this.resetTask();
    },

    _initiateChildren: function _initiateChildren() {
        var _this12 = this;

        var _iteratorNormalCompletion46 = true;
        var _didIteratorError46 = false;
        var _iteratorError46 = undefined;

        try {
            var _loop4 = function _loop4() {
                var _element$correct;

                var element = _step46.value;

                element.dropSectionParent = _this12;
                element.allowMultiple = element.allowMultiple || _this12.allowMultiple;
                element.correct = (_element$correct = element.correct).concat.apply(_element$correct, _toConsumableArray(_this12.correct));
                if (element.allow.length > 0 || _this12.allow.length > 0) {
                    var _element$allow;

                    element.allow = (_element$allow = element.allow).concat.apply(_element$allow, _toConsumableArray(_this12.allow));
                    element.allow = element.allow.filter(function (name) {
                        return !element.reject.includes(name);
                    });
                    element.reject = [];
                } else {
                    var _element$reject;

                    element.reject = (_element$reject = element.reject).concat.apply(_element$reject, _toConsumableArray(_this12.reject));
                }
            };

            for (var _iterator46 = this._dropElements[Symbol.iterator](), _step46; !(_iteratorNormalCompletion46 = (_step46 = _iterator46.next()).done); _iteratorNormalCompletion46 = true) {
                _loop4();
            }
        } catch (err) {
            _didIteratorError46 = true;
            _iteratorError46 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion46 && _iterator46.return) {
                    _iterator46.return();
                }
            } finally {
                if (_didIteratorError46) {
                    throw _iteratorError46;
                }
            }
        }
    },

    _handleReset: function _handleReset(_ref16) {
        var detail = _ref16.detail;

        detail.sectionElement = this;
    }
});
Polymer({
    is: 'inkd-draggable',

    properties: {},

    behaviors: [InkdBehavior, TaskBehavior],

    listeners: {
        'dragstart': '_handleDragstart'
    },

    observers: ['_handleDropParentChange(dropParent)'],

    ready: function ready() {
        this.enforceAncestor('inkd-drag-section', 'inkd-droptarget');

        Polymer.dom(this).setAttribute('draggable', true);
        this.dropParent = null;
    },

    validate: function validate() {},

    reset: function reset() {
        if (this.domParent.tagName === 'INKD-DROPTARGET') {
            this.domParent.addDraggable(this);
        } else {
            Polymer.dom(this.domParent).appendChild(this);
            this.dropParent = null;
        }
    },

    _handleDropParentChange: function _handleDropParentChange() {
        this.taskDone = this.dropParent !== null;
        this.taskCorrect = this.taskDone ? this.dropParent.correct.includes(this.name) : null;
    },

    _checkRemovable: function _checkRemovable(dropParent) {
        return dropParent && !(dropParent.noRemove || dropParent === this._originalParent);
    },

    _handleDragstart: function _handleDragstart(event) {
        event.dataTransfer.setData('text/plain', 'firefox-drag-fix');

        this.fire('dragged', { dragElement: this });
    }
});
Polymer({
    is: 'inkd-droptarget',

    properties: {
        correct: String,
        allow: String,
        reject: String,
        allowMultiple: Boolean
    },

    behaviors: [InkdBehavior, TaskBehavior],

    listeners: {
        'drop': '_handleDrop',
        'dragenter': '_handleDragenter',
        'dragover': '_handleDragover',
        'dragleave': '_handleDragleave'
    },

    observers: ['_handleDragChildrenChange(dragChildren.splices)'],

    ready: function ready() {
        this.enforceAncestor('inkd-drop-section');

        this.setBuiltinProps({ draggableText: '', draggableHtml: '', draggableFeedback: '' });

        this.correct = this.correct === undefined ? [] : this.correct.replace(/\s/g, '').split(',');

        this.allow = this.allow === undefined ? [] : this.allow.replace(/\s/g, '').split(',');
        this.reject = this.reject === undefined ? [] : this.reject.replace(/\s/g, '').split(',');

        var repeated = this.reject.filter(function (name) {
            return this.allow.includes(name);
        }.bind(this));
        if (repeated.length > 0) {
            this.addDebugWarn(null, '\'' + repeated.join('\', \'') + '\' unused in \'reject\' because already used in \'allow\'');
            this.reject = this.reject.filter(function (name) {
                return !repeated.includes(name);
            });
        }

        this.dragChildren = Polymer.dom(this).querySelectorAll('inkd-draggable');

        if (this.dragChildren.length > 0) {
            this.onGlobalAttach('_initiateChildren');
        }
    },

    addDraggable: function addDraggable(element) {
        Polymer.dom(this).appendChild(element);
        element.dropParent = this;

        this.push('dragChildren', element);
    },

    removeDraggable: function removeDraggable(element) {
        Polymer.dom(this).removeChild(element);
        element.reset();
        var index = this.dragChildren.findIndex(function (child) {
            return child === element;
        });

        this.splice('dragChildren', index, 1);
    },

    checkIfAllowed: function checkIfAllowed(_ref17) {
        var name = _ref17.name;

        if (this.allow.length > 0) {
            return name && this.allow.includes(name);
        } else {
            return !(name && this.reject.includes(name));
        }
    },

    validate: function validate() {},

    reset: function reset() {
        var track = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

        if (track) {
            this.fire('reset', { dropElement: this });
        }
        var _iteratorNormalCompletion47 = true;
        var _didIteratorError47 = false;
        var _iteratorError47 = undefined;

        try {
            for (var _iterator47 = this.dragChildren[Symbol.iterator](), _step47; !(_iteratorNormalCompletion47 = (_step47 = _iterator47.next()).done); _iteratorNormalCompletion47 = true) {
                var _element3 = _step47.value;

                this.removeDraggable(_element3);
            }
        } catch (err) {
            _didIteratorError47 = true;
            _iteratorError47 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion47 && _iterator47.return) {
                    _iterator47.return();
                }
            } finally {
                if (_didIteratorError47) {
                    throw _iteratorError47;
                }
            }
        }
    },

    _initiateChildren: function _initiateChildren() {
        var _iteratorNormalCompletion48 = true;
        var _didIteratorError48 = false;
        var _iteratorError48 = undefined;

        try {
            for (var _iterator48 = this.dragChildren.entries()[Symbol.iterator](), _step48; !(_iteratorNormalCompletion48 = (_step48 = _iterator48.next()).done); _iteratorNormalCompletion48 = true) {
                var _step48$value = _slicedToArray(_step48.value, 2),
                    index = _step48$value[0],
                    _element4 = _step48$value[1];

                _element4.dropParent = this;
            }
        } catch (err) {
            _didIteratorError48 = true;
            _iteratorError48 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion48 && _iterator48.return) {
                    _iterator48.return();
                }
            } finally {
                if (_didIteratorError48) {
                    throw _iteratorError48;
                }
            }
        }
    },

    _checkDragRemovable: function _checkDragRemovable(element) {
        return element.domParent.tagName !== 'INKD-DROPTARGET';
    },

    _handleDragChildrenChange: function _handleDragChildrenChange() {
        this.taskDone = this.dragChildren.length > 0;
        this.taskCorrect = this.taskDone ? this.dragChildren.every(function (element) {
            return element.taskCorrect;
        }) : null;
        this._showPlaceholder = !this.taskDone;

        var value = this.dragChildren.reduce(function (text, element) {
            return text + Polymer.dom(element).textContent.trim() + '<br>';
        }, '');
        this.setBuiltinProp('draggableText', value);

        value = this.dragChildren.reduce(function (html, element) {
            return html + '<div>' + Polymer.dom(element).innerHTML + '</div>';
        }, '');
        this.setBuiltinProp('draggableHtml', value);

        value = this.dragChildren.reduce(function (feed, element) {
            return feed + element.taskFeedback;
        }, '');
        this.setBuiltinProp('draggableFeedback', value);

        var _iteratorNormalCompletion49 = true;
        var _didIteratorError49 = false;
        var _iteratorError49 = undefined;

        try {
            for (var _iterator49 = this.dragChildren.entries()[Symbol.iterator](), _step49; !(_iteratorNormalCompletion49 = (_step49 = _iterator49.next()).done); _iteratorNormalCompletion49 = true) {
                var _step49$value = _slicedToArray(_step49.value, 2),
                    index = _step49$value[0],
                    _element5 = _step49$value[1];

                Polymer.dom(_element5).setAttribute('data-index', index);
            }
        } catch (err) {
            _didIteratorError49 = true;
            _iteratorError49 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion49 && _iterator49.return) {
                    _iterator49.return();
                }
            } finally {
                if (_didIteratorError49) {
                    throw _iteratorError49;
                }
            }
        }
    },

    _handleDrop: function _handleDrop(event) {
        event.preventDefault();
        Polymer.dom(this).classList.remove('dragover');
        this.fire('dropped', { dropElement: this });
    },

    _handleDragenter: function _handleDragenter(event) {
        event.preventDefault();
    },

    _handleDragover: function _handleDragover(event) {
        event.preventDefault();
        Polymer.dom(this).classList.add('dragover');
        this.fire('dragged-over', { dropElement: this });
    },

    _handleDragleave: function _handleDragleave() {
        Polymer.dom(this).classList.remove('dragover');
        this.fire('dragged-out', { dropElement: this });
    },

    _handleRemove: function _handleRemove(_ref18) {
        var index = _ref18.target.dataset.index;

        var element = this.dragChildren[index];
        this.removeDraggable(element);

        this.fire('removed', { dragElement: element, dropElement: this });
    }
});
Polymer({
    is: 'inkd-dd',

    properties: {
        noMenu: {
            type: Boolean,
            value: false
        },
        noLinkedSections: {
            type: Boolean,
            value: false
        }
    },

    behaviors: [InkdBehavior, TaskBehavior],

    listeners: {
        'dragged': '_handleDrag',
        'dragged-over': '_handleDraggedOver',
        'dragged-out': '_handleDraggedOut',
        'dropped': '_handleDrop',
        'removed': '_handleRemove',
        'goto': '_handleGoto',
        'reset': '_handleReset'
    },

    observers: ['_computeTemplateVariables(noMenu, noLinkedSections, _dragData.sections.length, _dropData.sections.length)'],

    ready: function ready() {
        MobileDragDrop.polyfill({
            dragImageTranslateOverride: MobileDragDrop.scrollBehaviourDragImageTranslateOverride
        });

        window.addEventListener('touchmove', function () {});

        var dragSections = Polymer.dom(this).children.filter(function (element) {
            return element.tagName === 'INKD-DRAG-SECTION';
        });
        var dropSections = Polymer.dom(this).children.filter(function (element) {
            return element.tagName === 'INKD-DROP-SECTION';
        });

        this._dragData = { sections: dragSections, gotoIndexes: {} };
        this._dropData = { sections: dropSections, gotoIndexes: {} };

        if (dropSections.length === 0) {
            this.addDebugError(null, 'No <inkd-drop-section> children found');
        } else {
            this.setTaskDependents(dropSections);

            if (dragSections.length > 0) {
                var _iteratorNormalCompletion50 = true;
                var _didIteratorError50 = false;
                var _iteratorError50 = undefined;

                try {
                    for (var _iterator50 = dragSections.entries()[Symbol.iterator](), _step50; !(_iteratorNormalCompletion50 = (_step50 = _iterator50.next()).done); _iteratorNormalCompletion50 = true) {
                        var _step50$value = _slicedToArray(_step50.value, 2),
                            index = _step50$value[0],
                            section = _step50$value[1];

                        Polymer.dom(section).setAttribute('active-section', 'false');
                        if (section.name) {
                            this._dragData.gotoIndexes[section.name] = index;
                        }
                    }
                } catch (err) {
                    _didIteratorError50 = true;
                    _iteratorError50 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion50 && _iterator50.return) {
                            _iterator50.return();
                        }
                    } finally {
                        if (_didIteratorError50) {
                            throw _iteratorError50;
                        }
                    }
                }

                this._updateSection('drag', 0);

                this._sectionsLinked = dragSections.length === dropSections.length;
            }

            var _iteratorNormalCompletion51 = true;
            var _didIteratorError51 = false;
            var _iteratorError51 = undefined;

            try {
                for (var _iterator51 = dropSections.entries()[Symbol.iterator](), _step51; !(_iteratorNormalCompletion51 = (_step51 = _iterator51.next()).done); _iteratorNormalCompletion51 = true) {
                    var _step51$value = _slicedToArray(_step51.value, 2),
                        index = _step51$value[0],
                        section = _step51$value[1];

                    Polymer.dom(section).setAttribute('active-section', 'false');
                    if (section.name) {
                        this._dropData.gotoIndexes[section.name] = index;
                    }
                }
            } catch (err) {
                _didIteratorError51 = true;
                _iteratorError51 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion51 && _iterator51.return) {
                        _iterator51.return();
                    }
                } finally {
                    if (_didIteratorError51) {
                        throw _iteratorError51;
                    }
                }
            }

            this._updateSection('drop', 0);
        }
    },

    validate: function validate() {},

    reset: function reset() {
        this.resetTask();

        this.addTrackEvent('dd-reset', { dd: this.name });

        this._updateSection('drag', 0);
        this._updateSection('drop', 0);
    },

    handleTaskGoto: function handleTaskGoto(gotoData) {
        var data = {
            drag: { otherType: 'drop', gotoIndexes: this._dragData.gotoIndexes },
            drop: { otherType: 'drag', gotoIndexes: this._dropData.gotoIndexes }
        };

        var taskGotoData = { drag: null, drop: null, unresolved: [] };
        var _iteratorNormalCompletion52 = true;
        var _didIteratorError52 = false;
        var _iteratorError52 = undefined;

        try {
            for (var _iterator52 = gotoData[Symbol.iterator](), _step52; !(_iteratorNormalCompletion52 = (_step52 = _iterator52.next()).done); _iteratorNormalCompletion52 = true) {
                var _step52$value = _step52.value,
                    _element6 = _step52$value.element,
                    gotos = _step52$value.gotos;

                var elementData = { element: _element6, drag: null, drop: null, unresolved: [] };
                var _iteratorNormalCompletion53 = true;
                var _didIteratorError53 = false;
                var _iteratorError53 = undefined;

                try {
                    for (var _iterator53 = gotos[Symbol.iterator](), _step53; !(_iteratorNormalCompletion53 = (_step53 = _iterator53.next()).done); _iteratorNormalCompletion53 = true) {
                        var _goto2 = _step53.value;

                        var value = this.getGlobalPropValue(_goto2);
                        var gotoName = typeof value === 'string' || value === null ? value : _goto2;

                        if (gotoName === null) {
                            this.addDebugWarn('goto', '\'' + _goto2 + '\' does not exist yet', _element6);
                        } else if (gotoName === 'next' || gotoName === 'prev') {
                            if (data.drag.gotoIndexes[gotoName + '-drag'] === null) {
                                if (this._sectionsLinked) {
                                    this.addDebugWarn('goto', '\'' + _goto2 + '\' unused because ' + (gotoName === 'prev' ? 'previous' : 'next') + ' drag-drop linked sections do not exist', _element6);
                                } else {
                                    this.addDebugWarn('goto', '\'' + _goto2 + '\' unused because ' + (gotoName === 'prev' ? 'previous' : 'next') + ' drag section does not exist', _element6);
                                }
                            } else {
                                this._resolveGotoData(_goto2, gotoName + '-drag', 'drag', elementData);
                            }
                            if (!this._sectionsLinked) {
                                if (data.drop.gotoIndexes[gotoName + '-drop'] === null) {
                                    this.addDebugWarn('goto', '\'' + _goto2 + '\' unused because ' + (gotoName === 'prev' ? 'previous' : 'next') + ' drop section does not exist', _element6);
                                } else {
                                    this._resolveGotoData(_goto2, gotoName + '-drop', 'drop', elementData);
                                }
                            }
                        } else if (data.drag.gotoIndexes.hasOwnProperty(gotoName)) {
                            if (data.drag.gotoIndexes[gotoName] === null) {
                                this.addDebugWarn('goto', '\'' + _goto2 + '\' unused because ' + (gotoName.startsWith('prev') ? 'previous' : 'next') + ' drag section does not exist', _element6);
                            } else {
                                this._resolveGotoData(_goto2, gotoName, 'drag', elementData);
                            }
                        } else if (data.drop.gotoIndexes.hasOwnProperty(gotoName)) {
                            if (data.drop.gotoIndexes[gotoName] === null) {
                                this.addDebugWarn('goto', '\'' + _goto2 + '\' unused because ' + (gotoName.startsWith('prev') ? 'previous' : 'next') + ' drop section does not exist', _element6);
                            } else {
                                this._resolveGotoData(_goto2, gotoName, 'drop', elementData);
                            }
                        } else {
                            elementData.unresolved.push(_goto2);
                        }
                    }
                } catch (err) {
                    _didIteratorError53 = true;
                    _iteratorError53 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion53 && _iterator53.return) {
                            _iterator53.return();
                        }
                    } finally {
                        if (_didIteratorError53) {
                            throw _iteratorError53;
                        }
                    }
                }

                for (var _type in data) {
                    if (taskGotoData[_type] === null && elementData[_type] !== null && !(this._sectionsLinked && taskGotoData[data[_type].otherType] !== null)) {
                        taskGotoData[_type] = elementData[_type];
                    }
                }

                if (elementData.unresolved.length > 0) {
                    taskGotoData.unresolved.push({ element: _element6, gotos: elementData.unresolved });
                }
            }
        } catch (err) {
            _didIteratorError52 = true;
            _iteratorError52 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion52 && _iterator52.return) {
                    _iterator52.return();
                }
            } finally {
                if (_didIteratorError52) {
                    throw _iteratorError52;
                }
            }
        }

        for (var type in data) {
            if (taskGotoData[type] !== null) {
                var index = data[type].gotoIndexes[taskGotoData[type]];
                this._updateSection(type, index);
                if (this._sectionsLinked) {
                    this._updateSection(data[type].otherType, index);
                }
            }
        }

        if (taskGotoData.unresolved.length > 0) {
            return taskGotoData.unresolved;
        }
    },

    _resolveGotoData: function _resolveGotoData(goto, gotoName, type, elementData) {
        var element = elementData.element;

        var otherType = type === 'drag' ? 'drop' : 'drag';
        if (elementData[type] === null) {
            if (!(this._sectionsLinked && elementData[otherType] !== null)) {
                elementData[type] = gotoName;
                elementData[type + 'Goto'] = goto;
            } else {
                this.addDebugWarn('goto', '\'' + goto + '\' unused because \'' + elementData[otherType + 'Goto'] + '\' already refers to a linked section in the same <inkd-dd>', element);
            }
        } else {
            this.addDebugWarn('goto', '\'' + goto + '\' unused because \'' + elementData[type + 'Goto'] + '\' already refers to a ' + type + ' section in the same <inkd-dd>', element);
        }
    },

    _computeTemplateVariables: function _computeTemplateVariables(noMenu, noLinkedSections, numDragSections, numDropSections) {
        this.showLinkedMenu = numDragSections === numDropSections && numDragSections > 1 && !noMenu && !noLinkedSections;
        this.showDragSection = numDragSections > 0;
        this.showDragMenu = numDragSections > 1 && !noMenu && !this.showLinkedMenu;
        this.showDropMenu = numDropSections > 1 && !noMenu && !this.showLinkedMenu;
    },

    _checkDisabledButton: function _checkDisabledButton(sectionIndex, currentIndex) {
        return sectionIndex === currentIndex;
    },

    _getMenuLabel: function _getMenuLabel(sectionElement, sectionIndex) {
        if (this.showLinkedMenu) {
            return this._dragData.sections[sectionIndex].label || this._dropData.sections[sectionIndex].label || 'Section ' + (sectionIndex + 1);
        }
        return sectionElement.label || 'Section ' + (sectionIndex + 1);
    },

    _updateSection: function _updateSection(type, index) {
        var data = this['_' + type + 'Data'];
        var sections = data.sections,
            currentIndex = data.currentIndex;


        if (index !== currentIndex) {
            if (currentIndex !== undefined) {
                Polymer.dom(sections[currentIndex]).setAttribute('active-section', 'false');
            }

            this.set('_' + type + 'Data.currentIndex', index);

            var section = sections[index];
            Polymer.dom(section).setAttribute('active-section', 'true');

            data.gotoIndexes['next-' + type] = index < sections.length - 1 ? index + 1 : null;
            data.gotoIndexes['prev-' + type] = index > 0 ? index - 1 : null;

            this.addTrackEvent(type + '-section-change', {
                dd: this.name,
                section: section.name || section.label || 'Section ' + (index + 1)
            }, section);
        }
    },


    _handleMenuTap: function _handleMenuTap(_ref19) {
        var _ref19$currentTarget$ = _ref19.currentTarget.dataset,
            type = _ref19$currentTarget$.type,
            index = _ref19$currentTarget$.index;

        this._updateSection(type, Number(index));
        if (this._sectionsLinked) {
            this._updateSection(type === 'drag' ? 'drop' : 'drag', Number(index));
        }
    },

    _handleDrag: function _handleDrag(_ref20) {
        var dragElement = _ref20.detail.dragElement;

        this._draggedElement = dragElement;
    },

    _handleDraggedOver: function _handleDraggedOver(_ref21) {
        var dropElement = _ref21.detail.dropElement;

        if (!dropElement.checkIfAllowed(this._draggedElement)) {
            Polymer.dom(this._draggedElement).classList.add('not-allowed');
            Polymer.dom(dropElement).classList.add('not-allowed');
        }
    },

    _handleDraggedOut: function _handleDraggedOut(_ref22) {
        var dropElement = _ref22.detail.dropElement;

        Polymer.dom(this._draggedElement).classList.remove('not-allowed');
        Polymer.dom(dropElement).classList.remove('not-allowed');
    },

    _handleDrop: function _handleDrop(_ref23) {
        var dropElement = _ref23.detail.dropElement;

        Polymer.dom(this._draggedElement).classList.remove('not-allowed');
        Polymer.dom(dropElement).classList.remove('not-allowed');

        var dropSectionEl = dropElement.dropSectionParent;

        if (dropElement.checkIfAllowed(this._draggedElement)) {

            var currentDragChild = dropElement.dragChildren[0];
            var currentDropParent = this._draggedElement.dropParent;

            if (currentDropParent) {
                currentDropParent.removeDraggable(this._draggedElement);
            }

            if (!dropElement.allowMultiple) {
                if (currentDragChild) {
                    dropElement.removeDraggable(currentDragChild);

                    if (currentDropParent) {
                        currentDropParent.addDraggable(currentDragChild);
                    }
                }
            }

            dropElement.addDraggable(this._draggedElement);

            this.addTrackEvent('draggable-add', {
                dd: this.name,
                droptarget: dropElement.name || dropElement.textContent.trim(),
                draggable: this._draggedElement.name || this._draggedElement.textContent.trim(),
                correct: this._draggedElement.taskCorrect
            }, this._draggedElement);
        }
    },

    _handleRemove: function _handleRemove(_ref24) {
        var _ref24$detail = _ref24.detail,
            dragElement = _ref24$detail.dragElement,
            dropElement = _ref24$detail.dropElement;

        var index = this._dragData.sections.indexOf(dragElement.dragSectionParent);
        this._updateSection('drag', index);
        if (this._sectionsLinked) {
            this._updateSection('drop', index);
        }

        this.addTrackEvent('draggable-remove', {
            dd: this.name,
            droptarget: dropElement.name || dropElement.textContent.trim(),
            draggable: dragElement.name || dragElement.textContent.trim()
        }, dragElement);
    },

    _handleGoto: function _handleGoto(event) {
        var gotoData = event.detail.gotoData;

        var unresolvedData = this.handleTaskGoto(gotoData);
        if (unresolvedData) {
            event.detail.gotoData = unresolvedData;
        } else {
            event.stopPropagation();
        }
    },

    _handleReset: function _handleReset(event) {
        event.stopPropagation();
        var _event$detail5 = event.detail,
            sectionElement = _event$detail5.sectionElement,
            dropElement = _event$detail5.dropElement;

        var data = {
            dd: this.name,
            section: sectionElement.name || sectionElement.label || 'Section ' + (this._dragData.sections.indexOf(sectionElement) + 1)
        };
        var trackEvent = void 0;
        if (dropElement === undefined) {
            trackEvent = 'drop-section-reset';
        } else {
            trackEvent = 'droptarget-reset';
            data.droptarget = dropElement.name || dropElement.textContent.trim();
        }
        this.addTrackEvent(trackEvent, data);
    }
});
Polymer({
    is: 'inkd-mc-section',

    properties: {
        allowMultiple: Boolean,
        required: Boolean
    },

    behaviors: [InkdBehavior, TaskBehavior, GotoElement],

    listeners: {
        'reset': '_handleReset'
    },

    ready: function ready() {
        this.enforceAncestor('inkd-mc');

        this._questions = Polymer.dom(this).querySelectorAll('inkd-mc-question');

        if (this._questions.length > 0) {
            this.setTaskDependents(this._questions);

            this.onGlobalAttach('_initiateChildren');
        } else {
            this.addDebugError(null, 'No <inkd-mc-question> children found');
        }
    },

    validate: function validate() {
        this.validateTask();
    },

    reset: function reset() {
        var track = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

        if (track) {
            this.fire('reset', { sectionElement: this });
        }
        this.resetTask();
    },

    get disableNext() {
        return this._questions.some(function (element) {
            return element.disableNext;
        });
    },

    _initiateChildren: function _initiateChildren() {
        var _iteratorNormalCompletion54 = true;
        var _didIteratorError54 = false;
        var _iteratorError54 = undefined;

        try {
            for (var _iterator54 = this._questions[Symbol.iterator](), _step54; !(_iteratorNormalCompletion54 = (_step54 = _iterator54.next()).done); _iteratorNormalCompletion54 = true) {
                var _element7 = _step54.value;

                _element7.allowMultiple = _element7.allowMultiple || this.allowMultiple;
                _element7.required = _element7.required || this.required;
            }
        } catch (err) {
            _didIteratorError54 = true;
            _iteratorError54 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion54 && _iterator54.return) {
                    _iterator54.return();
                }
            } finally {
                if (_didIteratorError54) {
                    throw _iteratorError54;
                }
            }
        }
    },

    _handleReset: function _handleReset(_ref25) {
        var detail = _ref25.detail;

        detail.sectionElement = this;
    }
});
Polymer({
    is: 'inkd-mc-question',

    properties: {
        allowMultiple: Boolean,
        required: Boolean
    },

    behaviors: [InkdBehavior, TaskBehavior, GotoElement],

    listeners: {
        'changed': '_handleChange'
    },

    observers: ['_handleSelectedOptionsChange(_selectedOptions.splices)'],

    ready: function ready() {
        this.enforceAncestor('inkd-mc-section');

        this.setBuiltinProps({ optionText: '', optionHtml: '', optionFeedback: '', optionMultimedia: '' });

        this._options = Polymer.dom(this).querySelectorAll('inkd-mc-option');

        if (this._options.length > 0) {
            this._selectedOptions = [];
            this.onGlobalAttach('_initiateChildren');
        } else {
            this.addDebugError(null, 'No <inkd-mc-option> children found');
        }
    },

    validate: function validate() {
        this.validateTask();
    },

    reset: function reset() {
        var track = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

        if (track) {
            this.fire('reset', { questionElement: this });
        }
        var _iteratorNormalCompletion55 = true;
        var _didIteratorError55 = false;
        var _iteratorError55 = undefined;

        try {
            for (var _iterator55 = this._options[Symbol.iterator](), _step55; !(_iteratorNormalCompletion55 = (_step55 = _iterator55.next()).done); _iteratorNormalCompletion55 = true) {
                var _element8 = _step55.value;

                _element8.reset();
            }
        } catch (err) {
            _didIteratorError55 = true;
            _iteratorError55 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion55 && _iterator55.return) {
                    _iterator55.return();
                }
            } finally {
                if (_didIteratorError55) {
                    throw _iteratorError55;
                }
            }
        }
    },

    get disableNext() {
        return this.required && !this.taskDone;
    },

    _initiateChildren: function _initiateChildren() {
        var id = 'mc-' + this.getGlobalUniqueId();
        var _iteratorNormalCompletion56 = true;
        var _didIteratorError56 = false;
        var _iteratorError56 = undefined;

        try {
            for (var _iterator56 = this._options.entries()[Symbol.iterator](), _step56; !(_iteratorNormalCompletion56 = (_step56 = _iterator56.next()).done); _iteratorNormalCompletion56 = true) {
                var _step56$value = _slicedToArray(_step56.value, 2),
                    index = _step56$value[0],
                    _element9 = _step56$value[1];

                Object.assign(_element9, { multiple: this.allowMultiple, questionId: id, index: index });

                if (_element9.checked) {
                    if (!this.allowMultiple && this._selectedOptions.length > 0) {
                        this.addDebugWarn(null, 'Only one <inkd-mc-option> can have the \'checked\' attribute by default (to allow multiple selection, use the flag \'allow-multiple\')');
                        Object.assign(_element9, { checked: false, initialChecked: false });
                    } else {
                        this.push('_selectedOptions', _element9);
                    }
                }
            }
        } catch (err) {
            _didIteratorError56 = true;
            _iteratorError56 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion56 && _iterator56.return) {
                    _iterator56.return();
                }
            } finally {
                if (_didIteratorError56) {
                    throw _iteratorError56;
                }
            }
        }
    },

    _handleSelectedOptionsChange: function _handleSelectedOptionsChange() {
        this.taskDone = this._selectedOptions.length > 0;
        this.taskCorrect = this.taskDone ? this._options.every(function (element) {
            return element.taskCorrect;
        }) : null;

        var value = this._selectedOptions.reduce(function (text, element) {
            return text + Polymer.dom(element).textContent.trim() + '<br>';
        }, '');
        this.setBuiltinProp('optionText', value);

        value = this._selectedOptions.reduce(function (html, element) {
            return html + '<div>' + Polymer.dom(element).innerHTML + '</div>';
        }, '');
        this.setBuiltinProp('optionHtml', value);

        value = this._selectedOptions.reduce(function (feed, element) {
            return feed + element.taskFeedback;
        }, '');
        this.setBuiltinProp('optionFeedback', value);

        value = this._selectedOptions.reduce(function (html, element) {
            return html + element.multimedia;
        }, '');
        this.setBuiltinProp('optionMultimedia', value);
    },

    _handleChange: function _handleChange(event) {
        var element = event.target;

        if (element.checked) {
            if (!this.allowMultiple) {
                var option = this._selectedOptions[0];
                if (option) {
                    option.checked = false;
                    this.pop('_selectedOptions');
                }
            }
            this.push('_selectedOptions', element);
        } else {
            var index = this._selectedOptions.findIndex(function (option) {
                return option === element;
            });
            this.splice('_selectedOptions', index, 1);
        }
        event.detail.questionElement = this;
    }
});
Polymer({
    is: 'inkd-mc-option',

    properties: {
        correct: Boolean,
        checked: {
            type: Boolean,
            value: false,
            reflectToAttribute: true,
            observer: '_handleCheckedChange'
        }
    },

    behaviors: [InkdBehavior, TaskBehavior],

    ready: function ready() {
        this.enforceAncestor('inkd-mc-question');

        this.initialChecked = this.checked;
        this.multiple = false;

        this._multimediaElements = Polymer.dom(this).querySelectorAll('inkd-mc-multimedia');

        this.multimedia = '';
        var _iteratorNormalCompletion57 = true;
        var _didIteratorError57 = false;
        var _iteratorError57 = undefined;

        try {
            for (var _iterator57 = this._multimediaElements[Symbol.iterator](), _step57; !(_iteratorNormalCompletion57 = (_step57 = _iterator57.next()).done); _iteratorNormalCompletion57 = true) {
                var _element10 = _step57.value;

                this.multimedia += _element10.outerHTML;
            }
        } catch (err) {
            _didIteratorError57 = true;
            _iteratorError57 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion57 && _iterator57.return) {
                    _iterator57.return();
                }
            } finally {
                if (_didIteratorError57) {
                    throw _iteratorError57;
                }
            }
        }

        this.onGlobalAttach('_removeMultimedia');
    },

    validate: function validate() {},

    reset: function reset() {
        this.checked = this.initialChecked;
    },

    _removeMultimedia: function _removeMultimedia() {
        var _iteratorNormalCompletion58 = true;
        var _didIteratorError58 = false;
        var _iteratorError58 = undefined;

        try {
            for (var _iterator58 = this._multimediaElements[Symbol.iterator](), _step58; !(_iteratorNormalCompletion58 = (_step58 = _iterator58.next()).done); _iteratorNormalCompletion58 = true) {
                var _element11 = _step58.value;

                _element11.domRemove();
            }
        } catch (err) {
            _didIteratorError58 = true;
            _iteratorError58 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion58 && _iterator58.return) {
                    _iterator58.return();
                }
            } finally {
                if (_didIteratorError58) {
                    throw _iteratorError58;
                }
            }
        }
    },

    _handleCheckedChange: function _handleCheckedChange() {
        var track = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

        this.taskDone = this.checked;
        this.taskCorrect = this.correct ? this.checked : !this.checked;
        this.fire('changed', { optionElement: this, track: track });
    },

    _handleTap: function _handleTap() {
        this.checked = !this.checked;
    }
});
Polymer({
    is: 'inkd-mc-multimedia',

    behaviors: [InkdBehavior]
});
Polymer({
    is: 'inkd-mc',

    properties: {
        noPrev: {
            type: Boolean,
            value: false
        }
    },

    behaviors: [InkdBehavior, TaskBehavior],

    listeners: {
        'changed': '_handleChange',
        'goto': '_handleGoto',
        'reset': '_handleReset'
    },

    observers: ['_computeTemplateVariables(_currentIndex)'],

    ready: function ready() {
        this._sections = Polymer.dom(this).children.filter(function (element) {
            return element.tagName === 'INKD-MC-SECTION';
        });

        this._gotoIndexes = {};
        if (this._sections.length === 0) {
            this.addDebugError(null, 'No <inkd-mc-section> children found');
        } else {
            this.setTaskDependents(this._sections);

            var _iteratorNormalCompletion59 = true;
            var _didIteratorError59 = false;
            var _iteratorError59 = undefined;

            try {
                for (var _iterator59 = this._sections.entries()[Symbol.iterator](), _step59; !(_iteratorNormalCompletion59 = (_step59 = _iterator59.next()).done); _iteratorNormalCompletion59 = true) {
                    var _step59$value = _slicedToArray(_step59.value, 2),
                        index = _step59$value[0],
                        _element12 = _step59$value[1];

                    Polymer.dom(_element12).setAttribute('active-section', 'false');
                    if (_element12.name) {
                        this._gotoIndexes[_element12.name] = index;
                    }
                }
            } catch (err) {
                _didIteratorError59 = true;
                _iteratorError59 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion59 && _iterator59.return) {
                        _iterator59.return();
                    }
                } finally {
                    if (_didIteratorError59) {
                        throw _iteratorError59;
                    }
                }
            }

            this._updateSection(0);
        }
    },

    validate: function validate() {},

    reset: function reset() {
        this.resetTask();

        this.addTrackEvent('mc-reset', { mc: this.name });

        this._updateSection(0);
    },

    handleTaskGoto: function handleTaskGoto(gotoData) {
        var taskGotoData = { section: null, unresolved: [] };
        var _iteratorNormalCompletion60 = true;
        var _didIteratorError60 = false;
        var _iteratorError60 = undefined;

        try {
            for (var _iterator60 = gotoData[Symbol.iterator](), _step60; !(_iteratorNormalCompletion60 = (_step60 = _iterator60.next()).done); _iteratorNormalCompletion60 = true) {
                var _step60$value = _step60.value,
                    _element13 = _step60$value.element,
                    gotos = _step60$value.gotos;

                var elementData = { section: null, unresolved: [] };
                var _iteratorNormalCompletion61 = true;
                var _didIteratorError61 = false;
                var _iteratorError61 = undefined;

                try {
                    for (var _iterator61 = gotos[Symbol.iterator](), _step61; !(_iteratorNormalCompletion61 = (_step61 = _iterator61.next()).done); _iteratorNormalCompletion61 = true) {
                        var _goto3 = _step61.value;

                        var value = this.getGlobalPropValue(_goto3);
                        var gotoName = typeof value === 'string' || value === null ? value : _goto3;

                        if (gotoName === null) {
                            this.addDebugWarn('goto', '\'' + _goto3 + '\' does not exist yet', _element13);
                        } else if (this._gotoIndexes.hasOwnProperty(gotoName)) {
                            if (this._gotoIndexes[gotoName] === null) {
                                this.addDebugWarn('goto', '\'' + _goto3 + '\' unused because ' + (gotoName === 'prev' ? 'previous' : 'next') + ' multiple choice section does not exist', _element13);
                            } else {
                                if (elementData.section === null) {
                                    elementData.section = gotoName;
                                    elementData.sectionGoto = _goto3;
                                } else {
                                    this.addDebugWarn('goto', '\'' + _goto3 + '\' unused because \'' + elementData.sectionGoto + '\' already refers to a section or question in the same <inkd-mc>', _element13);
                                }
                            }
                        } else {
                            elementData.unresolved.push(_goto3);
                        }
                    }
                } catch (err) {
                    _didIteratorError61 = true;
                    _iteratorError61 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion61 && _iterator61.return) {
                            _iterator61.return();
                        }
                    } finally {
                        if (_didIteratorError61) {
                            throw _iteratorError61;
                        }
                    }
                }

                if (elementData.section !== null && taskGotoData.section === null) {
                    taskGotoData.section = elementData.section;
                }
                if (elementData.unresolved.length > 0) {
                    taskGotoData.unresolved.push({ element: _element13, gotos: elementData.unresolved });
                }
            }
        } catch (err) {
            _didIteratorError60 = true;
            _iteratorError60 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion60 && _iterator60.return) {
                    _iterator60.return();
                }
            } finally {
                if (_didIteratorError60) {
                    throw _iteratorError60;
                }
            }
        }

        if (taskGotoData.section !== null) {
            var index = this._gotoIndexes[taskGotoData.section];
            this._updateSection(index);
        }

        if (taskGotoData.unresolved.length > 0) {
            return taskGotoData.unresolved;
        }
    },

    _computeTemplateVariables: function _computeTemplateVariables() {
        var numSections = this._sections.length;
        this._showPrevious = !this.noPrev && numSections > 1 && this._currentIndex > 0;
        this._showNext = numSections > 1 && this._currentIndex < numSections - 1;
        this._checkDisableNext();
    },

    _checkDisableNext: function _checkDisableNext() {
        if (this._sections) {
            var section = this._sections[this._currentIndex];
            this._disableNext = section.disableNext;
        }
    },

    _updateSection: function _updateSection(index) {
        if (index !== this._currentIndex) {
            if (this._currentIndex !== undefined) {
                Polymer.dom(this._sections[this._currentIndex]).setAttribute('active-section', 'false');
            }

            this._currentIndex = index;

            var section = this._sections[index];
            Polymer.dom(section).setAttribute('active-section', 'true');

            this._gotoIndexes['next'] = index < this._sections.length - 1 ? index + 1 : null;
            this._gotoIndexes['prev'] = index > 0 ? index - 1 : null;

            this.addTrackEvent('mc-section-change', {
                mc: this.name,
                section: section.name || 'Section ' + (index + 1)
            }, section);
        }
    },

    _handleNext: function _handleNext() {
        this._updateSection(this._currentIndex + 1);
    },

    _handlePrevious: function _handlePrevious() {
        this._updateSection(this._currentIndex - 1);
    },

    _handleChange: function _handleChange(event) {
        event.stopPropagation();
        this._checkDisableNext();

        var _event$detail6 = event.detail,
            optionElement = _event$detail6.optionElement,
            questionElement = _event$detail6.questionElement,
            track = _event$detail6.track;

        if (track) {
            var eventName = optionElement.checked ? 'mc-option-select' : 'mc-option-unselect';
            this.addTrackEvent(eventName, {
                mc: this.name,
                question: questionElement.name || Array.from(questionElement.childNodes).reduce(function (text, node) {
                    return text + (node.nodeType === Node.TEXT_NODE ? node.textContent.trim() : '');
                }, ''),
                option: optionElement.textContent.trim(),
                correct: optionElement.taskCorrect
            }, optionElement);
        }
    },

    _handleGoto: function _handleGoto(event) {
        var gotoData = event.detail.gotoData;

        var unresolvedData = this.handleTaskGoto(gotoData);
        if (unresolvedData) {
            event.detail.gotoData = unresolvedData;
        } else {
            event.stopPropagation();
        }
    },

    _handleReset: function _handleReset(event) {
        event.stopPropagation();
        var _event$detail7 = event.detail,
            sectionElement = _event$detail7.sectionElement,
            questionElement = _event$detail7.questionElement;

        var data = {
            mc: this.name,
            section: sectionElement.name || 'Section ' + (this._sections.indexOf(sectionElement) + 1)
        };
        var trackEvent = void 0;
        if (questionElement === undefined) {
            trackEvent = 'mc-section-reset';
        } else {
            trackEvent = 'mc-question-reset';
            data.question = questionElement.name || Array.from(questionElement.childNodes).reduce(function (text, node) {
                return text + (node.nodeType === Node.TEXT_NODE ? node.textContent.trim() : '');
            }, '');
        }
        this.addTrackEvent(trackEvent, data);
    }
});
Polymer({
    is: 'inkd-feedback',

    properties: {
        wrong: Boolean
    },

    behaviors: [InkdBehavior]
});
Polymer({
    is: 'inkd-list',

    properties: {
        data: Array,
        subindex: {
            type: String,
            value: ''
        }
    },

    behaviors: [InkdBehavior],

    _getLinkClasses: function _getLinkClasses(active, visited) {
        return 'link ' + (active ? 'active' : '') + ' ' + (visited ? 'visited' : '');
    },

    _getNumber: function _getNumber(index) {
        return '' + this.subindex + (index + 1) + '.';
    },

    _handleLinkTap: function _handleLinkTap(event) {
        event.preventDefault();
        event.stopPropagation();
        var index = event.currentTarget.dataset.index;
        var _data$index$link = this.data[index].link,
            eventName = _data$index$link.event,
            detail = _data$index$link.detail;

        this.fire(eventName, detail);
    },

    _handleTap: function _handleTap(event) {
        event.stopPropagation();
        var target = event.target,
            currentTarget = event.currentTarget;

        if (!['INKD-LIST', 'LI'].includes(target.tagName)) {
            currentTarget.classList.toggle('hide-list');
        }
    }
});
Polymer({
    is: 'inkd-outline',

    properties: {
        cyoa: String,
        data: String
    },

    behaviors: [InkdBehavior],

    listeners: {},

    ready: function ready() {
        this.data = this.data ? this.data.match(/(?:\\,|[^,])+/g) : [];
        var _iteratorNormalCompletion62 = true;
        var _didIteratorError62 = false;
        var _iteratorError62 = undefined;

        try {
            for (var _iterator62 = this.data.entries()[Symbol.iterator](), _step62; !(_iteratorNormalCompletion62 = (_step62 = _iterator62.next()).done); _iteratorNormalCompletion62 = true) {
                var _step62$value = _slicedToArray(_step62.value, 2),
                    index = _step62$value[0],
                    datum = _step62$value[1];

                var match = datum.match(/((?:[\s\d.])+):((?:\\:|[^:])+)/);
                if (match) {
                    this.data[index] = {
                        levels: this._getOutlineLevels(match[1]),
                        text: match[2].trim().replace(/\\([,:])/g, '$1'),
                        element: this
                    };
                } else {
                    this.addDebugError('data', '\'' + datum + '\' is not valid outline data (has to be in the form \'outline-number: topic\')');
                }
            }
        } catch (err) {
            _didIteratorError62 = true;
            _iteratorError62 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion62 && _iterator62.return) {
                    _iterator62.return();
                }
            } finally {
                if (_didIteratorError62) {
                    throw _iteratorError62;
                }
            }
        }

        this._listData = [];

        this.onGlobalAttach('_initiate');
    },

    _initiate: function _initiate() {
        this.cyoa = this.cyoa.replace(/\s/g, '').split(',');
        this.nodeLevelMap = {};
        var _iteratorNormalCompletion63 = true;
        var _didIteratorError63 = false;
        var _iteratorError63 = undefined;

        try {
            for (var _iterator63 = this.cyoa[Symbol.iterator](), _step63; !(_iteratorNormalCompletion63 = (_step63 = _iterator63.next()).done); _iteratorNormalCompletion63 = true) {
                var cyoaName = _step63.value;

                var cyoaElement = this.getGlobalNameElement(cyoaName, 'inkd-cyoa', 'cyoa');
                if (cyoaElement !== undefined) {
                    var data = [];
                    var _iteratorNormalCompletion64 = true;
                    var _didIteratorError64 = false;
                    var _iteratorError64 = undefined;

                    try {
                        for (var _iterator64 = cyoaElement.nodes[Symbol.iterator](), _step64; !(_iteratorNormalCompletion64 = (_step64 = _iterator64.next()).done); _iteratorNormalCompletion64 = true) {
                            var node = _step64.value;

                            if (node.number) {
                                var name = node.name,
                                    topic = node.topic,
                                    number = node.number;

                                var levels = this._getOutlineLevels(number);
                                data.push({ element: node, levels: levels, text: topic.trim(),
                                    link: {
                                        event: 'goto',
                                        detail: { gotoData: [{ element: this, gotos: [name] }] }
                                    }
                                });
                                this.nodeLevelMap[name] = levels;
                            }
                        }
                    } catch (err) {
                        _didIteratorError64 = true;
                        _iteratorError64 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion64 && _iterator64.return) {
                                _iterator64.return();
                            }
                        } finally {
                            if (_didIteratorError64) {
                                throw _iteratorError64;
                            }
                        }
                    }

                    this._addListData(data, 'number');
                    this.onGlobalChange(cyoaName + '.currentNode', '_handleCurrentNodeChange');
                    this.onGlobalChange(cyoaName + '.prevNode', '_handlePrevNodeChange');
                }
            }
        } catch (err) {
            _didIteratorError63 = true;
            _iteratorError63 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion63 && _iterator63.return) {
                    _iterator63.return();
                }
            } finally {
                if (_didIteratorError63) {
                    throw _iteratorError63;
                }
            }
        }

        this._addListData(this.data, 'data');
    },

    _addListData: function _addListData(data, attr) {
        var _iteratorNormalCompletion65 = true;
        var _didIteratorError65 = false;
        var _iteratorError65 = undefined;

        try {
            for (var _iterator65 = data[Symbol.iterator](), _step65; !(_iteratorNormalCompletion65 = (_step65 = _iterator65.next()).done); _iteratorNormalCompletion65 = true) {
                var datum = _step65.value;

                var levelData = this._listData;
                var lastIndex = datum.levels.length - 1;
                var _iteratorNormalCompletion66 = true;
                var _didIteratorError66 = false;
                var _iteratorError66 = undefined;

                try {
                    for (var _iterator66 = datum.levels.entries()[Symbol.iterator](), _step66; !(_iteratorNormalCompletion66 = (_step66 = _iterator66.next()).done); _iteratorNormalCompletion66 = true) {
                        var _step66$value = _slicedToArray(_step66.value, 2),
                            index = _step66$value[0],
                            num = _step66$value[1];

                        num = num - 1;
                        if (index === lastIndex) {
                            levelData[num] = levelData[num] || {};
                            if (levelData[num].text) {
                                this.addDebugWarn(attr, 'Outline number \'' + datum.levels.join('.') + '\' already set to \'' + levelData[num].text + '\'', datum.element);
                            } else {
                                levelData[num].text = datum.text;
                                levelData[num].link = datum.link || null;
                            }
                        } else {
                            levelData[num] = levelData[num] || {};
                            levelData[num].list = levelData[num].list || [];
                            levelData = levelData[num].list;
                        }
                    }
                } catch (err) {
                    _didIteratorError66 = true;
                    _iteratorError66 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion66 && _iterator66.return) {
                            _iterator66.return();
                        }
                    } finally {
                        if (_didIteratorError66) {
                            throw _iteratorError66;
                        }
                    }
                }
            }
        } catch (err) {
            _didIteratorError65 = true;
            _iteratorError65 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion65 && _iterator65.return) {
                    _iterator65.return();
                }
            } finally {
                if (_didIteratorError65) {
                    throw _iteratorError65;
                }
            }
        }

        this._listData = [].concat(this._listData);
    },

    _getOutlineLevels: function _getOutlineLevels(string) {
        return string.replace(/\s/g, '').split(/\.+/).filter(function (num) {
            return num !== '';
        }).map(function (num) {
            return Number(num);
        });
    },

    _getOutlinePath: function _getOutlinePath(node) {
        var levels = this.nodeLevelMap[node];
        if (levels !== undefined) {
            var path = ['_listData'];
            var lastIndex = levels.length - 1;
            var _iteratorNormalCompletion67 = true;
            var _didIteratorError67 = false;
            var _iteratorError67 = undefined;

            try {
                for (var _iterator67 = levels.entries()[Symbol.iterator](), _step67; !(_iteratorNormalCompletion67 = (_step67 = _iterator67.next()).done); _iteratorNormalCompletion67 = true) {
                    var _step67$value = _slicedToArray(_step67.value, 2),
                        index = _step67$value[0],
                        num = _step67$value[1];

                    path.push(num - 1);
                    if (index !== lastIndex) {
                        path.push('list');
                    }
                }
            } catch (err) {
                _didIteratorError67 = true;
                _iteratorError67 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion67 && _iterator67.return) {
                        _iterator67.return();
                    }
                } finally {
                    if (_didIteratorError67) {
                        throw _iteratorError67;
                    }
                }
            }

            return path;
        }
    },

    _handleCurrentNodeChange: function _handleCurrentNodeChange(_ref26) {
        var value = _ref26.detail.value;

        var path = this._getOutlinePath(value);
        if (path) {
            this.set(path.concat('active'), true);
            this.set(path.concat('visited'), true);
        }
    },

    _handlePrevNodeChange: function _handlePrevNodeChange(_ref27) {
        var value = _ref27.detail.value;

        var path = this._getOutlinePath(value);
        if (path) {
            this.set(path.concat('active'), false);
        }
    }
});</script></body></html>